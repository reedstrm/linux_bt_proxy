// This file is generated by rust-protobuf 3.7.2. Do not edit
// .proto file is parsed by protoc 3.21.12
// @generated

// https://github.com/rust-lang/rust-clippy/issues/702
#![allow(unknown_lints)]
#![allow(clippy::all)]

#![allow(unused_attributes)]
#![cfg_attr(rustfmt, rustfmt::skip)]

#![allow(dead_code)]
#![allow(missing_docs)]
#![allow(non_camel_case_types)]
#![allow(non_snake_case)]
#![allow(non_upper_case_globals)]
#![allow(trivial_casts)]
#![allow(unused_results)]
#![allow(unused_mut)]

//! Generated file from `api.proto`

/// Generated files are compatible only with the same version
/// of protobuf runtime.
const _PROTOBUF_VERSION_CHECK: () = ::protobuf::VERSION_3_7_2;

// @@protoc_insertion_point(message:HelloRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct HelloRequest {
    // message fields
    // @@protoc_insertion_point(field:HelloRequest.client_info)
    pub client_info: ::std::string::String,
    // @@protoc_insertion_point(field:HelloRequest.api_version_major)
    pub api_version_major: u32,
    // @@protoc_insertion_point(field:HelloRequest.api_version_minor)
    pub api_version_minor: u32,
    // special fields
    // @@protoc_insertion_point(special_field:HelloRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a HelloRequest {
    fn default() -> &'a HelloRequest {
        <HelloRequest as ::protobuf::Message>::default_instance()
    }
}

impl HelloRequest {
    pub fn new() -> HelloRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "client_info",
            |m: &HelloRequest| { &m.client_info },
            |m: &mut HelloRequest| { &mut m.client_info },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "api_version_major",
            |m: &HelloRequest| { &m.api_version_major },
            |m: &mut HelloRequest| { &mut m.api_version_major },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "api_version_minor",
            |m: &HelloRequest| { &m.api_version_minor },
            |m: &mut HelloRequest| { &mut m.api_version_minor },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<HelloRequest>(
            "HelloRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for HelloRequest {
    const NAME: &'static str = "HelloRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.client_info = is.read_string()?;
                },
                16 => {
                    self.api_version_major = is.read_uint32()?;
                },
                24 => {
                    self.api_version_minor = is.read_uint32()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.client_info.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.client_info);
        }
        if self.api_version_major != 0 {
            my_size += ::protobuf::rt::uint32_size(2, self.api_version_major);
        }
        if self.api_version_minor != 0 {
            my_size += ::protobuf::rt::uint32_size(3, self.api_version_minor);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.client_info.is_empty() {
            os.write_string(1, &self.client_info)?;
        }
        if self.api_version_major != 0 {
            os.write_uint32(2, self.api_version_major)?;
        }
        if self.api_version_minor != 0 {
            os.write_uint32(3, self.api_version_minor)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> HelloRequest {
        HelloRequest::new()
    }

    fn clear(&mut self) {
        self.client_info.clear();
        self.api_version_major = 0;
        self.api_version_minor = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static HelloRequest {
        static instance: HelloRequest = HelloRequest {
            client_info: ::std::string::String::new(),
            api_version_major: 0,
            api_version_minor: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for HelloRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("HelloRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for HelloRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for HelloRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:HelloResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct HelloResponse {
    // message fields
    // @@protoc_insertion_point(field:HelloResponse.api_version_major)
    pub api_version_major: u32,
    // @@protoc_insertion_point(field:HelloResponse.api_version_minor)
    pub api_version_minor: u32,
    // @@protoc_insertion_point(field:HelloResponse.server_info)
    pub server_info: ::std::string::String,
    // @@protoc_insertion_point(field:HelloResponse.name)
    pub name: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:HelloResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a HelloResponse {
    fn default() -> &'a HelloResponse {
        <HelloResponse as ::protobuf::Message>::default_instance()
    }
}

impl HelloResponse {
    pub fn new() -> HelloResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "api_version_major",
            |m: &HelloResponse| { &m.api_version_major },
            |m: &mut HelloResponse| { &mut m.api_version_major },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "api_version_minor",
            |m: &HelloResponse| { &m.api_version_minor },
            |m: &mut HelloResponse| { &mut m.api_version_minor },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "server_info",
            |m: &HelloResponse| { &m.server_info },
            |m: &mut HelloResponse| { &mut m.server_info },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "name",
            |m: &HelloResponse| { &m.name },
            |m: &mut HelloResponse| { &mut m.name },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<HelloResponse>(
            "HelloResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for HelloResponse {
    const NAME: &'static str = "HelloResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.api_version_major = is.read_uint32()?;
                },
                16 => {
                    self.api_version_minor = is.read_uint32()?;
                },
                26 => {
                    self.server_info = is.read_string()?;
                },
                34 => {
                    self.name = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.api_version_major != 0 {
            my_size += ::protobuf::rt::uint32_size(1, self.api_version_major);
        }
        if self.api_version_minor != 0 {
            my_size += ::protobuf::rt::uint32_size(2, self.api_version_minor);
        }
        if !self.server_info.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.server_info);
        }
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.name);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.api_version_major != 0 {
            os.write_uint32(1, self.api_version_major)?;
        }
        if self.api_version_minor != 0 {
            os.write_uint32(2, self.api_version_minor)?;
        }
        if !self.server_info.is_empty() {
            os.write_string(3, &self.server_info)?;
        }
        if !self.name.is_empty() {
            os.write_string(4, &self.name)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> HelloResponse {
        HelloResponse::new()
    }

    fn clear(&mut self) {
        self.api_version_major = 0;
        self.api_version_minor = 0;
        self.server_info.clear();
        self.name.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static HelloResponse {
        static instance: HelloResponse = HelloResponse {
            api_version_major: 0,
            api_version_minor: 0,
            server_info: ::std::string::String::new(),
            name: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for HelloResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("HelloResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for HelloResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for HelloResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:ConnectRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ConnectRequest {
    // message fields
    // @@protoc_insertion_point(field:ConnectRequest.password)
    pub password: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:ConnectRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ConnectRequest {
    fn default() -> &'a ConnectRequest {
        <ConnectRequest as ::protobuf::Message>::default_instance()
    }
}

impl ConnectRequest {
    pub fn new() -> ConnectRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "password",
            |m: &ConnectRequest| { &m.password },
            |m: &mut ConnectRequest| { &mut m.password },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ConnectRequest>(
            "ConnectRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ConnectRequest {
    const NAME: &'static str = "ConnectRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.password = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.password.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.password);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.password.is_empty() {
            os.write_string(1, &self.password)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ConnectRequest {
        ConnectRequest::new()
    }

    fn clear(&mut self) {
        self.password.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ConnectRequest {
        static instance: ConnectRequest = ConnectRequest {
            password: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ConnectRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ConnectRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ConnectRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ConnectRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:ConnectResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ConnectResponse {
    // message fields
    // @@protoc_insertion_point(field:ConnectResponse.invalid_password)
    pub invalid_password: bool,
    // special fields
    // @@protoc_insertion_point(special_field:ConnectResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ConnectResponse {
    fn default() -> &'a ConnectResponse {
        <ConnectResponse as ::protobuf::Message>::default_instance()
    }
}

impl ConnectResponse {
    pub fn new() -> ConnectResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "invalid_password",
            |m: &ConnectResponse| { &m.invalid_password },
            |m: &mut ConnectResponse| { &mut m.invalid_password },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ConnectResponse>(
            "ConnectResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ConnectResponse {
    const NAME: &'static str = "ConnectResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.invalid_password = is.read_bool()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.invalid_password != false {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.invalid_password != false {
            os.write_bool(1, self.invalid_password)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ConnectResponse {
        ConnectResponse::new()
    }

    fn clear(&mut self) {
        self.invalid_password = false;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ConnectResponse {
        static instance: ConnectResponse = ConnectResponse {
            invalid_password: false,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ConnectResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ConnectResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ConnectResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ConnectResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:DisconnectRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct DisconnectRequest {
    // special fields
    // @@protoc_insertion_point(special_field:DisconnectRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a DisconnectRequest {
    fn default() -> &'a DisconnectRequest {
        <DisconnectRequest as ::protobuf::Message>::default_instance()
    }
}

impl DisconnectRequest {
    pub fn new() -> DisconnectRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(0);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<DisconnectRequest>(
            "DisconnectRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for DisconnectRequest {
    const NAME: &'static str = "DisconnectRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> DisconnectRequest {
        DisconnectRequest::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static DisconnectRequest {
        static instance: DisconnectRequest = DisconnectRequest {
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for DisconnectRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("DisconnectRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for DisconnectRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DisconnectRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:DisconnectResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct DisconnectResponse {
    // special fields
    // @@protoc_insertion_point(special_field:DisconnectResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a DisconnectResponse {
    fn default() -> &'a DisconnectResponse {
        <DisconnectResponse as ::protobuf::Message>::default_instance()
    }
}

impl DisconnectResponse {
    pub fn new() -> DisconnectResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(0);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<DisconnectResponse>(
            "DisconnectResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for DisconnectResponse {
    const NAME: &'static str = "DisconnectResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> DisconnectResponse {
        DisconnectResponse::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static DisconnectResponse {
        static instance: DisconnectResponse = DisconnectResponse {
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for DisconnectResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("DisconnectResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for DisconnectResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DisconnectResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:PingRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct PingRequest {
    // special fields
    // @@protoc_insertion_point(special_field:PingRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a PingRequest {
    fn default() -> &'a PingRequest {
        <PingRequest as ::protobuf::Message>::default_instance()
    }
}

impl PingRequest {
    pub fn new() -> PingRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(0);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<PingRequest>(
            "PingRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for PingRequest {
    const NAME: &'static str = "PingRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> PingRequest {
        PingRequest::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static PingRequest {
        static instance: PingRequest = PingRequest {
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for PingRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("PingRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for PingRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PingRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:PingResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct PingResponse {
    // special fields
    // @@protoc_insertion_point(special_field:PingResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a PingResponse {
    fn default() -> &'a PingResponse {
        <PingResponse as ::protobuf::Message>::default_instance()
    }
}

impl PingResponse {
    pub fn new() -> PingResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(0);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<PingResponse>(
            "PingResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for PingResponse {
    const NAME: &'static str = "PingResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> PingResponse {
        PingResponse::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static PingResponse {
        static instance: PingResponse = PingResponse {
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for PingResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("PingResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for PingResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for PingResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:DeviceInfoRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct DeviceInfoRequest {
    // special fields
    // @@protoc_insertion_point(special_field:DeviceInfoRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a DeviceInfoRequest {
    fn default() -> &'a DeviceInfoRequest {
        <DeviceInfoRequest as ::protobuf::Message>::default_instance()
    }
}

impl DeviceInfoRequest {
    pub fn new() -> DeviceInfoRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(0);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<DeviceInfoRequest>(
            "DeviceInfoRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for DeviceInfoRequest {
    const NAME: &'static str = "DeviceInfoRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> DeviceInfoRequest {
        DeviceInfoRequest::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static DeviceInfoRequest {
        static instance: DeviceInfoRequest = DeviceInfoRequest {
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for DeviceInfoRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("DeviceInfoRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for DeviceInfoRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DeviceInfoRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:AreaInfo)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct AreaInfo {
    // message fields
    // @@protoc_insertion_point(field:AreaInfo.area_id)
    pub area_id: u32,
    // @@protoc_insertion_point(field:AreaInfo.name)
    pub name: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:AreaInfo.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a AreaInfo {
    fn default() -> &'a AreaInfo {
        <AreaInfo as ::protobuf::Message>::default_instance()
    }
}

impl AreaInfo {
    pub fn new() -> AreaInfo {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "area_id",
            |m: &AreaInfo| { &m.area_id },
            |m: &mut AreaInfo| { &mut m.area_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "name",
            |m: &AreaInfo| { &m.name },
            |m: &mut AreaInfo| { &mut m.name },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<AreaInfo>(
            "AreaInfo",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for AreaInfo {
    const NAME: &'static str = "AreaInfo";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.area_id = is.read_uint32()?;
                },
                18 => {
                    self.name = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.area_id != 0 {
            my_size += ::protobuf::rt::uint32_size(1, self.area_id);
        }
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.name);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.area_id != 0 {
            os.write_uint32(1, self.area_id)?;
        }
        if !self.name.is_empty() {
            os.write_string(2, &self.name)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> AreaInfo {
        AreaInfo::new()
    }

    fn clear(&mut self) {
        self.area_id = 0;
        self.name.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static AreaInfo {
        static instance: AreaInfo = AreaInfo {
            area_id: 0,
            name: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for AreaInfo {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("AreaInfo").unwrap()).clone()
    }
}

impl ::std::fmt::Display for AreaInfo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AreaInfo {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:DeviceInfo)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct DeviceInfo {
    // message fields
    // @@protoc_insertion_point(field:DeviceInfo.device_id)
    pub device_id: u32,
    // @@protoc_insertion_point(field:DeviceInfo.name)
    pub name: ::std::string::String,
    // @@protoc_insertion_point(field:DeviceInfo.area_id)
    pub area_id: u32,
    // special fields
    // @@protoc_insertion_point(special_field:DeviceInfo.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a DeviceInfo {
    fn default() -> &'a DeviceInfo {
        <DeviceInfo as ::protobuf::Message>::default_instance()
    }
}

impl DeviceInfo {
    pub fn new() -> DeviceInfo {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "device_id",
            |m: &DeviceInfo| { &m.device_id },
            |m: &mut DeviceInfo| { &mut m.device_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "name",
            |m: &DeviceInfo| { &m.name },
            |m: &mut DeviceInfo| { &mut m.name },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "area_id",
            |m: &DeviceInfo| { &m.area_id },
            |m: &mut DeviceInfo| { &mut m.area_id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<DeviceInfo>(
            "DeviceInfo",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for DeviceInfo {
    const NAME: &'static str = "DeviceInfo";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.device_id = is.read_uint32()?;
                },
                18 => {
                    self.name = is.read_string()?;
                },
                24 => {
                    self.area_id = is.read_uint32()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.device_id != 0 {
            my_size += ::protobuf::rt::uint32_size(1, self.device_id);
        }
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.name);
        }
        if self.area_id != 0 {
            my_size += ::protobuf::rt::uint32_size(3, self.area_id);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.device_id != 0 {
            os.write_uint32(1, self.device_id)?;
        }
        if !self.name.is_empty() {
            os.write_string(2, &self.name)?;
        }
        if self.area_id != 0 {
            os.write_uint32(3, self.area_id)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> DeviceInfo {
        DeviceInfo::new()
    }

    fn clear(&mut self) {
        self.device_id = 0;
        self.name.clear();
        self.area_id = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static DeviceInfo {
        static instance: DeviceInfo = DeviceInfo {
            device_id: 0,
            name: ::std::string::String::new(),
            area_id: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for DeviceInfo {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("DeviceInfo").unwrap()).clone()
    }
}

impl ::std::fmt::Display for DeviceInfo {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DeviceInfo {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:DeviceInfoResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct DeviceInfoResponse {
    // message fields
    // @@protoc_insertion_point(field:DeviceInfoResponse.uses_password)
    pub uses_password: bool,
    // @@protoc_insertion_point(field:DeviceInfoResponse.name)
    pub name: ::std::string::String,
    // @@protoc_insertion_point(field:DeviceInfoResponse.mac_address)
    pub mac_address: ::std::string::String,
    // @@protoc_insertion_point(field:DeviceInfoResponse.esphome_version)
    pub esphome_version: ::std::string::String,
    // @@protoc_insertion_point(field:DeviceInfoResponse.compilation_time)
    pub compilation_time: ::std::string::String,
    // @@protoc_insertion_point(field:DeviceInfoResponse.model)
    pub model: ::std::string::String,
    // @@protoc_insertion_point(field:DeviceInfoResponse.has_deep_sleep)
    pub has_deep_sleep: bool,
    // @@protoc_insertion_point(field:DeviceInfoResponse.project_name)
    pub project_name: ::std::string::String,
    // @@protoc_insertion_point(field:DeviceInfoResponse.project_version)
    pub project_version: ::std::string::String,
    // @@protoc_insertion_point(field:DeviceInfoResponse.webserver_port)
    pub webserver_port: u32,
    // @@protoc_insertion_point(field:DeviceInfoResponse.legacy_bluetooth_proxy_version)
    pub legacy_bluetooth_proxy_version: u32,
    // @@protoc_insertion_point(field:DeviceInfoResponse.bluetooth_proxy_feature_flags)
    pub bluetooth_proxy_feature_flags: u32,
    // @@protoc_insertion_point(field:DeviceInfoResponse.manufacturer)
    pub manufacturer: ::std::string::String,
    // @@protoc_insertion_point(field:DeviceInfoResponse.friendly_name)
    pub friendly_name: ::std::string::String,
    // @@protoc_insertion_point(field:DeviceInfoResponse.legacy_voice_assistant_version)
    pub legacy_voice_assistant_version: u32,
    // @@protoc_insertion_point(field:DeviceInfoResponse.voice_assistant_feature_flags)
    pub voice_assistant_feature_flags: u32,
    // @@protoc_insertion_point(field:DeviceInfoResponse.suggested_area)
    pub suggested_area: ::std::string::String,
    // @@protoc_insertion_point(field:DeviceInfoResponse.bluetooth_mac_address)
    pub bluetooth_mac_address: ::std::string::String,
    // @@protoc_insertion_point(field:DeviceInfoResponse.api_encryption_supported)
    pub api_encryption_supported: bool,
    // @@protoc_insertion_point(field:DeviceInfoResponse.devices)
    pub devices: ::std::vec::Vec<DeviceInfo>,
    // @@protoc_insertion_point(field:DeviceInfoResponse.areas)
    pub areas: ::std::vec::Vec<AreaInfo>,
    // @@protoc_insertion_point(field:DeviceInfoResponse.area)
    pub area: ::protobuf::MessageField<AreaInfo>,
    // special fields
    // @@protoc_insertion_point(special_field:DeviceInfoResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a DeviceInfoResponse {
    fn default() -> &'a DeviceInfoResponse {
        <DeviceInfoResponse as ::protobuf::Message>::default_instance()
    }
}

impl DeviceInfoResponse {
    pub fn new() -> DeviceInfoResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(22);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "uses_password",
            |m: &DeviceInfoResponse| { &m.uses_password },
            |m: &mut DeviceInfoResponse| { &mut m.uses_password },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "name",
            |m: &DeviceInfoResponse| { &m.name },
            |m: &mut DeviceInfoResponse| { &mut m.name },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "mac_address",
            |m: &DeviceInfoResponse| { &m.mac_address },
            |m: &mut DeviceInfoResponse| { &mut m.mac_address },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "esphome_version",
            |m: &DeviceInfoResponse| { &m.esphome_version },
            |m: &mut DeviceInfoResponse| { &mut m.esphome_version },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "compilation_time",
            |m: &DeviceInfoResponse| { &m.compilation_time },
            |m: &mut DeviceInfoResponse| { &mut m.compilation_time },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "model",
            |m: &DeviceInfoResponse| { &m.model },
            |m: &mut DeviceInfoResponse| { &mut m.model },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "has_deep_sleep",
            |m: &DeviceInfoResponse| { &m.has_deep_sleep },
            |m: &mut DeviceInfoResponse| { &mut m.has_deep_sleep },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "project_name",
            |m: &DeviceInfoResponse| { &m.project_name },
            |m: &mut DeviceInfoResponse| { &mut m.project_name },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "project_version",
            |m: &DeviceInfoResponse| { &m.project_version },
            |m: &mut DeviceInfoResponse| { &mut m.project_version },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "webserver_port",
            |m: &DeviceInfoResponse| { &m.webserver_port },
            |m: &mut DeviceInfoResponse| { &mut m.webserver_port },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "legacy_bluetooth_proxy_version",
            |m: &DeviceInfoResponse| { &m.legacy_bluetooth_proxy_version },
            |m: &mut DeviceInfoResponse| { &mut m.legacy_bluetooth_proxy_version },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "bluetooth_proxy_feature_flags",
            |m: &DeviceInfoResponse| { &m.bluetooth_proxy_feature_flags },
            |m: &mut DeviceInfoResponse| { &mut m.bluetooth_proxy_feature_flags },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "manufacturer",
            |m: &DeviceInfoResponse| { &m.manufacturer },
            |m: &mut DeviceInfoResponse| { &mut m.manufacturer },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "friendly_name",
            |m: &DeviceInfoResponse| { &m.friendly_name },
            |m: &mut DeviceInfoResponse| { &mut m.friendly_name },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "legacy_voice_assistant_version",
            |m: &DeviceInfoResponse| { &m.legacy_voice_assistant_version },
            |m: &mut DeviceInfoResponse| { &mut m.legacy_voice_assistant_version },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "voice_assistant_feature_flags",
            |m: &DeviceInfoResponse| { &m.voice_assistant_feature_flags },
            |m: &mut DeviceInfoResponse| { &mut m.voice_assistant_feature_flags },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "suggested_area",
            |m: &DeviceInfoResponse| { &m.suggested_area },
            |m: &mut DeviceInfoResponse| { &mut m.suggested_area },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "bluetooth_mac_address",
            |m: &DeviceInfoResponse| { &m.bluetooth_mac_address },
            |m: &mut DeviceInfoResponse| { &mut m.bluetooth_mac_address },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "api_encryption_supported",
            |m: &DeviceInfoResponse| { &m.api_encryption_supported },
            |m: &mut DeviceInfoResponse| { &mut m.api_encryption_supported },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "devices",
            |m: &DeviceInfoResponse| { &m.devices },
            |m: &mut DeviceInfoResponse| { &mut m.devices },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "areas",
            |m: &DeviceInfoResponse| { &m.areas },
            |m: &mut DeviceInfoResponse| { &mut m.areas },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, AreaInfo>(
            "area",
            |m: &DeviceInfoResponse| { &m.area },
            |m: &mut DeviceInfoResponse| { &mut m.area },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<DeviceInfoResponse>(
            "DeviceInfoResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for DeviceInfoResponse {
    const NAME: &'static str = "DeviceInfoResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.uses_password = is.read_bool()?;
                },
                18 => {
                    self.name = is.read_string()?;
                },
                26 => {
                    self.mac_address = is.read_string()?;
                },
                34 => {
                    self.esphome_version = is.read_string()?;
                },
                42 => {
                    self.compilation_time = is.read_string()?;
                },
                50 => {
                    self.model = is.read_string()?;
                },
                56 => {
                    self.has_deep_sleep = is.read_bool()?;
                },
                66 => {
                    self.project_name = is.read_string()?;
                },
                74 => {
                    self.project_version = is.read_string()?;
                },
                80 => {
                    self.webserver_port = is.read_uint32()?;
                },
                88 => {
                    self.legacy_bluetooth_proxy_version = is.read_uint32()?;
                },
                120 => {
                    self.bluetooth_proxy_feature_flags = is.read_uint32()?;
                },
                98 => {
                    self.manufacturer = is.read_string()?;
                },
                106 => {
                    self.friendly_name = is.read_string()?;
                },
                112 => {
                    self.legacy_voice_assistant_version = is.read_uint32()?;
                },
                136 => {
                    self.voice_assistant_feature_flags = is.read_uint32()?;
                },
                130 => {
                    self.suggested_area = is.read_string()?;
                },
                146 => {
                    self.bluetooth_mac_address = is.read_string()?;
                },
                152 => {
                    self.api_encryption_supported = is.read_bool()?;
                },
                162 => {
                    self.devices.push(is.read_message()?);
                },
                170 => {
                    self.areas.push(is.read_message()?);
                },
                178 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.area)?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.uses_password != false {
            my_size += 1 + 1;
        }
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.name);
        }
        if !self.mac_address.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.mac_address);
        }
        if !self.esphome_version.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.esphome_version);
        }
        if !self.compilation_time.is_empty() {
            my_size += ::protobuf::rt::string_size(5, &self.compilation_time);
        }
        if !self.model.is_empty() {
            my_size += ::protobuf::rt::string_size(6, &self.model);
        }
        if self.has_deep_sleep != false {
            my_size += 1 + 1;
        }
        if !self.project_name.is_empty() {
            my_size += ::protobuf::rt::string_size(8, &self.project_name);
        }
        if !self.project_version.is_empty() {
            my_size += ::protobuf::rt::string_size(9, &self.project_version);
        }
        if self.webserver_port != 0 {
            my_size += ::protobuf::rt::uint32_size(10, self.webserver_port);
        }
        if self.legacy_bluetooth_proxy_version != 0 {
            my_size += ::protobuf::rt::uint32_size(11, self.legacy_bluetooth_proxy_version);
        }
        if self.bluetooth_proxy_feature_flags != 0 {
            my_size += ::protobuf::rt::uint32_size(15, self.bluetooth_proxy_feature_flags);
        }
        if !self.manufacturer.is_empty() {
            my_size += ::protobuf::rt::string_size(12, &self.manufacturer);
        }
        if !self.friendly_name.is_empty() {
            my_size += ::protobuf::rt::string_size(13, &self.friendly_name);
        }
        if self.legacy_voice_assistant_version != 0 {
            my_size += ::protobuf::rt::uint32_size(14, self.legacy_voice_assistant_version);
        }
        if self.voice_assistant_feature_flags != 0 {
            my_size += ::protobuf::rt::uint32_size(17, self.voice_assistant_feature_flags);
        }
        if !self.suggested_area.is_empty() {
            my_size += ::protobuf::rt::string_size(16, &self.suggested_area);
        }
        if !self.bluetooth_mac_address.is_empty() {
            my_size += ::protobuf::rt::string_size(18, &self.bluetooth_mac_address);
        }
        if self.api_encryption_supported != false {
            my_size += 2 + 1;
        }
        for value in &self.devices {
            let len = value.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.areas {
            let len = value.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if let Some(v) = self.area.as_ref() {
            let len = v.compute_size();
            my_size += 2 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.uses_password != false {
            os.write_bool(1, self.uses_password)?;
        }
        if !self.name.is_empty() {
            os.write_string(2, &self.name)?;
        }
        if !self.mac_address.is_empty() {
            os.write_string(3, &self.mac_address)?;
        }
        if !self.esphome_version.is_empty() {
            os.write_string(4, &self.esphome_version)?;
        }
        if !self.compilation_time.is_empty() {
            os.write_string(5, &self.compilation_time)?;
        }
        if !self.model.is_empty() {
            os.write_string(6, &self.model)?;
        }
        if self.has_deep_sleep != false {
            os.write_bool(7, self.has_deep_sleep)?;
        }
        if !self.project_name.is_empty() {
            os.write_string(8, &self.project_name)?;
        }
        if !self.project_version.is_empty() {
            os.write_string(9, &self.project_version)?;
        }
        if self.webserver_port != 0 {
            os.write_uint32(10, self.webserver_port)?;
        }
        if self.legacy_bluetooth_proxy_version != 0 {
            os.write_uint32(11, self.legacy_bluetooth_proxy_version)?;
        }
        if self.bluetooth_proxy_feature_flags != 0 {
            os.write_uint32(15, self.bluetooth_proxy_feature_flags)?;
        }
        if !self.manufacturer.is_empty() {
            os.write_string(12, &self.manufacturer)?;
        }
        if !self.friendly_name.is_empty() {
            os.write_string(13, &self.friendly_name)?;
        }
        if self.legacy_voice_assistant_version != 0 {
            os.write_uint32(14, self.legacy_voice_assistant_version)?;
        }
        if self.voice_assistant_feature_flags != 0 {
            os.write_uint32(17, self.voice_assistant_feature_flags)?;
        }
        if !self.suggested_area.is_empty() {
            os.write_string(16, &self.suggested_area)?;
        }
        if !self.bluetooth_mac_address.is_empty() {
            os.write_string(18, &self.bluetooth_mac_address)?;
        }
        if self.api_encryption_supported != false {
            os.write_bool(19, self.api_encryption_supported)?;
        }
        for v in &self.devices {
            ::protobuf::rt::write_message_field_with_cached_size(20, v, os)?;
        };
        for v in &self.areas {
            ::protobuf::rt::write_message_field_with_cached_size(21, v, os)?;
        };
        if let Some(v) = self.area.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(22, v, os)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> DeviceInfoResponse {
        DeviceInfoResponse::new()
    }

    fn clear(&mut self) {
        self.uses_password = false;
        self.name.clear();
        self.mac_address.clear();
        self.esphome_version.clear();
        self.compilation_time.clear();
        self.model.clear();
        self.has_deep_sleep = false;
        self.project_name.clear();
        self.project_version.clear();
        self.webserver_port = 0;
        self.legacy_bluetooth_proxy_version = 0;
        self.bluetooth_proxy_feature_flags = 0;
        self.manufacturer.clear();
        self.friendly_name.clear();
        self.legacy_voice_assistant_version = 0;
        self.voice_assistant_feature_flags = 0;
        self.suggested_area.clear();
        self.bluetooth_mac_address.clear();
        self.api_encryption_supported = false;
        self.devices.clear();
        self.areas.clear();
        self.area.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static DeviceInfoResponse {
        static instance: DeviceInfoResponse = DeviceInfoResponse {
            uses_password: false,
            name: ::std::string::String::new(),
            mac_address: ::std::string::String::new(),
            esphome_version: ::std::string::String::new(),
            compilation_time: ::std::string::String::new(),
            model: ::std::string::String::new(),
            has_deep_sleep: false,
            project_name: ::std::string::String::new(),
            project_version: ::std::string::String::new(),
            webserver_port: 0,
            legacy_bluetooth_proxy_version: 0,
            bluetooth_proxy_feature_flags: 0,
            manufacturer: ::std::string::String::new(),
            friendly_name: ::std::string::String::new(),
            legacy_voice_assistant_version: 0,
            voice_assistant_feature_flags: 0,
            suggested_area: ::std::string::String::new(),
            bluetooth_mac_address: ::std::string::String::new(),
            api_encryption_supported: false,
            devices: ::std::vec::Vec::new(),
            areas: ::std::vec::Vec::new(),
            area: ::protobuf::MessageField::none(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for DeviceInfoResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("DeviceInfoResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for DeviceInfoResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DeviceInfoResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:ListEntitiesRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ListEntitiesRequest {
    // special fields
    // @@protoc_insertion_point(special_field:ListEntitiesRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ListEntitiesRequest {
    fn default() -> &'a ListEntitiesRequest {
        <ListEntitiesRequest as ::protobuf::Message>::default_instance()
    }
}

impl ListEntitiesRequest {
    pub fn new() -> ListEntitiesRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(0);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ListEntitiesRequest>(
            "ListEntitiesRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ListEntitiesRequest {
    const NAME: &'static str = "ListEntitiesRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ListEntitiesRequest {
        ListEntitiesRequest::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ListEntitiesRequest {
        static instance: ListEntitiesRequest = ListEntitiesRequest {
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ListEntitiesRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ListEntitiesRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ListEntitiesRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ListEntitiesRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:ListEntitiesDoneResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ListEntitiesDoneResponse {
    // special fields
    // @@protoc_insertion_point(special_field:ListEntitiesDoneResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ListEntitiesDoneResponse {
    fn default() -> &'a ListEntitiesDoneResponse {
        <ListEntitiesDoneResponse as ::protobuf::Message>::default_instance()
    }
}

impl ListEntitiesDoneResponse {
    pub fn new() -> ListEntitiesDoneResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(0);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ListEntitiesDoneResponse>(
            "ListEntitiesDoneResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ListEntitiesDoneResponse {
    const NAME: &'static str = "ListEntitiesDoneResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ListEntitiesDoneResponse {
        ListEntitiesDoneResponse::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ListEntitiesDoneResponse {
        static instance: ListEntitiesDoneResponse = ListEntitiesDoneResponse {
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ListEntitiesDoneResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ListEntitiesDoneResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ListEntitiesDoneResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ListEntitiesDoneResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:SubscribeStatesRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct SubscribeStatesRequest {
    // special fields
    // @@protoc_insertion_point(special_field:SubscribeStatesRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a SubscribeStatesRequest {
    fn default() -> &'a SubscribeStatesRequest {
        <SubscribeStatesRequest as ::protobuf::Message>::default_instance()
    }
}

impl SubscribeStatesRequest {
    pub fn new() -> SubscribeStatesRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(0);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<SubscribeStatesRequest>(
            "SubscribeStatesRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for SubscribeStatesRequest {
    const NAME: &'static str = "SubscribeStatesRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> SubscribeStatesRequest {
        SubscribeStatesRequest::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static SubscribeStatesRequest {
        static instance: SubscribeStatesRequest = SubscribeStatesRequest {
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for SubscribeStatesRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("SubscribeStatesRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for SubscribeStatesRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SubscribeStatesRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:ListEntitiesBinarySensorResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ListEntitiesBinarySensorResponse {
    // message fields
    // @@protoc_insertion_point(field:ListEntitiesBinarySensorResponse.object_id)
    pub object_id: ::std::string::String,
    // @@protoc_insertion_point(field:ListEntitiesBinarySensorResponse.key)
    pub key: u32,
    // @@protoc_insertion_point(field:ListEntitiesBinarySensorResponse.name)
    pub name: ::std::string::String,
    // @@protoc_insertion_point(field:ListEntitiesBinarySensorResponse.unique_id)
    pub unique_id: ::std::string::String,
    // @@protoc_insertion_point(field:ListEntitiesBinarySensorResponse.device_class)
    pub device_class: ::std::string::String,
    // @@protoc_insertion_point(field:ListEntitiesBinarySensorResponse.is_status_binary_sensor)
    pub is_status_binary_sensor: bool,
    // @@protoc_insertion_point(field:ListEntitiesBinarySensorResponse.disabled_by_default)
    pub disabled_by_default: bool,
    // @@protoc_insertion_point(field:ListEntitiesBinarySensorResponse.icon)
    pub icon: ::std::string::String,
    // @@protoc_insertion_point(field:ListEntitiesBinarySensorResponse.entity_category)
    pub entity_category: ::protobuf::EnumOrUnknown<EntityCategory>,
    // @@protoc_insertion_point(field:ListEntitiesBinarySensorResponse.device_id)
    pub device_id: u32,
    // special fields
    // @@protoc_insertion_point(special_field:ListEntitiesBinarySensorResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ListEntitiesBinarySensorResponse {
    fn default() -> &'a ListEntitiesBinarySensorResponse {
        <ListEntitiesBinarySensorResponse as ::protobuf::Message>::default_instance()
    }
}

impl ListEntitiesBinarySensorResponse {
    pub fn new() -> ListEntitiesBinarySensorResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(10);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "object_id",
            |m: &ListEntitiesBinarySensorResponse| { &m.object_id },
            |m: &mut ListEntitiesBinarySensorResponse| { &mut m.object_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "key",
            |m: &ListEntitiesBinarySensorResponse| { &m.key },
            |m: &mut ListEntitiesBinarySensorResponse| { &mut m.key },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "name",
            |m: &ListEntitiesBinarySensorResponse| { &m.name },
            |m: &mut ListEntitiesBinarySensorResponse| { &mut m.name },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "unique_id",
            |m: &ListEntitiesBinarySensorResponse| { &m.unique_id },
            |m: &mut ListEntitiesBinarySensorResponse| { &mut m.unique_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "device_class",
            |m: &ListEntitiesBinarySensorResponse| { &m.device_class },
            |m: &mut ListEntitiesBinarySensorResponse| { &mut m.device_class },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "is_status_binary_sensor",
            |m: &ListEntitiesBinarySensorResponse| { &m.is_status_binary_sensor },
            |m: &mut ListEntitiesBinarySensorResponse| { &mut m.is_status_binary_sensor },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "disabled_by_default",
            |m: &ListEntitiesBinarySensorResponse| { &m.disabled_by_default },
            |m: &mut ListEntitiesBinarySensorResponse| { &mut m.disabled_by_default },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "icon",
            |m: &ListEntitiesBinarySensorResponse| { &m.icon },
            |m: &mut ListEntitiesBinarySensorResponse| { &mut m.icon },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "entity_category",
            |m: &ListEntitiesBinarySensorResponse| { &m.entity_category },
            |m: &mut ListEntitiesBinarySensorResponse| { &mut m.entity_category },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "device_id",
            |m: &ListEntitiesBinarySensorResponse| { &m.device_id },
            |m: &mut ListEntitiesBinarySensorResponse| { &mut m.device_id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ListEntitiesBinarySensorResponse>(
            "ListEntitiesBinarySensorResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ListEntitiesBinarySensorResponse {
    const NAME: &'static str = "ListEntitiesBinarySensorResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.object_id = is.read_string()?;
                },
                21 => {
                    self.key = is.read_fixed32()?;
                },
                26 => {
                    self.name = is.read_string()?;
                },
                34 => {
                    self.unique_id = is.read_string()?;
                },
                42 => {
                    self.device_class = is.read_string()?;
                },
                48 => {
                    self.is_status_binary_sensor = is.read_bool()?;
                },
                56 => {
                    self.disabled_by_default = is.read_bool()?;
                },
                66 => {
                    self.icon = is.read_string()?;
                },
                72 => {
                    self.entity_category = is.read_enum_or_unknown()?;
                },
                80 => {
                    self.device_id = is.read_uint32()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.object_id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.object_id);
        }
        if self.key != 0 {
            my_size += 1 + 4;
        }
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.name);
        }
        if !self.unique_id.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.unique_id);
        }
        if !self.device_class.is_empty() {
            my_size += ::protobuf::rt::string_size(5, &self.device_class);
        }
        if self.is_status_binary_sensor != false {
            my_size += 1 + 1;
        }
        if self.disabled_by_default != false {
            my_size += 1 + 1;
        }
        if !self.icon.is_empty() {
            my_size += ::protobuf::rt::string_size(8, &self.icon);
        }
        if self.entity_category != ::protobuf::EnumOrUnknown::new(EntityCategory::ENTITY_CATEGORY_NONE) {
            my_size += ::protobuf::rt::int32_size(9, self.entity_category.value());
        }
        if self.device_id != 0 {
            my_size += ::protobuf::rt::uint32_size(10, self.device_id);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.object_id.is_empty() {
            os.write_string(1, &self.object_id)?;
        }
        if self.key != 0 {
            os.write_fixed32(2, self.key)?;
        }
        if !self.name.is_empty() {
            os.write_string(3, &self.name)?;
        }
        if !self.unique_id.is_empty() {
            os.write_string(4, &self.unique_id)?;
        }
        if !self.device_class.is_empty() {
            os.write_string(5, &self.device_class)?;
        }
        if self.is_status_binary_sensor != false {
            os.write_bool(6, self.is_status_binary_sensor)?;
        }
        if self.disabled_by_default != false {
            os.write_bool(7, self.disabled_by_default)?;
        }
        if !self.icon.is_empty() {
            os.write_string(8, &self.icon)?;
        }
        if self.entity_category != ::protobuf::EnumOrUnknown::new(EntityCategory::ENTITY_CATEGORY_NONE) {
            os.write_enum(9, ::protobuf::EnumOrUnknown::value(&self.entity_category))?;
        }
        if self.device_id != 0 {
            os.write_uint32(10, self.device_id)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ListEntitiesBinarySensorResponse {
        ListEntitiesBinarySensorResponse::new()
    }

    fn clear(&mut self) {
        self.object_id.clear();
        self.key = 0;
        self.name.clear();
        self.unique_id.clear();
        self.device_class.clear();
        self.is_status_binary_sensor = false;
        self.disabled_by_default = false;
        self.icon.clear();
        self.entity_category = ::protobuf::EnumOrUnknown::new(EntityCategory::ENTITY_CATEGORY_NONE);
        self.device_id = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ListEntitiesBinarySensorResponse {
        static instance: ListEntitiesBinarySensorResponse = ListEntitiesBinarySensorResponse {
            object_id: ::std::string::String::new(),
            key: 0,
            name: ::std::string::String::new(),
            unique_id: ::std::string::String::new(),
            device_class: ::std::string::String::new(),
            is_status_binary_sensor: false,
            disabled_by_default: false,
            icon: ::std::string::String::new(),
            entity_category: ::protobuf::EnumOrUnknown::from_i32(0),
            device_id: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ListEntitiesBinarySensorResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ListEntitiesBinarySensorResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ListEntitiesBinarySensorResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ListEntitiesBinarySensorResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:BinarySensorStateResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct BinarySensorStateResponse {
    // message fields
    // @@protoc_insertion_point(field:BinarySensorStateResponse.key)
    pub key: u32,
    // @@protoc_insertion_point(field:BinarySensorStateResponse.state)
    pub state: bool,
    // @@protoc_insertion_point(field:BinarySensorStateResponse.missing_state)
    pub missing_state: bool,
    // @@protoc_insertion_point(field:BinarySensorStateResponse.device_id)
    pub device_id: u32,
    // special fields
    // @@protoc_insertion_point(special_field:BinarySensorStateResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a BinarySensorStateResponse {
    fn default() -> &'a BinarySensorStateResponse {
        <BinarySensorStateResponse as ::protobuf::Message>::default_instance()
    }
}

impl BinarySensorStateResponse {
    pub fn new() -> BinarySensorStateResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "key",
            |m: &BinarySensorStateResponse| { &m.key },
            |m: &mut BinarySensorStateResponse| { &mut m.key },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "state",
            |m: &BinarySensorStateResponse| { &m.state },
            |m: &mut BinarySensorStateResponse| { &mut m.state },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "missing_state",
            |m: &BinarySensorStateResponse| { &m.missing_state },
            |m: &mut BinarySensorStateResponse| { &mut m.missing_state },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "device_id",
            |m: &BinarySensorStateResponse| { &m.device_id },
            |m: &mut BinarySensorStateResponse| { &mut m.device_id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<BinarySensorStateResponse>(
            "BinarySensorStateResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for BinarySensorStateResponse {
    const NAME: &'static str = "BinarySensorStateResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                13 => {
                    self.key = is.read_fixed32()?;
                },
                16 => {
                    self.state = is.read_bool()?;
                },
                24 => {
                    self.missing_state = is.read_bool()?;
                },
                32 => {
                    self.device_id = is.read_uint32()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.key != 0 {
            my_size += 1 + 4;
        }
        if self.state != false {
            my_size += 1 + 1;
        }
        if self.missing_state != false {
            my_size += 1 + 1;
        }
        if self.device_id != 0 {
            my_size += ::protobuf::rt::uint32_size(4, self.device_id);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.key != 0 {
            os.write_fixed32(1, self.key)?;
        }
        if self.state != false {
            os.write_bool(2, self.state)?;
        }
        if self.missing_state != false {
            os.write_bool(3, self.missing_state)?;
        }
        if self.device_id != 0 {
            os.write_uint32(4, self.device_id)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> BinarySensorStateResponse {
        BinarySensorStateResponse::new()
    }

    fn clear(&mut self) {
        self.key = 0;
        self.state = false;
        self.missing_state = false;
        self.device_id = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static BinarySensorStateResponse {
        static instance: BinarySensorStateResponse = BinarySensorStateResponse {
            key: 0,
            state: false,
            missing_state: false,
            device_id: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for BinarySensorStateResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("BinarySensorStateResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for BinarySensorStateResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for BinarySensorStateResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:ListEntitiesCoverResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ListEntitiesCoverResponse {
    // message fields
    // @@protoc_insertion_point(field:ListEntitiesCoverResponse.object_id)
    pub object_id: ::std::string::String,
    // @@protoc_insertion_point(field:ListEntitiesCoverResponse.key)
    pub key: u32,
    // @@protoc_insertion_point(field:ListEntitiesCoverResponse.name)
    pub name: ::std::string::String,
    // @@protoc_insertion_point(field:ListEntitiesCoverResponse.unique_id)
    pub unique_id: ::std::string::String,
    // @@protoc_insertion_point(field:ListEntitiesCoverResponse.assumed_state)
    pub assumed_state: bool,
    // @@protoc_insertion_point(field:ListEntitiesCoverResponse.supports_position)
    pub supports_position: bool,
    // @@protoc_insertion_point(field:ListEntitiesCoverResponse.supports_tilt)
    pub supports_tilt: bool,
    // @@protoc_insertion_point(field:ListEntitiesCoverResponse.device_class)
    pub device_class: ::std::string::String,
    // @@protoc_insertion_point(field:ListEntitiesCoverResponse.disabled_by_default)
    pub disabled_by_default: bool,
    // @@protoc_insertion_point(field:ListEntitiesCoverResponse.icon)
    pub icon: ::std::string::String,
    // @@protoc_insertion_point(field:ListEntitiesCoverResponse.entity_category)
    pub entity_category: ::protobuf::EnumOrUnknown<EntityCategory>,
    // @@protoc_insertion_point(field:ListEntitiesCoverResponse.supports_stop)
    pub supports_stop: bool,
    // @@protoc_insertion_point(field:ListEntitiesCoverResponse.device_id)
    pub device_id: u32,
    // special fields
    // @@protoc_insertion_point(special_field:ListEntitiesCoverResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ListEntitiesCoverResponse {
    fn default() -> &'a ListEntitiesCoverResponse {
        <ListEntitiesCoverResponse as ::protobuf::Message>::default_instance()
    }
}

impl ListEntitiesCoverResponse {
    pub fn new() -> ListEntitiesCoverResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(13);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "object_id",
            |m: &ListEntitiesCoverResponse| { &m.object_id },
            |m: &mut ListEntitiesCoverResponse| { &mut m.object_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "key",
            |m: &ListEntitiesCoverResponse| { &m.key },
            |m: &mut ListEntitiesCoverResponse| { &mut m.key },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "name",
            |m: &ListEntitiesCoverResponse| { &m.name },
            |m: &mut ListEntitiesCoverResponse| { &mut m.name },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "unique_id",
            |m: &ListEntitiesCoverResponse| { &m.unique_id },
            |m: &mut ListEntitiesCoverResponse| { &mut m.unique_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "assumed_state",
            |m: &ListEntitiesCoverResponse| { &m.assumed_state },
            |m: &mut ListEntitiesCoverResponse| { &mut m.assumed_state },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "supports_position",
            |m: &ListEntitiesCoverResponse| { &m.supports_position },
            |m: &mut ListEntitiesCoverResponse| { &mut m.supports_position },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "supports_tilt",
            |m: &ListEntitiesCoverResponse| { &m.supports_tilt },
            |m: &mut ListEntitiesCoverResponse| { &mut m.supports_tilt },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "device_class",
            |m: &ListEntitiesCoverResponse| { &m.device_class },
            |m: &mut ListEntitiesCoverResponse| { &mut m.device_class },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "disabled_by_default",
            |m: &ListEntitiesCoverResponse| { &m.disabled_by_default },
            |m: &mut ListEntitiesCoverResponse| { &mut m.disabled_by_default },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "icon",
            |m: &ListEntitiesCoverResponse| { &m.icon },
            |m: &mut ListEntitiesCoverResponse| { &mut m.icon },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "entity_category",
            |m: &ListEntitiesCoverResponse| { &m.entity_category },
            |m: &mut ListEntitiesCoverResponse| { &mut m.entity_category },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "supports_stop",
            |m: &ListEntitiesCoverResponse| { &m.supports_stop },
            |m: &mut ListEntitiesCoverResponse| { &mut m.supports_stop },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "device_id",
            |m: &ListEntitiesCoverResponse| { &m.device_id },
            |m: &mut ListEntitiesCoverResponse| { &mut m.device_id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ListEntitiesCoverResponse>(
            "ListEntitiesCoverResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ListEntitiesCoverResponse {
    const NAME: &'static str = "ListEntitiesCoverResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.object_id = is.read_string()?;
                },
                21 => {
                    self.key = is.read_fixed32()?;
                },
                26 => {
                    self.name = is.read_string()?;
                },
                34 => {
                    self.unique_id = is.read_string()?;
                },
                40 => {
                    self.assumed_state = is.read_bool()?;
                },
                48 => {
                    self.supports_position = is.read_bool()?;
                },
                56 => {
                    self.supports_tilt = is.read_bool()?;
                },
                66 => {
                    self.device_class = is.read_string()?;
                },
                72 => {
                    self.disabled_by_default = is.read_bool()?;
                },
                82 => {
                    self.icon = is.read_string()?;
                },
                88 => {
                    self.entity_category = is.read_enum_or_unknown()?;
                },
                96 => {
                    self.supports_stop = is.read_bool()?;
                },
                104 => {
                    self.device_id = is.read_uint32()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.object_id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.object_id);
        }
        if self.key != 0 {
            my_size += 1 + 4;
        }
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.name);
        }
        if !self.unique_id.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.unique_id);
        }
        if self.assumed_state != false {
            my_size += 1 + 1;
        }
        if self.supports_position != false {
            my_size += 1 + 1;
        }
        if self.supports_tilt != false {
            my_size += 1 + 1;
        }
        if !self.device_class.is_empty() {
            my_size += ::protobuf::rt::string_size(8, &self.device_class);
        }
        if self.disabled_by_default != false {
            my_size += 1 + 1;
        }
        if !self.icon.is_empty() {
            my_size += ::protobuf::rt::string_size(10, &self.icon);
        }
        if self.entity_category != ::protobuf::EnumOrUnknown::new(EntityCategory::ENTITY_CATEGORY_NONE) {
            my_size += ::protobuf::rt::int32_size(11, self.entity_category.value());
        }
        if self.supports_stop != false {
            my_size += 1 + 1;
        }
        if self.device_id != 0 {
            my_size += ::protobuf::rt::uint32_size(13, self.device_id);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.object_id.is_empty() {
            os.write_string(1, &self.object_id)?;
        }
        if self.key != 0 {
            os.write_fixed32(2, self.key)?;
        }
        if !self.name.is_empty() {
            os.write_string(3, &self.name)?;
        }
        if !self.unique_id.is_empty() {
            os.write_string(4, &self.unique_id)?;
        }
        if self.assumed_state != false {
            os.write_bool(5, self.assumed_state)?;
        }
        if self.supports_position != false {
            os.write_bool(6, self.supports_position)?;
        }
        if self.supports_tilt != false {
            os.write_bool(7, self.supports_tilt)?;
        }
        if !self.device_class.is_empty() {
            os.write_string(8, &self.device_class)?;
        }
        if self.disabled_by_default != false {
            os.write_bool(9, self.disabled_by_default)?;
        }
        if !self.icon.is_empty() {
            os.write_string(10, &self.icon)?;
        }
        if self.entity_category != ::protobuf::EnumOrUnknown::new(EntityCategory::ENTITY_CATEGORY_NONE) {
            os.write_enum(11, ::protobuf::EnumOrUnknown::value(&self.entity_category))?;
        }
        if self.supports_stop != false {
            os.write_bool(12, self.supports_stop)?;
        }
        if self.device_id != 0 {
            os.write_uint32(13, self.device_id)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ListEntitiesCoverResponse {
        ListEntitiesCoverResponse::new()
    }

    fn clear(&mut self) {
        self.object_id.clear();
        self.key = 0;
        self.name.clear();
        self.unique_id.clear();
        self.assumed_state = false;
        self.supports_position = false;
        self.supports_tilt = false;
        self.device_class.clear();
        self.disabled_by_default = false;
        self.icon.clear();
        self.entity_category = ::protobuf::EnumOrUnknown::new(EntityCategory::ENTITY_CATEGORY_NONE);
        self.supports_stop = false;
        self.device_id = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ListEntitiesCoverResponse {
        static instance: ListEntitiesCoverResponse = ListEntitiesCoverResponse {
            object_id: ::std::string::String::new(),
            key: 0,
            name: ::std::string::String::new(),
            unique_id: ::std::string::String::new(),
            assumed_state: false,
            supports_position: false,
            supports_tilt: false,
            device_class: ::std::string::String::new(),
            disabled_by_default: false,
            icon: ::std::string::String::new(),
            entity_category: ::protobuf::EnumOrUnknown::from_i32(0),
            supports_stop: false,
            device_id: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ListEntitiesCoverResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ListEntitiesCoverResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ListEntitiesCoverResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ListEntitiesCoverResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CoverStateResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CoverStateResponse {
    // message fields
    // @@protoc_insertion_point(field:CoverStateResponse.key)
    pub key: u32,
    // @@protoc_insertion_point(field:CoverStateResponse.legacy_state)
    pub legacy_state: ::protobuf::EnumOrUnknown<LegacyCoverState>,
    // @@protoc_insertion_point(field:CoverStateResponse.position)
    pub position: f32,
    // @@protoc_insertion_point(field:CoverStateResponse.tilt)
    pub tilt: f32,
    // @@protoc_insertion_point(field:CoverStateResponse.current_operation)
    pub current_operation: ::protobuf::EnumOrUnknown<CoverOperation>,
    // @@protoc_insertion_point(field:CoverStateResponse.device_id)
    pub device_id: u32,
    // special fields
    // @@protoc_insertion_point(special_field:CoverStateResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CoverStateResponse {
    fn default() -> &'a CoverStateResponse {
        <CoverStateResponse as ::protobuf::Message>::default_instance()
    }
}

impl CoverStateResponse {
    pub fn new() -> CoverStateResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(6);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "key",
            |m: &CoverStateResponse| { &m.key },
            |m: &mut CoverStateResponse| { &mut m.key },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "legacy_state",
            |m: &CoverStateResponse| { &m.legacy_state },
            |m: &mut CoverStateResponse| { &mut m.legacy_state },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "position",
            |m: &CoverStateResponse| { &m.position },
            |m: &mut CoverStateResponse| { &mut m.position },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "tilt",
            |m: &CoverStateResponse| { &m.tilt },
            |m: &mut CoverStateResponse| { &mut m.tilt },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "current_operation",
            |m: &CoverStateResponse| { &m.current_operation },
            |m: &mut CoverStateResponse| { &mut m.current_operation },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "device_id",
            |m: &CoverStateResponse| { &m.device_id },
            |m: &mut CoverStateResponse| { &mut m.device_id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CoverStateResponse>(
            "CoverStateResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CoverStateResponse {
    const NAME: &'static str = "CoverStateResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                13 => {
                    self.key = is.read_fixed32()?;
                },
                16 => {
                    self.legacy_state = is.read_enum_or_unknown()?;
                },
                29 => {
                    self.position = is.read_float()?;
                },
                37 => {
                    self.tilt = is.read_float()?;
                },
                40 => {
                    self.current_operation = is.read_enum_or_unknown()?;
                },
                48 => {
                    self.device_id = is.read_uint32()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.key != 0 {
            my_size += 1 + 4;
        }
        if self.legacy_state != ::protobuf::EnumOrUnknown::new(LegacyCoverState::LEGACY_COVER_STATE_OPEN) {
            my_size += ::protobuf::rt::int32_size(2, self.legacy_state.value());
        }
        if self.position != 0. {
            my_size += 1 + 4;
        }
        if self.tilt != 0. {
            my_size += 1 + 4;
        }
        if self.current_operation != ::protobuf::EnumOrUnknown::new(CoverOperation::COVER_OPERATION_IDLE) {
            my_size += ::protobuf::rt::int32_size(5, self.current_operation.value());
        }
        if self.device_id != 0 {
            my_size += ::protobuf::rt::uint32_size(6, self.device_id);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.key != 0 {
            os.write_fixed32(1, self.key)?;
        }
        if self.legacy_state != ::protobuf::EnumOrUnknown::new(LegacyCoverState::LEGACY_COVER_STATE_OPEN) {
            os.write_enum(2, ::protobuf::EnumOrUnknown::value(&self.legacy_state))?;
        }
        if self.position != 0. {
            os.write_float(3, self.position)?;
        }
        if self.tilt != 0. {
            os.write_float(4, self.tilt)?;
        }
        if self.current_operation != ::protobuf::EnumOrUnknown::new(CoverOperation::COVER_OPERATION_IDLE) {
            os.write_enum(5, ::protobuf::EnumOrUnknown::value(&self.current_operation))?;
        }
        if self.device_id != 0 {
            os.write_uint32(6, self.device_id)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CoverStateResponse {
        CoverStateResponse::new()
    }

    fn clear(&mut self) {
        self.key = 0;
        self.legacy_state = ::protobuf::EnumOrUnknown::new(LegacyCoverState::LEGACY_COVER_STATE_OPEN);
        self.position = 0.;
        self.tilt = 0.;
        self.current_operation = ::protobuf::EnumOrUnknown::new(CoverOperation::COVER_OPERATION_IDLE);
        self.device_id = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CoverStateResponse {
        static instance: CoverStateResponse = CoverStateResponse {
            key: 0,
            legacy_state: ::protobuf::EnumOrUnknown::from_i32(0),
            position: 0.,
            tilt: 0.,
            current_operation: ::protobuf::EnumOrUnknown::from_i32(0),
            device_id: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CoverStateResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CoverStateResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CoverStateResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CoverStateResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CoverCommandRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CoverCommandRequest {
    // message fields
    // @@protoc_insertion_point(field:CoverCommandRequest.key)
    pub key: u32,
    // @@protoc_insertion_point(field:CoverCommandRequest.has_legacy_command)
    pub has_legacy_command: bool,
    // @@protoc_insertion_point(field:CoverCommandRequest.legacy_command)
    pub legacy_command: ::protobuf::EnumOrUnknown<LegacyCoverCommand>,
    // @@protoc_insertion_point(field:CoverCommandRequest.has_position)
    pub has_position: bool,
    // @@protoc_insertion_point(field:CoverCommandRequest.position)
    pub position: f32,
    // @@protoc_insertion_point(field:CoverCommandRequest.has_tilt)
    pub has_tilt: bool,
    // @@protoc_insertion_point(field:CoverCommandRequest.tilt)
    pub tilt: f32,
    // @@protoc_insertion_point(field:CoverCommandRequest.stop)
    pub stop: bool,
    // @@protoc_insertion_point(field:CoverCommandRequest.device_id)
    pub device_id: u32,
    // special fields
    // @@protoc_insertion_point(special_field:CoverCommandRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CoverCommandRequest {
    fn default() -> &'a CoverCommandRequest {
        <CoverCommandRequest as ::protobuf::Message>::default_instance()
    }
}

impl CoverCommandRequest {
    pub fn new() -> CoverCommandRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(9);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "key",
            |m: &CoverCommandRequest| { &m.key },
            |m: &mut CoverCommandRequest| { &mut m.key },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "has_legacy_command",
            |m: &CoverCommandRequest| { &m.has_legacy_command },
            |m: &mut CoverCommandRequest| { &mut m.has_legacy_command },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "legacy_command",
            |m: &CoverCommandRequest| { &m.legacy_command },
            |m: &mut CoverCommandRequest| { &mut m.legacy_command },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "has_position",
            |m: &CoverCommandRequest| { &m.has_position },
            |m: &mut CoverCommandRequest| { &mut m.has_position },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "position",
            |m: &CoverCommandRequest| { &m.position },
            |m: &mut CoverCommandRequest| { &mut m.position },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "has_tilt",
            |m: &CoverCommandRequest| { &m.has_tilt },
            |m: &mut CoverCommandRequest| { &mut m.has_tilt },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "tilt",
            |m: &CoverCommandRequest| { &m.tilt },
            |m: &mut CoverCommandRequest| { &mut m.tilt },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "stop",
            |m: &CoverCommandRequest| { &m.stop },
            |m: &mut CoverCommandRequest| { &mut m.stop },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "device_id",
            |m: &CoverCommandRequest| { &m.device_id },
            |m: &mut CoverCommandRequest| { &mut m.device_id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CoverCommandRequest>(
            "CoverCommandRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CoverCommandRequest {
    const NAME: &'static str = "CoverCommandRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                13 => {
                    self.key = is.read_fixed32()?;
                },
                16 => {
                    self.has_legacy_command = is.read_bool()?;
                },
                24 => {
                    self.legacy_command = is.read_enum_or_unknown()?;
                },
                32 => {
                    self.has_position = is.read_bool()?;
                },
                45 => {
                    self.position = is.read_float()?;
                },
                48 => {
                    self.has_tilt = is.read_bool()?;
                },
                61 => {
                    self.tilt = is.read_float()?;
                },
                64 => {
                    self.stop = is.read_bool()?;
                },
                72 => {
                    self.device_id = is.read_uint32()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.key != 0 {
            my_size += 1 + 4;
        }
        if self.has_legacy_command != false {
            my_size += 1 + 1;
        }
        if self.legacy_command != ::protobuf::EnumOrUnknown::new(LegacyCoverCommand::LEGACY_COVER_COMMAND_OPEN) {
            my_size += ::protobuf::rt::int32_size(3, self.legacy_command.value());
        }
        if self.has_position != false {
            my_size += 1 + 1;
        }
        if self.position != 0. {
            my_size += 1 + 4;
        }
        if self.has_tilt != false {
            my_size += 1 + 1;
        }
        if self.tilt != 0. {
            my_size += 1 + 4;
        }
        if self.stop != false {
            my_size += 1 + 1;
        }
        if self.device_id != 0 {
            my_size += ::protobuf::rt::uint32_size(9, self.device_id);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.key != 0 {
            os.write_fixed32(1, self.key)?;
        }
        if self.has_legacy_command != false {
            os.write_bool(2, self.has_legacy_command)?;
        }
        if self.legacy_command != ::protobuf::EnumOrUnknown::new(LegacyCoverCommand::LEGACY_COVER_COMMAND_OPEN) {
            os.write_enum(3, ::protobuf::EnumOrUnknown::value(&self.legacy_command))?;
        }
        if self.has_position != false {
            os.write_bool(4, self.has_position)?;
        }
        if self.position != 0. {
            os.write_float(5, self.position)?;
        }
        if self.has_tilt != false {
            os.write_bool(6, self.has_tilt)?;
        }
        if self.tilt != 0. {
            os.write_float(7, self.tilt)?;
        }
        if self.stop != false {
            os.write_bool(8, self.stop)?;
        }
        if self.device_id != 0 {
            os.write_uint32(9, self.device_id)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CoverCommandRequest {
        CoverCommandRequest::new()
    }

    fn clear(&mut self) {
        self.key = 0;
        self.has_legacy_command = false;
        self.legacy_command = ::protobuf::EnumOrUnknown::new(LegacyCoverCommand::LEGACY_COVER_COMMAND_OPEN);
        self.has_position = false;
        self.position = 0.;
        self.has_tilt = false;
        self.tilt = 0.;
        self.stop = false;
        self.device_id = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CoverCommandRequest {
        static instance: CoverCommandRequest = CoverCommandRequest {
            key: 0,
            has_legacy_command: false,
            legacy_command: ::protobuf::EnumOrUnknown::from_i32(0),
            has_position: false,
            position: 0.,
            has_tilt: false,
            tilt: 0.,
            stop: false,
            device_id: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CoverCommandRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CoverCommandRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CoverCommandRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CoverCommandRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:ListEntitiesFanResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ListEntitiesFanResponse {
    // message fields
    // @@protoc_insertion_point(field:ListEntitiesFanResponse.object_id)
    pub object_id: ::std::string::String,
    // @@protoc_insertion_point(field:ListEntitiesFanResponse.key)
    pub key: u32,
    // @@protoc_insertion_point(field:ListEntitiesFanResponse.name)
    pub name: ::std::string::String,
    // @@protoc_insertion_point(field:ListEntitiesFanResponse.unique_id)
    pub unique_id: ::std::string::String,
    // @@protoc_insertion_point(field:ListEntitiesFanResponse.supports_oscillation)
    pub supports_oscillation: bool,
    // @@protoc_insertion_point(field:ListEntitiesFanResponse.supports_speed)
    pub supports_speed: bool,
    // @@protoc_insertion_point(field:ListEntitiesFanResponse.supports_direction)
    pub supports_direction: bool,
    // @@protoc_insertion_point(field:ListEntitiesFanResponse.supported_speed_count)
    pub supported_speed_count: i32,
    // @@protoc_insertion_point(field:ListEntitiesFanResponse.disabled_by_default)
    pub disabled_by_default: bool,
    // @@protoc_insertion_point(field:ListEntitiesFanResponse.icon)
    pub icon: ::std::string::String,
    // @@protoc_insertion_point(field:ListEntitiesFanResponse.entity_category)
    pub entity_category: ::protobuf::EnumOrUnknown<EntityCategory>,
    // @@protoc_insertion_point(field:ListEntitiesFanResponse.supported_preset_modes)
    pub supported_preset_modes: ::std::vec::Vec<::std::string::String>,
    // @@protoc_insertion_point(field:ListEntitiesFanResponse.device_id)
    pub device_id: u32,
    // special fields
    // @@protoc_insertion_point(special_field:ListEntitiesFanResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ListEntitiesFanResponse {
    fn default() -> &'a ListEntitiesFanResponse {
        <ListEntitiesFanResponse as ::protobuf::Message>::default_instance()
    }
}

impl ListEntitiesFanResponse {
    pub fn new() -> ListEntitiesFanResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(13);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "object_id",
            |m: &ListEntitiesFanResponse| { &m.object_id },
            |m: &mut ListEntitiesFanResponse| { &mut m.object_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "key",
            |m: &ListEntitiesFanResponse| { &m.key },
            |m: &mut ListEntitiesFanResponse| { &mut m.key },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "name",
            |m: &ListEntitiesFanResponse| { &m.name },
            |m: &mut ListEntitiesFanResponse| { &mut m.name },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "unique_id",
            |m: &ListEntitiesFanResponse| { &m.unique_id },
            |m: &mut ListEntitiesFanResponse| { &mut m.unique_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "supports_oscillation",
            |m: &ListEntitiesFanResponse| { &m.supports_oscillation },
            |m: &mut ListEntitiesFanResponse| { &mut m.supports_oscillation },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "supports_speed",
            |m: &ListEntitiesFanResponse| { &m.supports_speed },
            |m: &mut ListEntitiesFanResponse| { &mut m.supports_speed },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "supports_direction",
            |m: &ListEntitiesFanResponse| { &m.supports_direction },
            |m: &mut ListEntitiesFanResponse| { &mut m.supports_direction },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "supported_speed_count",
            |m: &ListEntitiesFanResponse| { &m.supported_speed_count },
            |m: &mut ListEntitiesFanResponse| { &mut m.supported_speed_count },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "disabled_by_default",
            |m: &ListEntitiesFanResponse| { &m.disabled_by_default },
            |m: &mut ListEntitiesFanResponse| { &mut m.disabled_by_default },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "icon",
            |m: &ListEntitiesFanResponse| { &m.icon },
            |m: &mut ListEntitiesFanResponse| { &mut m.icon },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "entity_category",
            |m: &ListEntitiesFanResponse| { &m.entity_category },
            |m: &mut ListEntitiesFanResponse| { &mut m.entity_category },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "supported_preset_modes",
            |m: &ListEntitiesFanResponse| { &m.supported_preset_modes },
            |m: &mut ListEntitiesFanResponse| { &mut m.supported_preset_modes },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "device_id",
            |m: &ListEntitiesFanResponse| { &m.device_id },
            |m: &mut ListEntitiesFanResponse| { &mut m.device_id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ListEntitiesFanResponse>(
            "ListEntitiesFanResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ListEntitiesFanResponse {
    const NAME: &'static str = "ListEntitiesFanResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.object_id = is.read_string()?;
                },
                21 => {
                    self.key = is.read_fixed32()?;
                },
                26 => {
                    self.name = is.read_string()?;
                },
                34 => {
                    self.unique_id = is.read_string()?;
                },
                40 => {
                    self.supports_oscillation = is.read_bool()?;
                },
                48 => {
                    self.supports_speed = is.read_bool()?;
                },
                56 => {
                    self.supports_direction = is.read_bool()?;
                },
                64 => {
                    self.supported_speed_count = is.read_int32()?;
                },
                72 => {
                    self.disabled_by_default = is.read_bool()?;
                },
                82 => {
                    self.icon = is.read_string()?;
                },
                88 => {
                    self.entity_category = is.read_enum_or_unknown()?;
                },
                98 => {
                    self.supported_preset_modes.push(is.read_string()?);
                },
                104 => {
                    self.device_id = is.read_uint32()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.object_id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.object_id);
        }
        if self.key != 0 {
            my_size += 1 + 4;
        }
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.name);
        }
        if !self.unique_id.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.unique_id);
        }
        if self.supports_oscillation != false {
            my_size += 1 + 1;
        }
        if self.supports_speed != false {
            my_size += 1 + 1;
        }
        if self.supports_direction != false {
            my_size += 1 + 1;
        }
        if self.supported_speed_count != 0 {
            my_size += ::protobuf::rt::int32_size(8, self.supported_speed_count);
        }
        if self.disabled_by_default != false {
            my_size += 1 + 1;
        }
        if !self.icon.is_empty() {
            my_size += ::protobuf::rt::string_size(10, &self.icon);
        }
        if self.entity_category != ::protobuf::EnumOrUnknown::new(EntityCategory::ENTITY_CATEGORY_NONE) {
            my_size += ::protobuf::rt::int32_size(11, self.entity_category.value());
        }
        for value in &self.supported_preset_modes {
            my_size += ::protobuf::rt::string_size(12, &value);
        };
        if self.device_id != 0 {
            my_size += ::protobuf::rt::uint32_size(13, self.device_id);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.object_id.is_empty() {
            os.write_string(1, &self.object_id)?;
        }
        if self.key != 0 {
            os.write_fixed32(2, self.key)?;
        }
        if !self.name.is_empty() {
            os.write_string(3, &self.name)?;
        }
        if !self.unique_id.is_empty() {
            os.write_string(4, &self.unique_id)?;
        }
        if self.supports_oscillation != false {
            os.write_bool(5, self.supports_oscillation)?;
        }
        if self.supports_speed != false {
            os.write_bool(6, self.supports_speed)?;
        }
        if self.supports_direction != false {
            os.write_bool(7, self.supports_direction)?;
        }
        if self.supported_speed_count != 0 {
            os.write_int32(8, self.supported_speed_count)?;
        }
        if self.disabled_by_default != false {
            os.write_bool(9, self.disabled_by_default)?;
        }
        if !self.icon.is_empty() {
            os.write_string(10, &self.icon)?;
        }
        if self.entity_category != ::protobuf::EnumOrUnknown::new(EntityCategory::ENTITY_CATEGORY_NONE) {
            os.write_enum(11, ::protobuf::EnumOrUnknown::value(&self.entity_category))?;
        }
        for v in &self.supported_preset_modes {
            os.write_string(12, &v)?;
        };
        if self.device_id != 0 {
            os.write_uint32(13, self.device_id)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ListEntitiesFanResponse {
        ListEntitiesFanResponse::new()
    }

    fn clear(&mut self) {
        self.object_id.clear();
        self.key = 0;
        self.name.clear();
        self.unique_id.clear();
        self.supports_oscillation = false;
        self.supports_speed = false;
        self.supports_direction = false;
        self.supported_speed_count = 0;
        self.disabled_by_default = false;
        self.icon.clear();
        self.entity_category = ::protobuf::EnumOrUnknown::new(EntityCategory::ENTITY_CATEGORY_NONE);
        self.supported_preset_modes.clear();
        self.device_id = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ListEntitiesFanResponse {
        static instance: ListEntitiesFanResponse = ListEntitiesFanResponse {
            object_id: ::std::string::String::new(),
            key: 0,
            name: ::std::string::String::new(),
            unique_id: ::std::string::String::new(),
            supports_oscillation: false,
            supports_speed: false,
            supports_direction: false,
            supported_speed_count: 0,
            disabled_by_default: false,
            icon: ::std::string::String::new(),
            entity_category: ::protobuf::EnumOrUnknown::from_i32(0),
            supported_preset_modes: ::std::vec::Vec::new(),
            device_id: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ListEntitiesFanResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ListEntitiesFanResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ListEntitiesFanResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ListEntitiesFanResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:FanStateResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct FanStateResponse {
    // message fields
    // @@protoc_insertion_point(field:FanStateResponse.key)
    pub key: u32,
    // @@protoc_insertion_point(field:FanStateResponse.state)
    pub state: bool,
    // @@protoc_insertion_point(field:FanStateResponse.oscillating)
    pub oscillating: bool,
    // @@protoc_insertion_point(field:FanStateResponse.speed)
    pub speed: ::protobuf::EnumOrUnknown<FanSpeed>,
    // @@protoc_insertion_point(field:FanStateResponse.direction)
    pub direction: ::protobuf::EnumOrUnknown<FanDirection>,
    // @@protoc_insertion_point(field:FanStateResponse.speed_level)
    pub speed_level: i32,
    // @@protoc_insertion_point(field:FanStateResponse.preset_mode)
    pub preset_mode: ::std::string::String,
    // @@protoc_insertion_point(field:FanStateResponse.device_id)
    pub device_id: u32,
    // special fields
    // @@protoc_insertion_point(special_field:FanStateResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a FanStateResponse {
    fn default() -> &'a FanStateResponse {
        <FanStateResponse as ::protobuf::Message>::default_instance()
    }
}

impl FanStateResponse {
    pub fn new() -> FanStateResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(8);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "key",
            |m: &FanStateResponse| { &m.key },
            |m: &mut FanStateResponse| { &mut m.key },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "state",
            |m: &FanStateResponse| { &m.state },
            |m: &mut FanStateResponse| { &mut m.state },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "oscillating",
            |m: &FanStateResponse| { &m.oscillating },
            |m: &mut FanStateResponse| { &mut m.oscillating },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "speed",
            |m: &FanStateResponse| { &m.speed },
            |m: &mut FanStateResponse| { &mut m.speed },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "direction",
            |m: &FanStateResponse| { &m.direction },
            |m: &mut FanStateResponse| { &mut m.direction },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "speed_level",
            |m: &FanStateResponse| { &m.speed_level },
            |m: &mut FanStateResponse| { &mut m.speed_level },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "preset_mode",
            |m: &FanStateResponse| { &m.preset_mode },
            |m: &mut FanStateResponse| { &mut m.preset_mode },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "device_id",
            |m: &FanStateResponse| { &m.device_id },
            |m: &mut FanStateResponse| { &mut m.device_id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<FanStateResponse>(
            "FanStateResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for FanStateResponse {
    const NAME: &'static str = "FanStateResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                13 => {
                    self.key = is.read_fixed32()?;
                },
                16 => {
                    self.state = is.read_bool()?;
                },
                24 => {
                    self.oscillating = is.read_bool()?;
                },
                32 => {
                    self.speed = is.read_enum_or_unknown()?;
                },
                40 => {
                    self.direction = is.read_enum_or_unknown()?;
                },
                48 => {
                    self.speed_level = is.read_int32()?;
                },
                58 => {
                    self.preset_mode = is.read_string()?;
                },
                64 => {
                    self.device_id = is.read_uint32()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.key != 0 {
            my_size += 1 + 4;
        }
        if self.state != false {
            my_size += 1 + 1;
        }
        if self.oscillating != false {
            my_size += 1 + 1;
        }
        if self.speed != ::protobuf::EnumOrUnknown::new(FanSpeed::FAN_SPEED_LOW) {
            my_size += ::protobuf::rt::int32_size(4, self.speed.value());
        }
        if self.direction != ::protobuf::EnumOrUnknown::new(FanDirection::FAN_DIRECTION_FORWARD) {
            my_size += ::protobuf::rt::int32_size(5, self.direction.value());
        }
        if self.speed_level != 0 {
            my_size += ::protobuf::rt::int32_size(6, self.speed_level);
        }
        if !self.preset_mode.is_empty() {
            my_size += ::protobuf::rt::string_size(7, &self.preset_mode);
        }
        if self.device_id != 0 {
            my_size += ::protobuf::rt::uint32_size(8, self.device_id);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.key != 0 {
            os.write_fixed32(1, self.key)?;
        }
        if self.state != false {
            os.write_bool(2, self.state)?;
        }
        if self.oscillating != false {
            os.write_bool(3, self.oscillating)?;
        }
        if self.speed != ::protobuf::EnumOrUnknown::new(FanSpeed::FAN_SPEED_LOW) {
            os.write_enum(4, ::protobuf::EnumOrUnknown::value(&self.speed))?;
        }
        if self.direction != ::protobuf::EnumOrUnknown::new(FanDirection::FAN_DIRECTION_FORWARD) {
            os.write_enum(5, ::protobuf::EnumOrUnknown::value(&self.direction))?;
        }
        if self.speed_level != 0 {
            os.write_int32(6, self.speed_level)?;
        }
        if !self.preset_mode.is_empty() {
            os.write_string(7, &self.preset_mode)?;
        }
        if self.device_id != 0 {
            os.write_uint32(8, self.device_id)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> FanStateResponse {
        FanStateResponse::new()
    }

    fn clear(&mut self) {
        self.key = 0;
        self.state = false;
        self.oscillating = false;
        self.speed = ::protobuf::EnumOrUnknown::new(FanSpeed::FAN_SPEED_LOW);
        self.direction = ::protobuf::EnumOrUnknown::new(FanDirection::FAN_DIRECTION_FORWARD);
        self.speed_level = 0;
        self.preset_mode.clear();
        self.device_id = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static FanStateResponse {
        static instance: FanStateResponse = FanStateResponse {
            key: 0,
            state: false,
            oscillating: false,
            speed: ::protobuf::EnumOrUnknown::from_i32(0),
            direction: ::protobuf::EnumOrUnknown::from_i32(0),
            speed_level: 0,
            preset_mode: ::std::string::String::new(),
            device_id: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for FanStateResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("FanStateResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for FanStateResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for FanStateResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:FanCommandRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct FanCommandRequest {
    // message fields
    // @@protoc_insertion_point(field:FanCommandRequest.key)
    pub key: u32,
    // @@protoc_insertion_point(field:FanCommandRequest.has_state)
    pub has_state: bool,
    // @@protoc_insertion_point(field:FanCommandRequest.state)
    pub state: bool,
    // @@protoc_insertion_point(field:FanCommandRequest.has_speed)
    pub has_speed: bool,
    // @@protoc_insertion_point(field:FanCommandRequest.speed)
    pub speed: ::protobuf::EnumOrUnknown<FanSpeed>,
    // @@protoc_insertion_point(field:FanCommandRequest.has_oscillating)
    pub has_oscillating: bool,
    // @@protoc_insertion_point(field:FanCommandRequest.oscillating)
    pub oscillating: bool,
    // @@protoc_insertion_point(field:FanCommandRequest.has_direction)
    pub has_direction: bool,
    // @@protoc_insertion_point(field:FanCommandRequest.direction)
    pub direction: ::protobuf::EnumOrUnknown<FanDirection>,
    // @@protoc_insertion_point(field:FanCommandRequest.has_speed_level)
    pub has_speed_level: bool,
    // @@protoc_insertion_point(field:FanCommandRequest.speed_level)
    pub speed_level: i32,
    // @@protoc_insertion_point(field:FanCommandRequest.has_preset_mode)
    pub has_preset_mode: bool,
    // @@protoc_insertion_point(field:FanCommandRequest.preset_mode)
    pub preset_mode: ::std::string::String,
    // @@protoc_insertion_point(field:FanCommandRequest.device_id)
    pub device_id: u32,
    // special fields
    // @@protoc_insertion_point(special_field:FanCommandRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a FanCommandRequest {
    fn default() -> &'a FanCommandRequest {
        <FanCommandRequest as ::protobuf::Message>::default_instance()
    }
}

impl FanCommandRequest {
    pub fn new() -> FanCommandRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(14);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "key",
            |m: &FanCommandRequest| { &m.key },
            |m: &mut FanCommandRequest| { &mut m.key },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "has_state",
            |m: &FanCommandRequest| { &m.has_state },
            |m: &mut FanCommandRequest| { &mut m.has_state },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "state",
            |m: &FanCommandRequest| { &m.state },
            |m: &mut FanCommandRequest| { &mut m.state },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "has_speed",
            |m: &FanCommandRequest| { &m.has_speed },
            |m: &mut FanCommandRequest| { &mut m.has_speed },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "speed",
            |m: &FanCommandRequest| { &m.speed },
            |m: &mut FanCommandRequest| { &mut m.speed },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "has_oscillating",
            |m: &FanCommandRequest| { &m.has_oscillating },
            |m: &mut FanCommandRequest| { &mut m.has_oscillating },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "oscillating",
            |m: &FanCommandRequest| { &m.oscillating },
            |m: &mut FanCommandRequest| { &mut m.oscillating },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "has_direction",
            |m: &FanCommandRequest| { &m.has_direction },
            |m: &mut FanCommandRequest| { &mut m.has_direction },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "direction",
            |m: &FanCommandRequest| { &m.direction },
            |m: &mut FanCommandRequest| { &mut m.direction },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "has_speed_level",
            |m: &FanCommandRequest| { &m.has_speed_level },
            |m: &mut FanCommandRequest| { &mut m.has_speed_level },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "speed_level",
            |m: &FanCommandRequest| { &m.speed_level },
            |m: &mut FanCommandRequest| { &mut m.speed_level },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "has_preset_mode",
            |m: &FanCommandRequest| { &m.has_preset_mode },
            |m: &mut FanCommandRequest| { &mut m.has_preset_mode },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "preset_mode",
            |m: &FanCommandRequest| { &m.preset_mode },
            |m: &mut FanCommandRequest| { &mut m.preset_mode },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "device_id",
            |m: &FanCommandRequest| { &m.device_id },
            |m: &mut FanCommandRequest| { &mut m.device_id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<FanCommandRequest>(
            "FanCommandRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for FanCommandRequest {
    const NAME: &'static str = "FanCommandRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                13 => {
                    self.key = is.read_fixed32()?;
                },
                16 => {
                    self.has_state = is.read_bool()?;
                },
                24 => {
                    self.state = is.read_bool()?;
                },
                32 => {
                    self.has_speed = is.read_bool()?;
                },
                40 => {
                    self.speed = is.read_enum_or_unknown()?;
                },
                48 => {
                    self.has_oscillating = is.read_bool()?;
                },
                56 => {
                    self.oscillating = is.read_bool()?;
                },
                64 => {
                    self.has_direction = is.read_bool()?;
                },
                72 => {
                    self.direction = is.read_enum_or_unknown()?;
                },
                80 => {
                    self.has_speed_level = is.read_bool()?;
                },
                88 => {
                    self.speed_level = is.read_int32()?;
                },
                96 => {
                    self.has_preset_mode = is.read_bool()?;
                },
                106 => {
                    self.preset_mode = is.read_string()?;
                },
                112 => {
                    self.device_id = is.read_uint32()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.key != 0 {
            my_size += 1 + 4;
        }
        if self.has_state != false {
            my_size += 1 + 1;
        }
        if self.state != false {
            my_size += 1 + 1;
        }
        if self.has_speed != false {
            my_size += 1 + 1;
        }
        if self.speed != ::protobuf::EnumOrUnknown::new(FanSpeed::FAN_SPEED_LOW) {
            my_size += ::protobuf::rt::int32_size(5, self.speed.value());
        }
        if self.has_oscillating != false {
            my_size += 1 + 1;
        }
        if self.oscillating != false {
            my_size += 1 + 1;
        }
        if self.has_direction != false {
            my_size += 1 + 1;
        }
        if self.direction != ::protobuf::EnumOrUnknown::new(FanDirection::FAN_DIRECTION_FORWARD) {
            my_size += ::protobuf::rt::int32_size(9, self.direction.value());
        }
        if self.has_speed_level != false {
            my_size += 1 + 1;
        }
        if self.speed_level != 0 {
            my_size += ::protobuf::rt::int32_size(11, self.speed_level);
        }
        if self.has_preset_mode != false {
            my_size += 1 + 1;
        }
        if !self.preset_mode.is_empty() {
            my_size += ::protobuf::rt::string_size(13, &self.preset_mode);
        }
        if self.device_id != 0 {
            my_size += ::protobuf::rt::uint32_size(14, self.device_id);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.key != 0 {
            os.write_fixed32(1, self.key)?;
        }
        if self.has_state != false {
            os.write_bool(2, self.has_state)?;
        }
        if self.state != false {
            os.write_bool(3, self.state)?;
        }
        if self.has_speed != false {
            os.write_bool(4, self.has_speed)?;
        }
        if self.speed != ::protobuf::EnumOrUnknown::new(FanSpeed::FAN_SPEED_LOW) {
            os.write_enum(5, ::protobuf::EnumOrUnknown::value(&self.speed))?;
        }
        if self.has_oscillating != false {
            os.write_bool(6, self.has_oscillating)?;
        }
        if self.oscillating != false {
            os.write_bool(7, self.oscillating)?;
        }
        if self.has_direction != false {
            os.write_bool(8, self.has_direction)?;
        }
        if self.direction != ::protobuf::EnumOrUnknown::new(FanDirection::FAN_DIRECTION_FORWARD) {
            os.write_enum(9, ::protobuf::EnumOrUnknown::value(&self.direction))?;
        }
        if self.has_speed_level != false {
            os.write_bool(10, self.has_speed_level)?;
        }
        if self.speed_level != 0 {
            os.write_int32(11, self.speed_level)?;
        }
        if self.has_preset_mode != false {
            os.write_bool(12, self.has_preset_mode)?;
        }
        if !self.preset_mode.is_empty() {
            os.write_string(13, &self.preset_mode)?;
        }
        if self.device_id != 0 {
            os.write_uint32(14, self.device_id)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> FanCommandRequest {
        FanCommandRequest::new()
    }

    fn clear(&mut self) {
        self.key = 0;
        self.has_state = false;
        self.state = false;
        self.has_speed = false;
        self.speed = ::protobuf::EnumOrUnknown::new(FanSpeed::FAN_SPEED_LOW);
        self.has_oscillating = false;
        self.oscillating = false;
        self.has_direction = false;
        self.direction = ::protobuf::EnumOrUnknown::new(FanDirection::FAN_DIRECTION_FORWARD);
        self.has_speed_level = false;
        self.speed_level = 0;
        self.has_preset_mode = false;
        self.preset_mode.clear();
        self.device_id = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static FanCommandRequest {
        static instance: FanCommandRequest = FanCommandRequest {
            key: 0,
            has_state: false,
            state: false,
            has_speed: false,
            speed: ::protobuf::EnumOrUnknown::from_i32(0),
            has_oscillating: false,
            oscillating: false,
            has_direction: false,
            direction: ::protobuf::EnumOrUnknown::from_i32(0),
            has_speed_level: false,
            speed_level: 0,
            has_preset_mode: false,
            preset_mode: ::std::string::String::new(),
            device_id: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for FanCommandRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("FanCommandRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for FanCommandRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for FanCommandRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:ListEntitiesLightResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ListEntitiesLightResponse {
    // message fields
    // @@protoc_insertion_point(field:ListEntitiesLightResponse.object_id)
    pub object_id: ::std::string::String,
    // @@protoc_insertion_point(field:ListEntitiesLightResponse.key)
    pub key: u32,
    // @@protoc_insertion_point(field:ListEntitiesLightResponse.name)
    pub name: ::std::string::String,
    // @@protoc_insertion_point(field:ListEntitiesLightResponse.unique_id)
    pub unique_id: ::std::string::String,
    // @@protoc_insertion_point(field:ListEntitiesLightResponse.supported_color_modes)
    pub supported_color_modes: ::std::vec::Vec<::protobuf::EnumOrUnknown<ColorMode>>,
    // @@protoc_insertion_point(field:ListEntitiesLightResponse.legacy_supports_brightness)
    pub legacy_supports_brightness: bool,
    // @@protoc_insertion_point(field:ListEntitiesLightResponse.legacy_supports_rgb)
    pub legacy_supports_rgb: bool,
    // @@protoc_insertion_point(field:ListEntitiesLightResponse.legacy_supports_white_value)
    pub legacy_supports_white_value: bool,
    // @@protoc_insertion_point(field:ListEntitiesLightResponse.legacy_supports_color_temperature)
    pub legacy_supports_color_temperature: bool,
    // @@protoc_insertion_point(field:ListEntitiesLightResponse.min_mireds)
    pub min_mireds: f32,
    // @@protoc_insertion_point(field:ListEntitiesLightResponse.max_mireds)
    pub max_mireds: f32,
    // @@protoc_insertion_point(field:ListEntitiesLightResponse.effects)
    pub effects: ::std::vec::Vec<::std::string::String>,
    // @@protoc_insertion_point(field:ListEntitiesLightResponse.disabled_by_default)
    pub disabled_by_default: bool,
    // @@protoc_insertion_point(field:ListEntitiesLightResponse.icon)
    pub icon: ::std::string::String,
    // @@protoc_insertion_point(field:ListEntitiesLightResponse.entity_category)
    pub entity_category: ::protobuf::EnumOrUnknown<EntityCategory>,
    // @@protoc_insertion_point(field:ListEntitiesLightResponse.device_id)
    pub device_id: u32,
    // special fields
    // @@protoc_insertion_point(special_field:ListEntitiesLightResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ListEntitiesLightResponse {
    fn default() -> &'a ListEntitiesLightResponse {
        <ListEntitiesLightResponse as ::protobuf::Message>::default_instance()
    }
}

impl ListEntitiesLightResponse {
    pub fn new() -> ListEntitiesLightResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(16);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "object_id",
            |m: &ListEntitiesLightResponse| { &m.object_id },
            |m: &mut ListEntitiesLightResponse| { &mut m.object_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "key",
            |m: &ListEntitiesLightResponse| { &m.key },
            |m: &mut ListEntitiesLightResponse| { &mut m.key },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "name",
            |m: &ListEntitiesLightResponse| { &m.name },
            |m: &mut ListEntitiesLightResponse| { &mut m.name },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "unique_id",
            |m: &ListEntitiesLightResponse| { &m.unique_id },
            |m: &mut ListEntitiesLightResponse| { &mut m.unique_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "supported_color_modes",
            |m: &ListEntitiesLightResponse| { &m.supported_color_modes },
            |m: &mut ListEntitiesLightResponse| { &mut m.supported_color_modes },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "legacy_supports_brightness",
            |m: &ListEntitiesLightResponse| { &m.legacy_supports_brightness },
            |m: &mut ListEntitiesLightResponse| { &mut m.legacy_supports_brightness },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "legacy_supports_rgb",
            |m: &ListEntitiesLightResponse| { &m.legacy_supports_rgb },
            |m: &mut ListEntitiesLightResponse| { &mut m.legacy_supports_rgb },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "legacy_supports_white_value",
            |m: &ListEntitiesLightResponse| { &m.legacy_supports_white_value },
            |m: &mut ListEntitiesLightResponse| { &mut m.legacy_supports_white_value },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "legacy_supports_color_temperature",
            |m: &ListEntitiesLightResponse| { &m.legacy_supports_color_temperature },
            |m: &mut ListEntitiesLightResponse| { &mut m.legacy_supports_color_temperature },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "min_mireds",
            |m: &ListEntitiesLightResponse| { &m.min_mireds },
            |m: &mut ListEntitiesLightResponse| { &mut m.min_mireds },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "max_mireds",
            |m: &ListEntitiesLightResponse| { &m.max_mireds },
            |m: &mut ListEntitiesLightResponse| { &mut m.max_mireds },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "effects",
            |m: &ListEntitiesLightResponse| { &m.effects },
            |m: &mut ListEntitiesLightResponse| { &mut m.effects },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "disabled_by_default",
            |m: &ListEntitiesLightResponse| { &m.disabled_by_default },
            |m: &mut ListEntitiesLightResponse| { &mut m.disabled_by_default },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "icon",
            |m: &ListEntitiesLightResponse| { &m.icon },
            |m: &mut ListEntitiesLightResponse| { &mut m.icon },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "entity_category",
            |m: &ListEntitiesLightResponse| { &m.entity_category },
            |m: &mut ListEntitiesLightResponse| { &mut m.entity_category },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "device_id",
            |m: &ListEntitiesLightResponse| { &m.device_id },
            |m: &mut ListEntitiesLightResponse| { &mut m.device_id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ListEntitiesLightResponse>(
            "ListEntitiesLightResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ListEntitiesLightResponse {
    const NAME: &'static str = "ListEntitiesLightResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.object_id = is.read_string()?;
                },
                21 => {
                    self.key = is.read_fixed32()?;
                },
                26 => {
                    self.name = is.read_string()?;
                },
                34 => {
                    self.unique_id = is.read_string()?;
                },
                96 => {
                    self.supported_color_modes.push(is.read_enum_or_unknown()?);
                },
                98 => {
                    ::protobuf::rt::read_repeated_packed_enum_or_unknown_into(is, &mut self.supported_color_modes)?
                },
                40 => {
                    self.legacy_supports_brightness = is.read_bool()?;
                },
                48 => {
                    self.legacy_supports_rgb = is.read_bool()?;
                },
                56 => {
                    self.legacy_supports_white_value = is.read_bool()?;
                },
                64 => {
                    self.legacy_supports_color_temperature = is.read_bool()?;
                },
                77 => {
                    self.min_mireds = is.read_float()?;
                },
                85 => {
                    self.max_mireds = is.read_float()?;
                },
                90 => {
                    self.effects.push(is.read_string()?);
                },
                104 => {
                    self.disabled_by_default = is.read_bool()?;
                },
                114 => {
                    self.icon = is.read_string()?;
                },
                120 => {
                    self.entity_category = is.read_enum_or_unknown()?;
                },
                128 => {
                    self.device_id = is.read_uint32()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.object_id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.object_id);
        }
        if self.key != 0 {
            my_size += 1 + 4;
        }
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.name);
        }
        if !self.unique_id.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.unique_id);
        }
        my_size += ::protobuf::rt::vec_packed_enum_or_unknown_size(12, &self.supported_color_modes);
        if self.legacy_supports_brightness != false {
            my_size += 1 + 1;
        }
        if self.legacy_supports_rgb != false {
            my_size += 1 + 1;
        }
        if self.legacy_supports_white_value != false {
            my_size += 1 + 1;
        }
        if self.legacy_supports_color_temperature != false {
            my_size += 1 + 1;
        }
        if self.min_mireds != 0. {
            my_size += 1 + 4;
        }
        if self.max_mireds != 0. {
            my_size += 1 + 4;
        }
        for value in &self.effects {
            my_size += ::protobuf::rt::string_size(11, &value);
        };
        if self.disabled_by_default != false {
            my_size += 1 + 1;
        }
        if !self.icon.is_empty() {
            my_size += ::protobuf::rt::string_size(14, &self.icon);
        }
        if self.entity_category != ::protobuf::EnumOrUnknown::new(EntityCategory::ENTITY_CATEGORY_NONE) {
            my_size += ::protobuf::rt::int32_size(15, self.entity_category.value());
        }
        if self.device_id != 0 {
            my_size += ::protobuf::rt::uint32_size(16, self.device_id);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.object_id.is_empty() {
            os.write_string(1, &self.object_id)?;
        }
        if self.key != 0 {
            os.write_fixed32(2, self.key)?;
        }
        if !self.name.is_empty() {
            os.write_string(3, &self.name)?;
        }
        if !self.unique_id.is_empty() {
            os.write_string(4, &self.unique_id)?;
        }
        os.write_repeated_packed_enum_or_unknown(12, &self.supported_color_modes)?;
        if self.legacy_supports_brightness != false {
            os.write_bool(5, self.legacy_supports_brightness)?;
        }
        if self.legacy_supports_rgb != false {
            os.write_bool(6, self.legacy_supports_rgb)?;
        }
        if self.legacy_supports_white_value != false {
            os.write_bool(7, self.legacy_supports_white_value)?;
        }
        if self.legacy_supports_color_temperature != false {
            os.write_bool(8, self.legacy_supports_color_temperature)?;
        }
        if self.min_mireds != 0. {
            os.write_float(9, self.min_mireds)?;
        }
        if self.max_mireds != 0. {
            os.write_float(10, self.max_mireds)?;
        }
        for v in &self.effects {
            os.write_string(11, &v)?;
        };
        if self.disabled_by_default != false {
            os.write_bool(13, self.disabled_by_default)?;
        }
        if !self.icon.is_empty() {
            os.write_string(14, &self.icon)?;
        }
        if self.entity_category != ::protobuf::EnumOrUnknown::new(EntityCategory::ENTITY_CATEGORY_NONE) {
            os.write_enum(15, ::protobuf::EnumOrUnknown::value(&self.entity_category))?;
        }
        if self.device_id != 0 {
            os.write_uint32(16, self.device_id)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ListEntitiesLightResponse {
        ListEntitiesLightResponse::new()
    }

    fn clear(&mut self) {
        self.object_id.clear();
        self.key = 0;
        self.name.clear();
        self.unique_id.clear();
        self.supported_color_modes.clear();
        self.legacy_supports_brightness = false;
        self.legacy_supports_rgb = false;
        self.legacy_supports_white_value = false;
        self.legacy_supports_color_temperature = false;
        self.min_mireds = 0.;
        self.max_mireds = 0.;
        self.effects.clear();
        self.disabled_by_default = false;
        self.icon.clear();
        self.entity_category = ::protobuf::EnumOrUnknown::new(EntityCategory::ENTITY_CATEGORY_NONE);
        self.device_id = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ListEntitiesLightResponse {
        static instance: ListEntitiesLightResponse = ListEntitiesLightResponse {
            object_id: ::std::string::String::new(),
            key: 0,
            name: ::std::string::String::new(),
            unique_id: ::std::string::String::new(),
            supported_color_modes: ::std::vec::Vec::new(),
            legacy_supports_brightness: false,
            legacy_supports_rgb: false,
            legacy_supports_white_value: false,
            legacy_supports_color_temperature: false,
            min_mireds: 0.,
            max_mireds: 0.,
            effects: ::std::vec::Vec::new(),
            disabled_by_default: false,
            icon: ::std::string::String::new(),
            entity_category: ::protobuf::EnumOrUnknown::from_i32(0),
            device_id: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ListEntitiesLightResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ListEntitiesLightResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ListEntitiesLightResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ListEntitiesLightResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:LightStateResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct LightStateResponse {
    // message fields
    // @@protoc_insertion_point(field:LightStateResponse.key)
    pub key: u32,
    // @@protoc_insertion_point(field:LightStateResponse.state)
    pub state: bool,
    // @@protoc_insertion_point(field:LightStateResponse.brightness)
    pub brightness: f32,
    // @@protoc_insertion_point(field:LightStateResponse.color_mode)
    pub color_mode: ::protobuf::EnumOrUnknown<ColorMode>,
    // @@protoc_insertion_point(field:LightStateResponse.color_brightness)
    pub color_brightness: f32,
    // @@protoc_insertion_point(field:LightStateResponse.red)
    pub red: f32,
    // @@protoc_insertion_point(field:LightStateResponse.green)
    pub green: f32,
    // @@protoc_insertion_point(field:LightStateResponse.blue)
    pub blue: f32,
    // @@protoc_insertion_point(field:LightStateResponse.white)
    pub white: f32,
    // @@protoc_insertion_point(field:LightStateResponse.color_temperature)
    pub color_temperature: f32,
    // @@protoc_insertion_point(field:LightStateResponse.cold_white)
    pub cold_white: f32,
    // @@protoc_insertion_point(field:LightStateResponse.warm_white)
    pub warm_white: f32,
    // @@protoc_insertion_point(field:LightStateResponse.effect)
    pub effect: ::std::string::String,
    // @@protoc_insertion_point(field:LightStateResponse.device_id)
    pub device_id: u32,
    // special fields
    // @@protoc_insertion_point(special_field:LightStateResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a LightStateResponse {
    fn default() -> &'a LightStateResponse {
        <LightStateResponse as ::protobuf::Message>::default_instance()
    }
}

impl LightStateResponse {
    pub fn new() -> LightStateResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(14);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "key",
            |m: &LightStateResponse| { &m.key },
            |m: &mut LightStateResponse| { &mut m.key },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "state",
            |m: &LightStateResponse| { &m.state },
            |m: &mut LightStateResponse| { &mut m.state },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "brightness",
            |m: &LightStateResponse| { &m.brightness },
            |m: &mut LightStateResponse| { &mut m.brightness },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "color_mode",
            |m: &LightStateResponse| { &m.color_mode },
            |m: &mut LightStateResponse| { &mut m.color_mode },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "color_brightness",
            |m: &LightStateResponse| { &m.color_brightness },
            |m: &mut LightStateResponse| { &mut m.color_brightness },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "red",
            |m: &LightStateResponse| { &m.red },
            |m: &mut LightStateResponse| { &mut m.red },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "green",
            |m: &LightStateResponse| { &m.green },
            |m: &mut LightStateResponse| { &mut m.green },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "blue",
            |m: &LightStateResponse| { &m.blue },
            |m: &mut LightStateResponse| { &mut m.blue },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "white",
            |m: &LightStateResponse| { &m.white },
            |m: &mut LightStateResponse| { &mut m.white },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "color_temperature",
            |m: &LightStateResponse| { &m.color_temperature },
            |m: &mut LightStateResponse| { &mut m.color_temperature },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "cold_white",
            |m: &LightStateResponse| { &m.cold_white },
            |m: &mut LightStateResponse| { &mut m.cold_white },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "warm_white",
            |m: &LightStateResponse| { &m.warm_white },
            |m: &mut LightStateResponse| { &mut m.warm_white },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "effect",
            |m: &LightStateResponse| { &m.effect },
            |m: &mut LightStateResponse| { &mut m.effect },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "device_id",
            |m: &LightStateResponse| { &m.device_id },
            |m: &mut LightStateResponse| { &mut m.device_id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<LightStateResponse>(
            "LightStateResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for LightStateResponse {
    const NAME: &'static str = "LightStateResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                13 => {
                    self.key = is.read_fixed32()?;
                },
                16 => {
                    self.state = is.read_bool()?;
                },
                29 => {
                    self.brightness = is.read_float()?;
                },
                88 => {
                    self.color_mode = is.read_enum_or_unknown()?;
                },
                85 => {
                    self.color_brightness = is.read_float()?;
                },
                37 => {
                    self.red = is.read_float()?;
                },
                45 => {
                    self.green = is.read_float()?;
                },
                53 => {
                    self.blue = is.read_float()?;
                },
                61 => {
                    self.white = is.read_float()?;
                },
                69 => {
                    self.color_temperature = is.read_float()?;
                },
                101 => {
                    self.cold_white = is.read_float()?;
                },
                109 => {
                    self.warm_white = is.read_float()?;
                },
                74 => {
                    self.effect = is.read_string()?;
                },
                112 => {
                    self.device_id = is.read_uint32()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.key != 0 {
            my_size += 1 + 4;
        }
        if self.state != false {
            my_size += 1 + 1;
        }
        if self.brightness != 0. {
            my_size += 1 + 4;
        }
        if self.color_mode != ::protobuf::EnumOrUnknown::new(ColorMode::COLOR_MODE_UNKNOWN) {
            my_size += ::protobuf::rt::int32_size(11, self.color_mode.value());
        }
        if self.color_brightness != 0. {
            my_size += 1 + 4;
        }
        if self.red != 0. {
            my_size += 1 + 4;
        }
        if self.green != 0. {
            my_size += 1 + 4;
        }
        if self.blue != 0. {
            my_size += 1 + 4;
        }
        if self.white != 0. {
            my_size += 1 + 4;
        }
        if self.color_temperature != 0. {
            my_size += 1 + 4;
        }
        if self.cold_white != 0. {
            my_size += 1 + 4;
        }
        if self.warm_white != 0. {
            my_size += 1 + 4;
        }
        if !self.effect.is_empty() {
            my_size += ::protobuf::rt::string_size(9, &self.effect);
        }
        if self.device_id != 0 {
            my_size += ::protobuf::rt::uint32_size(14, self.device_id);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.key != 0 {
            os.write_fixed32(1, self.key)?;
        }
        if self.state != false {
            os.write_bool(2, self.state)?;
        }
        if self.brightness != 0. {
            os.write_float(3, self.brightness)?;
        }
        if self.color_mode != ::protobuf::EnumOrUnknown::new(ColorMode::COLOR_MODE_UNKNOWN) {
            os.write_enum(11, ::protobuf::EnumOrUnknown::value(&self.color_mode))?;
        }
        if self.color_brightness != 0. {
            os.write_float(10, self.color_brightness)?;
        }
        if self.red != 0. {
            os.write_float(4, self.red)?;
        }
        if self.green != 0. {
            os.write_float(5, self.green)?;
        }
        if self.blue != 0. {
            os.write_float(6, self.blue)?;
        }
        if self.white != 0. {
            os.write_float(7, self.white)?;
        }
        if self.color_temperature != 0. {
            os.write_float(8, self.color_temperature)?;
        }
        if self.cold_white != 0. {
            os.write_float(12, self.cold_white)?;
        }
        if self.warm_white != 0. {
            os.write_float(13, self.warm_white)?;
        }
        if !self.effect.is_empty() {
            os.write_string(9, &self.effect)?;
        }
        if self.device_id != 0 {
            os.write_uint32(14, self.device_id)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> LightStateResponse {
        LightStateResponse::new()
    }

    fn clear(&mut self) {
        self.key = 0;
        self.state = false;
        self.brightness = 0.;
        self.color_mode = ::protobuf::EnumOrUnknown::new(ColorMode::COLOR_MODE_UNKNOWN);
        self.color_brightness = 0.;
        self.red = 0.;
        self.green = 0.;
        self.blue = 0.;
        self.white = 0.;
        self.color_temperature = 0.;
        self.cold_white = 0.;
        self.warm_white = 0.;
        self.effect.clear();
        self.device_id = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static LightStateResponse {
        static instance: LightStateResponse = LightStateResponse {
            key: 0,
            state: false,
            brightness: 0.,
            color_mode: ::protobuf::EnumOrUnknown::from_i32(0),
            color_brightness: 0.,
            red: 0.,
            green: 0.,
            blue: 0.,
            white: 0.,
            color_temperature: 0.,
            cold_white: 0.,
            warm_white: 0.,
            effect: ::std::string::String::new(),
            device_id: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for LightStateResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("LightStateResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for LightStateResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for LightStateResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:LightCommandRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct LightCommandRequest {
    // message fields
    // @@protoc_insertion_point(field:LightCommandRequest.key)
    pub key: u32,
    // @@protoc_insertion_point(field:LightCommandRequest.has_state)
    pub has_state: bool,
    // @@protoc_insertion_point(field:LightCommandRequest.state)
    pub state: bool,
    // @@protoc_insertion_point(field:LightCommandRequest.has_brightness)
    pub has_brightness: bool,
    // @@protoc_insertion_point(field:LightCommandRequest.brightness)
    pub brightness: f32,
    // @@protoc_insertion_point(field:LightCommandRequest.has_color_mode)
    pub has_color_mode: bool,
    // @@protoc_insertion_point(field:LightCommandRequest.color_mode)
    pub color_mode: ::protobuf::EnumOrUnknown<ColorMode>,
    // @@protoc_insertion_point(field:LightCommandRequest.has_color_brightness)
    pub has_color_brightness: bool,
    // @@protoc_insertion_point(field:LightCommandRequest.color_brightness)
    pub color_brightness: f32,
    // @@protoc_insertion_point(field:LightCommandRequest.has_rgb)
    pub has_rgb: bool,
    // @@protoc_insertion_point(field:LightCommandRequest.red)
    pub red: f32,
    // @@protoc_insertion_point(field:LightCommandRequest.green)
    pub green: f32,
    // @@protoc_insertion_point(field:LightCommandRequest.blue)
    pub blue: f32,
    // @@protoc_insertion_point(field:LightCommandRequest.has_white)
    pub has_white: bool,
    // @@protoc_insertion_point(field:LightCommandRequest.white)
    pub white: f32,
    // @@protoc_insertion_point(field:LightCommandRequest.has_color_temperature)
    pub has_color_temperature: bool,
    // @@protoc_insertion_point(field:LightCommandRequest.color_temperature)
    pub color_temperature: f32,
    // @@protoc_insertion_point(field:LightCommandRequest.has_cold_white)
    pub has_cold_white: bool,
    // @@protoc_insertion_point(field:LightCommandRequest.cold_white)
    pub cold_white: f32,
    // @@protoc_insertion_point(field:LightCommandRequest.has_warm_white)
    pub has_warm_white: bool,
    // @@protoc_insertion_point(field:LightCommandRequest.warm_white)
    pub warm_white: f32,
    // @@protoc_insertion_point(field:LightCommandRequest.has_transition_length)
    pub has_transition_length: bool,
    // @@protoc_insertion_point(field:LightCommandRequest.transition_length)
    pub transition_length: u32,
    // @@protoc_insertion_point(field:LightCommandRequest.has_flash_length)
    pub has_flash_length: bool,
    // @@protoc_insertion_point(field:LightCommandRequest.flash_length)
    pub flash_length: u32,
    // @@protoc_insertion_point(field:LightCommandRequest.has_effect)
    pub has_effect: bool,
    // @@protoc_insertion_point(field:LightCommandRequest.effect)
    pub effect: ::std::string::String,
    // @@protoc_insertion_point(field:LightCommandRequest.device_id)
    pub device_id: u32,
    // special fields
    // @@protoc_insertion_point(special_field:LightCommandRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a LightCommandRequest {
    fn default() -> &'a LightCommandRequest {
        <LightCommandRequest as ::protobuf::Message>::default_instance()
    }
}

impl LightCommandRequest {
    pub fn new() -> LightCommandRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(28);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "key",
            |m: &LightCommandRequest| { &m.key },
            |m: &mut LightCommandRequest| { &mut m.key },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "has_state",
            |m: &LightCommandRequest| { &m.has_state },
            |m: &mut LightCommandRequest| { &mut m.has_state },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "state",
            |m: &LightCommandRequest| { &m.state },
            |m: &mut LightCommandRequest| { &mut m.state },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "has_brightness",
            |m: &LightCommandRequest| { &m.has_brightness },
            |m: &mut LightCommandRequest| { &mut m.has_brightness },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "brightness",
            |m: &LightCommandRequest| { &m.brightness },
            |m: &mut LightCommandRequest| { &mut m.brightness },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "has_color_mode",
            |m: &LightCommandRequest| { &m.has_color_mode },
            |m: &mut LightCommandRequest| { &mut m.has_color_mode },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "color_mode",
            |m: &LightCommandRequest| { &m.color_mode },
            |m: &mut LightCommandRequest| { &mut m.color_mode },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "has_color_brightness",
            |m: &LightCommandRequest| { &m.has_color_brightness },
            |m: &mut LightCommandRequest| { &mut m.has_color_brightness },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "color_brightness",
            |m: &LightCommandRequest| { &m.color_brightness },
            |m: &mut LightCommandRequest| { &mut m.color_brightness },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "has_rgb",
            |m: &LightCommandRequest| { &m.has_rgb },
            |m: &mut LightCommandRequest| { &mut m.has_rgb },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "red",
            |m: &LightCommandRequest| { &m.red },
            |m: &mut LightCommandRequest| { &mut m.red },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "green",
            |m: &LightCommandRequest| { &m.green },
            |m: &mut LightCommandRequest| { &mut m.green },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "blue",
            |m: &LightCommandRequest| { &m.blue },
            |m: &mut LightCommandRequest| { &mut m.blue },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "has_white",
            |m: &LightCommandRequest| { &m.has_white },
            |m: &mut LightCommandRequest| { &mut m.has_white },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "white",
            |m: &LightCommandRequest| { &m.white },
            |m: &mut LightCommandRequest| { &mut m.white },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "has_color_temperature",
            |m: &LightCommandRequest| { &m.has_color_temperature },
            |m: &mut LightCommandRequest| { &mut m.has_color_temperature },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "color_temperature",
            |m: &LightCommandRequest| { &m.color_temperature },
            |m: &mut LightCommandRequest| { &mut m.color_temperature },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "has_cold_white",
            |m: &LightCommandRequest| { &m.has_cold_white },
            |m: &mut LightCommandRequest| { &mut m.has_cold_white },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "cold_white",
            |m: &LightCommandRequest| { &m.cold_white },
            |m: &mut LightCommandRequest| { &mut m.cold_white },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "has_warm_white",
            |m: &LightCommandRequest| { &m.has_warm_white },
            |m: &mut LightCommandRequest| { &mut m.has_warm_white },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "warm_white",
            |m: &LightCommandRequest| { &m.warm_white },
            |m: &mut LightCommandRequest| { &mut m.warm_white },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "has_transition_length",
            |m: &LightCommandRequest| { &m.has_transition_length },
            |m: &mut LightCommandRequest| { &mut m.has_transition_length },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "transition_length",
            |m: &LightCommandRequest| { &m.transition_length },
            |m: &mut LightCommandRequest| { &mut m.transition_length },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "has_flash_length",
            |m: &LightCommandRequest| { &m.has_flash_length },
            |m: &mut LightCommandRequest| { &mut m.has_flash_length },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "flash_length",
            |m: &LightCommandRequest| { &m.flash_length },
            |m: &mut LightCommandRequest| { &mut m.flash_length },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "has_effect",
            |m: &LightCommandRequest| { &m.has_effect },
            |m: &mut LightCommandRequest| { &mut m.has_effect },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "effect",
            |m: &LightCommandRequest| { &m.effect },
            |m: &mut LightCommandRequest| { &mut m.effect },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "device_id",
            |m: &LightCommandRequest| { &m.device_id },
            |m: &mut LightCommandRequest| { &mut m.device_id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<LightCommandRequest>(
            "LightCommandRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for LightCommandRequest {
    const NAME: &'static str = "LightCommandRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                13 => {
                    self.key = is.read_fixed32()?;
                },
                16 => {
                    self.has_state = is.read_bool()?;
                },
                24 => {
                    self.state = is.read_bool()?;
                },
                32 => {
                    self.has_brightness = is.read_bool()?;
                },
                45 => {
                    self.brightness = is.read_float()?;
                },
                176 => {
                    self.has_color_mode = is.read_bool()?;
                },
                184 => {
                    self.color_mode = is.read_enum_or_unknown()?;
                },
                160 => {
                    self.has_color_brightness = is.read_bool()?;
                },
                173 => {
                    self.color_brightness = is.read_float()?;
                },
                48 => {
                    self.has_rgb = is.read_bool()?;
                },
                61 => {
                    self.red = is.read_float()?;
                },
                69 => {
                    self.green = is.read_float()?;
                },
                77 => {
                    self.blue = is.read_float()?;
                },
                80 => {
                    self.has_white = is.read_bool()?;
                },
                93 => {
                    self.white = is.read_float()?;
                },
                96 => {
                    self.has_color_temperature = is.read_bool()?;
                },
                109 => {
                    self.color_temperature = is.read_float()?;
                },
                192 => {
                    self.has_cold_white = is.read_bool()?;
                },
                205 => {
                    self.cold_white = is.read_float()?;
                },
                208 => {
                    self.has_warm_white = is.read_bool()?;
                },
                221 => {
                    self.warm_white = is.read_float()?;
                },
                112 => {
                    self.has_transition_length = is.read_bool()?;
                },
                120 => {
                    self.transition_length = is.read_uint32()?;
                },
                128 => {
                    self.has_flash_length = is.read_bool()?;
                },
                136 => {
                    self.flash_length = is.read_uint32()?;
                },
                144 => {
                    self.has_effect = is.read_bool()?;
                },
                154 => {
                    self.effect = is.read_string()?;
                },
                224 => {
                    self.device_id = is.read_uint32()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.key != 0 {
            my_size += 1 + 4;
        }
        if self.has_state != false {
            my_size += 1 + 1;
        }
        if self.state != false {
            my_size += 1 + 1;
        }
        if self.has_brightness != false {
            my_size += 1 + 1;
        }
        if self.brightness != 0. {
            my_size += 1 + 4;
        }
        if self.has_color_mode != false {
            my_size += 2 + 1;
        }
        if self.color_mode != ::protobuf::EnumOrUnknown::new(ColorMode::COLOR_MODE_UNKNOWN) {
            my_size += ::protobuf::rt::int32_size(23, self.color_mode.value());
        }
        if self.has_color_brightness != false {
            my_size += 2 + 1;
        }
        if self.color_brightness != 0. {
            my_size += 2 + 4;
        }
        if self.has_rgb != false {
            my_size += 1 + 1;
        }
        if self.red != 0. {
            my_size += 1 + 4;
        }
        if self.green != 0. {
            my_size += 1 + 4;
        }
        if self.blue != 0. {
            my_size += 1 + 4;
        }
        if self.has_white != false {
            my_size += 1 + 1;
        }
        if self.white != 0. {
            my_size += 1 + 4;
        }
        if self.has_color_temperature != false {
            my_size += 1 + 1;
        }
        if self.color_temperature != 0. {
            my_size += 1 + 4;
        }
        if self.has_cold_white != false {
            my_size += 2 + 1;
        }
        if self.cold_white != 0. {
            my_size += 2 + 4;
        }
        if self.has_warm_white != false {
            my_size += 2 + 1;
        }
        if self.warm_white != 0. {
            my_size += 2 + 4;
        }
        if self.has_transition_length != false {
            my_size += 1 + 1;
        }
        if self.transition_length != 0 {
            my_size += ::protobuf::rt::uint32_size(15, self.transition_length);
        }
        if self.has_flash_length != false {
            my_size += 2 + 1;
        }
        if self.flash_length != 0 {
            my_size += ::protobuf::rt::uint32_size(17, self.flash_length);
        }
        if self.has_effect != false {
            my_size += 2 + 1;
        }
        if !self.effect.is_empty() {
            my_size += ::protobuf::rt::string_size(19, &self.effect);
        }
        if self.device_id != 0 {
            my_size += ::protobuf::rt::uint32_size(28, self.device_id);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.key != 0 {
            os.write_fixed32(1, self.key)?;
        }
        if self.has_state != false {
            os.write_bool(2, self.has_state)?;
        }
        if self.state != false {
            os.write_bool(3, self.state)?;
        }
        if self.has_brightness != false {
            os.write_bool(4, self.has_brightness)?;
        }
        if self.brightness != 0. {
            os.write_float(5, self.brightness)?;
        }
        if self.has_color_mode != false {
            os.write_bool(22, self.has_color_mode)?;
        }
        if self.color_mode != ::protobuf::EnumOrUnknown::new(ColorMode::COLOR_MODE_UNKNOWN) {
            os.write_enum(23, ::protobuf::EnumOrUnknown::value(&self.color_mode))?;
        }
        if self.has_color_brightness != false {
            os.write_bool(20, self.has_color_brightness)?;
        }
        if self.color_brightness != 0. {
            os.write_float(21, self.color_brightness)?;
        }
        if self.has_rgb != false {
            os.write_bool(6, self.has_rgb)?;
        }
        if self.red != 0. {
            os.write_float(7, self.red)?;
        }
        if self.green != 0. {
            os.write_float(8, self.green)?;
        }
        if self.blue != 0. {
            os.write_float(9, self.blue)?;
        }
        if self.has_white != false {
            os.write_bool(10, self.has_white)?;
        }
        if self.white != 0. {
            os.write_float(11, self.white)?;
        }
        if self.has_color_temperature != false {
            os.write_bool(12, self.has_color_temperature)?;
        }
        if self.color_temperature != 0. {
            os.write_float(13, self.color_temperature)?;
        }
        if self.has_cold_white != false {
            os.write_bool(24, self.has_cold_white)?;
        }
        if self.cold_white != 0. {
            os.write_float(25, self.cold_white)?;
        }
        if self.has_warm_white != false {
            os.write_bool(26, self.has_warm_white)?;
        }
        if self.warm_white != 0. {
            os.write_float(27, self.warm_white)?;
        }
        if self.has_transition_length != false {
            os.write_bool(14, self.has_transition_length)?;
        }
        if self.transition_length != 0 {
            os.write_uint32(15, self.transition_length)?;
        }
        if self.has_flash_length != false {
            os.write_bool(16, self.has_flash_length)?;
        }
        if self.flash_length != 0 {
            os.write_uint32(17, self.flash_length)?;
        }
        if self.has_effect != false {
            os.write_bool(18, self.has_effect)?;
        }
        if !self.effect.is_empty() {
            os.write_string(19, &self.effect)?;
        }
        if self.device_id != 0 {
            os.write_uint32(28, self.device_id)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> LightCommandRequest {
        LightCommandRequest::new()
    }

    fn clear(&mut self) {
        self.key = 0;
        self.has_state = false;
        self.state = false;
        self.has_brightness = false;
        self.brightness = 0.;
        self.has_color_mode = false;
        self.color_mode = ::protobuf::EnumOrUnknown::new(ColorMode::COLOR_MODE_UNKNOWN);
        self.has_color_brightness = false;
        self.color_brightness = 0.;
        self.has_rgb = false;
        self.red = 0.;
        self.green = 0.;
        self.blue = 0.;
        self.has_white = false;
        self.white = 0.;
        self.has_color_temperature = false;
        self.color_temperature = 0.;
        self.has_cold_white = false;
        self.cold_white = 0.;
        self.has_warm_white = false;
        self.warm_white = 0.;
        self.has_transition_length = false;
        self.transition_length = 0;
        self.has_flash_length = false;
        self.flash_length = 0;
        self.has_effect = false;
        self.effect.clear();
        self.device_id = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static LightCommandRequest {
        static instance: LightCommandRequest = LightCommandRequest {
            key: 0,
            has_state: false,
            state: false,
            has_brightness: false,
            brightness: 0.,
            has_color_mode: false,
            color_mode: ::protobuf::EnumOrUnknown::from_i32(0),
            has_color_brightness: false,
            color_brightness: 0.,
            has_rgb: false,
            red: 0.,
            green: 0.,
            blue: 0.,
            has_white: false,
            white: 0.,
            has_color_temperature: false,
            color_temperature: 0.,
            has_cold_white: false,
            cold_white: 0.,
            has_warm_white: false,
            warm_white: 0.,
            has_transition_length: false,
            transition_length: 0,
            has_flash_length: false,
            flash_length: 0,
            has_effect: false,
            effect: ::std::string::String::new(),
            device_id: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for LightCommandRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("LightCommandRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for LightCommandRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for LightCommandRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:ListEntitiesSensorResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ListEntitiesSensorResponse {
    // message fields
    // @@protoc_insertion_point(field:ListEntitiesSensorResponse.object_id)
    pub object_id: ::std::string::String,
    // @@protoc_insertion_point(field:ListEntitiesSensorResponse.key)
    pub key: u32,
    // @@protoc_insertion_point(field:ListEntitiesSensorResponse.name)
    pub name: ::std::string::String,
    // @@protoc_insertion_point(field:ListEntitiesSensorResponse.unique_id)
    pub unique_id: ::std::string::String,
    // @@protoc_insertion_point(field:ListEntitiesSensorResponse.icon)
    pub icon: ::std::string::String,
    // @@protoc_insertion_point(field:ListEntitiesSensorResponse.unit_of_measurement)
    pub unit_of_measurement: ::std::string::String,
    // @@protoc_insertion_point(field:ListEntitiesSensorResponse.accuracy_decimals)
    pub accuracy_decimals: i32,
    // @@protoc_insertion_point(field:ListEntitiesSensorResponse.force_update)
    pub force_update: bool,
    // @@protoc_insertion_point(field:ListEntitiesSensorResponse.device_class)
    pub device_class: ::std::string::String,
    // @@protoc_insertion_point(field:ListEntitiesSensorResponse.state_class)
    pub state_class: ::protobuf::EnumOrUnknown<SensorStateClass>,
    // @@protoc_insertion_point(field:ListEntitiesSensorResponse.legacy_last_reset_type)
    pub legacy_last_reset_type: ::protobuf::EnumOrUnknown<SensorLastResetType>,
    // @@protoc_insertion_point(field:ListEntitiesSensorResponse.disabled_by_default)
    pub disabled_by_default: bool,
    // @@protoc_insertion_point(field:ListEntitiesSensorResponse.entity_category)
    pub entity_category: ::protobuf::EnumOrUnknown<EntityCategory>,
    // @@protoc_insertion_point(field:ListEntitiesSensorResponse.device_id)
    pub device_id: u32,
    // special fields
    // @@protoc_insertion_point(special_field:ListEntitiesSensorResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ListEntitiesSensorResponse {
    fn default() -> &'a ListEntitiesSensorResponse {
        <ListEntitiesSensorResponse as ::protobuf::Message>::default_instance()
    }
}

impl ListEntitiesSensorResponse {
    pub fn new() -> ListEntitiesSensorResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(14);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "object_id",
            |m: &ListEntitiesSensorResponse| { &m.object_id },
            |m: &mut ListEntitiesSensorResponse| { &mut m.object_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "key",
            |m: &ListEntitiesSensorResponse| { &m.key },
            |m: &mut ListEntitiesSensorResponse| { &mut m.key },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "name",
            |m: &ListEntitiesSensorResponse| { &m.name },
            |m: &mut ListEntitiesSensorResponse| { &mut m.name },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "unique_id",
            |m: &ListEntitiesSensorResponse| { &m.unique_id },
            |m: &mut ListEntitiesSensorResponse| { &mut m.unique_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "icon",
            |m: &ListEntitiesSensorResponse| { &m.icon },
            |m: &mut ListEntitiesSensorResponse| { &mut m.icon },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "unit_of_measurement",
            |m: &ListEntitiesSensorResponse| { &m.unit_of_measurement },
            |m: &mut ListEntitiesSensorResponse| { &mut m.unit_of_measurement },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "accuracy_decimals",
            |m: &ListEntitiesSensorResponse| { &m.accuracy_decimals },
            |m: &mut ListEntitiesSensorResponse| { &mut m.accuracy_decimals },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "force_update",
            |m: &ListEntitiesSensorResponse| { &m.force_update },
            |m: &mut ListEntitiesSensorResponse| { &mut m.force_update },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "device_class",
            |m: &ListEntitiesSensorResponse| { &m.device_class },
            |m: &mut ListEntitiesSensorResponse| { &mut m.device_class },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "state_class",
            |m: &ListEntitiesSensorResponse| { &m.state_class },
            |m: &mut ListEntitiesSensorResponse| { &mut m.state_class },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "legacy_last_reset_type",
            |m: &ListEntitiesSensorResponse| { &m.legacy_last_reset_type },
            |m: &mut ListEntitiesSensorResponse| { &mut m.legacy_last_reset_type },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "disabled_by_default",
            |m: &ListEntitiesSensorResponse| { &m.disabled_by_default },
            |m: &mut ListEntitiesSensorResponse| { &mut m.disabled_by_default },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "entity_category",
            |m: &ListEntitiesSensorResponse| { &m.entity_category },
            |m: &mut ListEntitiesSensorResponse| { &mut m.entity_category },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "device_id",
            |m: &ListEntitiesSensorResponse| { &m.device_id },
            |m: &mut ListEntitiesSensorResponse| { &mut m.device_id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ListEntitiesSensorResponse>(
            "ListEntitiesSensorResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ListEntitiesSensorResponse {
    const NAME: &'static str = "ListEntitiesSensorResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.object_id = is.read_string()?;
                },
                21 => {
                    self.key = is.read_fixed32()?;
                },
                26 => {
                    self.name = is.read_string()?;
                },
                34 => {
                    self.unique_id = is.read_string()?;
                },
                42 => {
                    self.icon = is.read_string()?;
                },
                50 => {
                    self.unit_of_measurement = is.read_string()?;
                },
                56 => {
                    self.accuracy_decimals = is.read_int32()?;
                },
                64 => {
                    self.force_update = is.read_bool()?;
                },
                74 => {
                    self.device_class = is.read_string()?;
                },
                80 => {
                    self.state_class = is.read_enum_or_unknown()?;
                },
                88 => {
                    self.legacy_last_reset_type = is.read_enum_or_unknown()?;
                },
                96 => {
                    self.disabled_by_default = is.read_bool()?;
                },
                104 => {
                    self.entity_category = is.read_enum_or_unknown()?;
                },
                112 => {
                    self.device_id = is.read_uint32()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.object_id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.object_id);
        }
        if self.key != 0 {
            my_size += 1 + 4;
        }
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.name);
        }
        if !self.unique_id.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.unique_id);
        }
        if !self.icon.is_empty() {
            my_size += ::protobuf::rt::string_size(5, &self.icon);
        }
        if !self.unit_of_measurement.is_empty() {
            my_size += ::protobuf::rt::string_size(6, &self.unit_of_measurement);
        }
        if self.accuracy_decimals != 0 {
            my_size += ::protobuf::rt::int32_size(7, self.accuracy_decimals);
        }
        if self.force_update != false {
            my_size += 1 + 1;
        }
        if !self.device_class.is_empty() {
            my_size += ::protobuf::rt::string_size(9, &self.device_class);
        }
        if self.state_class != ::protobuf::EnumOrUnknown::new(SensorStateClass::STATE_CLASS_NONE) {
            my_size += ::protobuf::rt::int32_size(10, self.state_class.value());
        }
        if self.legacy_last_reset_type != ::protobuf::EnumOrUnknown::new(SensorLastResetType::LAST_RESET_NONE) {
            my_size += ::protobuf::rt::int32_size(11, self.legacy_last_reset_type.value());
        }
        if self.disabled_by_default != false {
            my_size += 1 + 1;
        }
        if self.entity_category != ::protobuf::EnumOrUnknown::new(EntityCategory::ENTITY_CATEGORY_NONE) {
            my_size += ::protobuf::rt::int32_size(13, self.entity_category.value());
        }
        if self.device_id != 0 {
            my_size += ::protobuf::rt::uint32_size(14, self.device_id);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.object_id.is_empty() {
            os.write_string(1, &self.object_id)?;
        }
        if self.key != 0 {
            os.write_fixed32(2, self.key)?;
        }
        if !self.name.is_empty() {
            os.write_string(3, &self.name)?;
        }
        if !self.unique_id.is_empty() {
            os.write_string(4, &self.unique_id)?;
        }
        if !self.icon.is_empty() {
            os.write_string(5, &self.icon)?;
        }
        if !self.unit_of_measurement.is_empty() {
            os.write_string(6, &self.unit_of_measurement)?;
        }
        if self.accuracy_decimals != 0 {
            os.write_int32(7, self.accuracy_decimals)?;
        }
        if self.force_update != false {
            os.write_bool(8, self.force_update)?;
        }
        if !self.device_class.is_empty() {
            os.write_string(9, &self.device_class)?;
        }
        if self.state_class != ::protobuf::EnumOrUnknown::new(SensorStateClass::STATE_CLASS_NONE) {
            os.write_enum(10, ::protobuf::EnumOrUnknown::value(&self.state_class))?;
        }
        if self.legacy_last_reset_type != ::protobuf::EnumOrUnknown::new(SensorLastResetType::LAST_RESET_NONE) {
            os.write_enum(11, ::protobuf::EnumOrUnknown::value(&self.legacy_last_reset_type))?;
        }
        if self.disabled_by_default != false {
            os.write_bool(12, self.disabled_by_default)?;
        }
        if self.entity_category != ::protobuf::EnumOrUnknown::new(EntityCategory::ENTITY_CATEGORY_NONE) {
            os.write_enum(13, ::protobuf::EnumOrUnknown::value(&self.entity_category))?;
        }
        if self.device_id != 0 {
            os.write_uint32(14, self.device_id)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ListEntitiesSensorResponse {
        ListEntitiesSensorResponse::new()
    }

    fn clear(&mut self) {
        self.object_id.clear();
        self.key = 0;
        self.name.clear();
        self.unique_id.clear();
        self.icon.clear();
        self.unit_of_measurement.clear();
        self.accuracy_decimals = 0;
        self.force_update = false;
        self.device_class.clear();
        self.state_class = ::protobuf::EnumOrUnknown::new(SensorStateClass::STATE_CLASS_NONE);
        self.legacy_last_reset_type = ::protobuf::EnumOrUnknown::new(SensorLastResetType::LAST_RESET_NONE);
        self.disabled_by_default = false;
        self.entity_category = ::protobuf::EnumOrUnknown::new(EntityCategory::ENTITY_CATEGORY_NONE);
        self.device_id = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ListEntitiesSensorResponse {
        static instance: ListEntitiesSensorResponse = ListEntitiesSensorResponse {
            object_id: ::std::string::String::new(),
            key: 0,
            name: ::std::string::String::new(),
            unique_id: ::std::string::String::new(),
            icon: ::std::string::String::new(),
            unit_of_measurement: ::std::string::String::new(),
            accuracy_decimals: 0,
            force_update: false,
            device_class: ::std::string::String::new(),
            state_class: ::protobuf::EnumOrUnknown::from_i32(0),
            legacy_last_reset_type: ::protobuf::EnumOrUnknown::from_i32(0),
            disabled_by_default: false,
            entity_category: ::protobuf::EnumOrUnknown::from_i32(0),
            device_id: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ListEntitiesSensorResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ListEntitiesSensorResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ListEntitiesSensorResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ListEntitiesSensorResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:SensorStateResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct SensorStateResponse {
    // message fields
    // @@protoc_insertion_point(field:SensorStateResponse.key)
    pub key: u32,
    // @@protoc_insertion_point(field:SensorStateResponse.state)
    pub state: f32,
    // @@protoc_insertion_point(field:SensorStateResponse.missing_state)
    pub missing_state: bool,
    // @@protoc_insertion_point(field:SensorStateResponse.device_id)
    pub device_id: u32,
    // special fields
    // @@protoc_insertion_point(special_field:SensorStateResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a SensorStateResponse {
    fn default() -> &'a SensorStateResponse {
        <SensorStateResponse as ::protobuf::Message>::default_instance()
    }
}

impl SensorStateResponse {
    pub fn new() -> SensorStateResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "key",
            |m: &SensorStateResponse| { &m.key },
            |m: &mut SensorStateResponse| { &mut m.key },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "state",
            |m: &SensorStateResponse| { &m.state },
            |m: &mut SensorStateResponse| { &mut m.state },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "missing_state",
            |m: &SensorStateResponse| { &m.missing_state },
            |m: &mut SensorStateResponse| { &mut m.missing_state },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "device_id",
            |m: &SensorStateResponse| { &m.device_id },
            |m: &mut SensorStateResponse| { &mut m.device_id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<SensorStateResponse>(
            "SensorStateResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for SensorStateResponse {
    const NAME: &'static str = "SensorStateResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                13 => {
                    self.key = is.read_fixed32()?;
                },
                21 => {
                    self.state = is.read_float()?;
                },
                24 => {
                    self.missing_state = is.read_bool()?;
                },
                32 => {
                    self.device_id = is.read_uint32()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.key != 0 {
            my_size += 1 + 4;
        }
        if self.state != 0. {
            my_size += 1 + 4;
        }
        if self.missing_state != false {
            my_size += 1 + 1;
        }
        if self.device_id != 0 {
            my_size += ::protobuf::rt::uint32_size(4, self.device_id);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.key != 0 {
            os.write_fixed32(1, self.key)?;
        }
        if self.state != 0. {
            os.write_float(2, self.state)?;
        }
        if self.missing_state != false {
            os.write_bool(3, self.missing_state)?;
        }
        if self.device_id != 0 {
            os.write_uint32(4, self.device_id)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> SensorStateResponse {
        SensorStateResponse::new()
    }

    fn clear(&mut self) {
        self.key = 0;
        self.state = 0.;
        self.missing_state = false;
        self.device_id = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static SensorStateResponse {
        static instance: SensorStateResponse = SensorStateResponse {
            key: 0,
            state: 0.,
            missing_state: false,
            device_id: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for SensorStateResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("SensorStateResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for SensorStateResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SensorStateResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:ListEntitiesSwitchResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ListEntitiesSwitchResponse {
    // message fields
    // @@protoc_insertion_point(field:ListEntitiesSwitchResponse.object_id)
    pub object_id: ::std::string::String,
    // @@protoc_insertion_point(field:ListEntitiesSwitchResponse.key)
    pub key: u32,
    // @@protoc_insertion_point(field:ListEntitiesSwitchResponse.name)
    pub name: ::std::string::String,
    // @@protoc_insertion_point(field:ListEntitiesSwitchResponse.unique_id)
    pub unique_id: ::std::string::String,
    // @@protoc_insertion_point(field:ListEntitiesSwitchResponse.icon)
    pub icon: ::std::string::String,
    // @@protoc_insertion_point(field:ListEntitiesSwitchResponse.assumed_state)
    pub assumed_state: bool,
    // @@protoc_insertion_point(field:ListEntitiesSwitchResponse.disabled_by_default)
    pub disabled_by_default: bool,
    // @@protoc_insertion_point(field:ListEntitiesSwitchResponse.entity_category)
    pub entity_category: ::protobuf::EnumOrUnknown<EntityCategory>,
    // @@protoc_insertion_point(field:ListEntitiesSwitchResponse.device_class)
    pub device_class: ::std::string::String,
    // @@protoc_insertion_point(field:ListEntitiesSwitchResponse.device_id)
    pub device_id: u32,
    // special fields
    // @@protoc_insertion_point(special_field:ListEntitiesSwitchResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ListEntitiesSwitchResponse {
    fn default() -> &'a ListEntitiesSwitchResponse {
        <ListEntitiesSwitchResponse as ::protobuf::Message>::default_instance()
    }
}

impl ListEntitiesSwitchResponse {
    pub fn new() -> ListEntitiesSwitchResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(10);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "object_id",
            |m: &ListEntitiesSwitchResponse| { &m.object_id },
            |m: &mut ListEntitiesSwitchResponse| { &mut m.object_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "key",
            |m: &ListEntitiesSwitchResponse| { &m.key },
            |m: &mut ListEntitiesSwitchResponse| { &mut m.key },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "name",
            |m: &ListEntitiesSwitchResponse| { &m.name },
            |m: &mut ListEntitiesSwitchResponse| { &mut m.name },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "unique_id",
            |m: &ListEntitiesSwitchResponse| { &m.unique_id },
            |m: &mut ListEntitiesSwitchResponse| { &mut m.unique_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "icon",
            |m: &ListEntitiesSwitchResponse| { &m.icon },
            |m: &mut ListEntitiesSwitchResponse| { &mut m.icon },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "assumed_state",
            |m: &ListEntitiesSwitchResponse| { &m.assumed_state },
            |m: &mut ListEntitiesSwitchResponse| { &mut m.assumed_state },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "disabled_by_default",
            |m: &ListEntitiesSwitchResponse| { &m.disabled_by_default },
            |m: &mut ListEntitiesSwitchResponse| { &mut m.disabled_by_default },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "entity_category",
            |m: &ListEntitiesSwitchResponse| { &m.entity_category },
            |m: &mut ListEntitiesSwitchResponse| { &mut m.entity_category },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "device_class",
            |m: &ListEntitiesSwitchResponse| { &m.device_class },
            |m: &mut ListEntitiesSwitchResponse| { &mut m.device_class },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "device_id",
            |m: &ListEntitiesSwitchResponse| { &m.device_id },
            |m: &mut ListEntitiesSwitchResponse| { &mut m.device_id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ListEntitiesSwitchResponse>(
            "ListEntitiesSwitchResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ListEntitiesSwitchResponse {
    const NAME: &'static str = "ListEntitiesSwitchResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.object_id = is.read_string()?;
                },
                21 => {
                    self.key = is.read_fixed32()?;
                },
                26 => {
                    self.name = is.read_string()?;
                },
                34 => {
                    self.unique_id = is.read_string()?;
                },
                42 => {
                    self.icon = is.read_string()?;
                },
                48 => {
                    self.assumed_state = is.read_bool()?;
                },
                56 => {
                    self.disabled_by_default = is.read_bool()?;
                },
                64 => {
                    self.entity_category = is.read_enum_or_unknown()?;
                },
                74 => {
                    self.device_class = is.read_string()?;
                },
                80 => {
                    self.device_id = is.read_uint32()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.object_id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.object_id);
        }
        if self.key != 0 {
            my_size += 1 + 4;
        }
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.name);
        }
        if !self.unique_id.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.unique_id);
        }
        if !self.icon.is_empty() {
            my_size += ::protobuf::rt::string_size(5, &self.icon);
        }
        if self.assumed_state != false {
            my_size += 1 + 1;
        }
        if self.disabled_by_default != false {
            my_size += 1 + 1;
        }
        if self.entity_category != ::protobuf::EnumOrUnknown::new(EntityCategory::ENTITY_CATEGORY_NONE) {
            my_size += ::protobuf::rt::int32_size(8, self.entity_category.value());
        }
        if !self.device_class.is_empty() {
            my_size += ::protobuf::rt::string_size(9, &self.device_class);
        }
        if self.device_id != 0 {
            my_size += ::protobuf::rt::uint32_size(10, self.device_id);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.object_id.is_empty() {
            os.write_string(1, &self.object_id)?;
        }
        if self.key != 0 {
            os.write_fixed32(2, self.key)?;
        }
        if !self.name.is_empty() {
            os.write_string(3, &self.name)?;
        }
        if !self.unique_id.is_empty() {
            os.write_string(4, &self.unique_id)?;
        }
        if !self.icon.is_empty() {
            os.write_string(5, &self.icon)?;
        }
        if self.assumed_state != false {
            os.write_bool(6, self.assumed_state)?;
        }
        if self.disabled_by_default != false {
            os.write_bool(7, self.disabled_by_default)?;
        }
        if self.entity_category != ::protobuf::EnumOrUnknown::new(EntityCategory::ENTITY_CATEGORY_NONE) {
            os.write_enum(8, ::protobuf::EnumOrUnknown::value(&self.entity_category))?;
        }
        if !self.device_class.is_empty() {
            os.write_string(9, &self.device_class)?;
        }
        if self.device_id != 0 {
            os.write_uint32(10, self.device_id)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ListEntitiesSwitchResponse {
        ListEntitiesSwitchResponse::new()
    }

    fn clear(&mut self) {
        self.object_id.clear();
        self.key = 0;
        self.name.clear();
        self.unique_id.clear();
        self.icon.clear();
        self.assumed_state = false;
        self.disabled_by_default = false;
        self.entity_category = ::protobuf::EnumOrUnknown::new(EntityCategory::ENTITY_CATEGORY_NONE);
        self.device_class.clear();
        self.device_id = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ListEntitiesSwitchResponse {
        static instance: ListEntitiesSwitchResponse = ListEntitiesSwitchResponse {
            object_id: ::std::string::String::new(),
            key: 0,
            name: ::std::string::String::new(),
            unique_id: ::std::string::String::new(),
            icon: ::std::string::String::new(),
            assumed_state: false,
            disabled_by_default: false,
            entity_category: ::protobuf::EnumOrUnknown::from_i32(0),
            device_class: ::std::string::String::new(),
            device_id: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ListEntitiesSwitchResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ListEntitiesSwitchResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ListEntitiesSwitchResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ListEntitiesSwitchResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:SwitchStateResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct SwitchStateResponse {
    // message fields
    // @@protoc_insertion_point(field:SwitchStateResponse.key)
    pub key: u32,
    // @@protoc_insertion_point(field:SwitchStateResponse.state)
    pub state: bool,
    // @@protoc_insertion_point(field:SwitchStateResponse.device_id)
    pub device_id: u32,
    // special fields
    // @@protoc_insertion_point(special_field:SwitchStateResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a SwitchStateResponse {
    fn default() -> &'a SwitchStateResponse {
        <SwitchStateResponse as ::protobuf::Message>::default_instance()
    }
}

impl SwitchStateResponse {
    pub fn new() -> SwitchStateResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "key",
            |m: &SwitchStateResponse| { &m.key },
            |m: &mut SwitchStateResponse| { &mut m.key },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "state",
            |m: &SwitchStateResponse| { &m.state },
            |m: &mut SwitchStateResponse| { &mut m.state },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "device_id",
            |m: &SwitchStateResponse| { &m.device_id },
            |m: &mut SwitchStateResponse| { &mut m.device_id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<SwitchStateResponse>(
            "SwitchStateResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for SwitchStateResponse {
    const NAME: &'static str = "SwitchStateResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                13 => {
                    self.key = is.read_fixed32()?;
                },
                16 => {
                    self.state = is.read_bool()?;
                },
                24 => {
                    self.device_id = is.read_uint32()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.key != 0 {
            my_size += 1 + 4;
        }
        if self.state != false {
            my_size += 1 + 1;
        }
        if self.device_id != 0 {
            my_size += ::protobuf::rt::uint32_size(3, self.device_id);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.key != 0 {
            os.write_fixed32(1, self.key)?;
        }
        if self.state != false {
            os.write_bool(2, self.state)?;
        }
        if self.device_id != 0 {
            os.write_uint32(3, self.device_id)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> SwitchStateResponse {
        SwitchStateResponse::new()
    }

    fn clear(&mut self) {
        self.key = 0;
        self.state = false;
        self.device_id = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static SwitchStateResponse {
        static instance: SwitchStateResponse = SwitchStateResponse {
            key: 0,
            state: false,
            device_id: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for SwitchStateResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("SwitchStateResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for SwitchStateResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SwitchStateResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:SwitchCommandRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct SwitchCommandRequest {
    // message fields
    // @@protoc_insertion_point(field:SwitchCommandRequest.key)
    pub key: u32,
    // @@protoc_insertion_point(field:SwitchCommandRequest.state)
    pub state: bool,
    // @@protoc_insertion_point(field:SwitchCommandRequest.device_id)
    pub device_id: u32,
    // special fields
    // @@protoc_insertion_point(special_field:SwitchCommandRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a SwitchCommandRequest {
    fn default() -> &'a SwitchCommandRequest {
        <SwitchCommandRequest as ::protobuf::Message>::default_instance()
    }
}

impl SwitchCommandRequest {
    pub fn new() -> SwitchCommandRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "key",
            |m: &SwitchCommandRequest| { &m.key },
            |m: &mut SwitchCommandRequest| { &mut m.key },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "state",
            |m: &SwitchCommandRequest| { &m.state },
            |m: &mut SwitchCommandRequest| { &mut m.state },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "device_id",
            |m: &SwitchCommandRequest| { &m.device_id },
            |m: &mut SwitchCommandRequest| { &mut m.device_id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<SwitchCommandRequest>(
            "SwitchCommandRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for SwitchCommandRequest {
    const NAME: &'static str = "SwitchCommandRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                13 => {
                    self.key = is.read_fixed32()?;
                },
                16 => {
                    self.state = is.read_bool()?;
                },
                24 => {
                    self.device_id = is.read_uint32()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.key != 0 {
            my_size += 1 + 4;
        }
        if self.state != false {
            my_size += 1 + 1;
        }
        if self.device_id != 0 {
            my_size += ::protobuf::rt::uint32_size(3, self.device_id);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.key != 0 {
            os.write_fixed32(1, self.key)?;
        }
        if self.state != false {
            os.write_bool(2, self.state)?;
        }
        if self.device_id != 0 {
            os.write_uint32(3, self.device_id)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> SwitchCommandRequest {
        SwitchCommandRequest::new()
    }

    fn clear(&mut self) {
        self.key = 0;
        self.state = false;
        self.device_id = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static SwitchCommandRequest {
        static instance: SwitchCommandRequest = SwitchCommandRequest {
            key: 0,
            state: false,
            device_id: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for SwitchCommandRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("SwitchCommandRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for SwitchCommandRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SwitchCommandRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:ListEntitiesTextSensorResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ListEntitiesTextSensorResponse {
    // message fields
    // @@protoc_insertion_point(field:ListEntitiesTextSensorResponse.object_id)
    pub object_id: ::std::string::String,
    // @@protoc_insertion_point(field:ListEntitiesTextSensorResponse.key)
    pub key: u32,
    // @@protoc_insertion_point(field:ListEntitiesTextSensorResponse.name)
    pub name: ::std::string::String,
    // @@protoc_insertion_point(field:ListEntitiesTextSensorResponse.unique_id)
    pub unique_id: ::std::string::String,
    // @@protoc_insertion_point(field:ListEntitiesTextSensorResponse.icon)
    pub icon: ::std::string::String,
    // @@protoc_insertion_point(field:ListEntitiesTextSensorResponse.disabled_by_default)
    pub disabled_by_default: bool,
    // @@protoc_insertion_point(field:ListEntitiesTextSensorResponse.entity_category)
    pub entity_category: ::protobuf::EnumOrUnknown<EntityCategory>,
    // @@protoc_insertion_point(field:ListEntitiesTextSensorResponse.device_class)
    pub device_class: ::std::string::String,
    // @@protoc_insertion_point(field:ListEntitiesTextSensorResponse.device_id)
    pub device_id: u32,
    // special fields
    // @@protoc_insertion_point(special_field:ListEntitiesTextSensorResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ListEntitiesTextSensorResponse {
    fn default() -> &'a ListEntitiesTextSensorResponse {
        <ListEntitiesTextSensorResponse as ::protobuf::Message>::default_instance()
    }
}

impl ListEntitiesTextSensorResponse {
    pub fn new() -> ListEntitiesTextSensorResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(9);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "object_id",
            |m: &ListEntitiesTextSensorResponse| { &m.object_id },
            |m: &mut ListEntitiesTextSensorResponse| { &mut m.object_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "key",
            |m: &ListEntitiesTextSensorResponse| { &m.key },
            |m: &mut ListEntitiesTextSensorResponse| { &mut m.key },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "name",
            |m: &ListEntitiesTextSensorResponse| { &m.name },
            |m: &mut ListEntitiesTextSensorResponse| { &mut m.name },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "unique_id",
            |m: &ListEntitiesTextSensorResponse| { &m.unique_id },
            |m: &mut ListEntitiesTextSensorResponse| { &mut m.unique_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "icon",
            |m: &ListEntitiesTextSensorResponse| { &m.icon },
            |m: &mut ListEntitiesTextSensorResponse| { &mut m.icon },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "disabled_by_default",
            |m: &ListEntitiesTextSensorResponse| { &m.disabled_by_default },
            |m: &mut ListEntitiesTextSensorResponse| { &mut m.disabled_by_default },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "entity_category",
            |m: &ListEntitiesTextSensorResponse| { &m.entity_category },
            |m: &mut ListEntitiesTextSensorResponse| { &mut m.entity_category },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "device_class",
            |m: &ListEntitiesTextSensorResponse| { &m.device_class },
            |m: &mut ListEntitiesTextSensorResponse| { &mut m.device_class },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "device_id",
            |m: &ListEntitiesTextSensorResponse| { &m.device_id },
            |m: &mut ListEntitiesTextSensorResponse| { &mut m.device_id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ListEntitiesTextSensorResponse>(
            "ListEntitiesTextSensorResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ListEntitiesTextSensorResponse {
    const NAME: &'static str = "ListEntitiesTextSensorResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.object_id = is.read_string()?;
                },
                21 => {
                    self.key = is.read_fixed32()?;
                },
                26 => {
                    self.name = is.read_string()?;
                },
                34 => {
                    self.unique_id = is.read_string()?;
                },
                42 => {
                    self.icon = is.read_string()?;
                },
                48 => {
                    self.disabled_by_default = is.read_bool()?;
                },
                56 => {
                    self.entity_category = is.read_enum_or_unknown()?;
                },
                66 => {
                    self.device_class = is.read_string()?;
                },
                72 => {
                    self.device_id = is.read_uint32()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.object_id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.object_id);
        }
        if self.key != 0 {
            my_size += 1 + 4;
        }
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.name);
        }
        if !self.unique_id.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.unique_id);
        }
        if !self.icon.is_empty() {
            my_size += ::protobuf::rt::string_size(5, &self.icon);
        }
        if self.disabled_by_default != false {
            my_size += 1 + 1;
        }
        if self.entity_category != ::protobuf::EnumOrUnknown::new(EntityCategory::ENTITY_CATEGORY_NONE) {
            my_size += ::protobuf::rt::int32_size(7, self.entity_category.value());
        }
        if !self.device_class.is_empty() {
            my_size += ::protobuf::rt::string_size(8, &self.device_class);
        }
        if self.device_id != 0 {
            my_size += ::protobuf::rt::uint32_size(9, self.device_id);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.object_id.is_empty() {
            os.write_string(1, &self.object_id)?;
        }
        if self.key != 0 {
            os.write_fixed32(2, self.key)?;
        }
        if !self.name.is_empty() {
            os.write_string(3, &self.name)?;
        }
        if !self.unique_id.is_empty() {
            os.write_string(4, &self.unique_id)?;
        }
        if !self.icon.is_empty() {
            os.write_string(5, &self.icon)?;
        }
        if self.disabled_by_default != false {
            os.write_bool(6, self.disabled_by_default)?;
        }
        if self.entity_category != ::protobuf::EnumOrUnknown::new(EntityCategory::ENTITY_CATEGORY_NONE) {
            os.write_enum(7, ::protobuf::EnumOrUnknown::value(&self.entity_category))?;
        }
        if !self.device_class.is_empty() {
            os.write_string(8, &self.device_class)?;
        }
        if self.device_id != 0 {
            os.write_uint32(9, self.device_id)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ListEntitiesTextSensorResponse {
        ListEntitiesTextSensorResponse::new()
    }

    fn clear(&mut self) {
        self.object_id.clear();
        self.key = 0;
        self.name.clear();
        self.unique_id.clear();
        self.icon.clear();
        self.disabled_by_default = false;
        self.entity_category = ::protobuf::EnumOrUnknown::new(EntityCategory::ENTITY_CATEGORY_NONE);
        self.device_class.clear();
        self.device_id = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ListEntitiesTextSensorResponse {
        static instance: ListEntitiesTextSensorResponse = ListEntitiesTextSensorResponse {
            object_id: ::std::string::String::new(),
            key: 0,
            name: ::std::string::String::new(),
            unique_id: ::std::string::String::new(),
            icon: ::std::string::String::new(),
            disabled_by_default: false,
            entity_category: ::protobuf::EnumOrUnknown::from_i32(0),
            device_class: ::std::string::String::new(),
            device_id: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ListEntitiesTextSensorResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ListEntitiesTextSensorResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ListEntitiesTextSensorResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ListEntitiesTextSensorResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:TextSensorStateResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct TextSensorStateResponse {
    // message fields
    // @@protoc_insertion_point(field:TextSensorStateResponse.key)
    pub key: u32,
    // @@protoc_insertion_point(field:TextSensorStateResponse.state)
    pub state: ::std::string::String,
    // @@protoc_insertion_point(field:TextSensorStateResponse.missing_state)
    pub missing_state: bool,
    // @@protoc_insertion_point(field:TextSensorStateResponse.device_id)
    pub device_id: u32,
    // special fields
    // @@protoc_insertion_point(special_field:TextSensorStateResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a TextSensorStateResponse {
    fn default() -> &'a TextSensorStateResponse {
        <TextSensorStateResponse as ::protobuf::Message>::default_instance()
    }
}

impl TextSensorStateResponse {
    pub fn new() -> TextSensorStateResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "key",
            |m: &TextSensorStateResponse| { &m.key },
            |m: &mut TextSensorStateResponse| { &mut m.key },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "state",
            |m: &TextSensorStateResponse| { &m.state },
            |m: &mut TextSensorStateResponse| { &mut m.state },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "missing_state",
            |m: &TextSensorStateResponse| { &m.missing_state },
            |m: &mut TextSensorStateResponse| { &mut m.missing_state },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "device_id",
            |m: &TextSensorStateResponse| { &m.device_id },
            |m: &mut TextSensorStateResponse| { &mut m.device_id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<TextSensorStateResponse>(
            "TextSensorStateResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for TextSensorStateResponse {
    const NAME: &'static str = "TextSensorStateResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                13 => {
                    self.key = is.read_fixed32()?;
                },
                18 => {
                    self.state = is.read_string()?;
                },
                24 => {
                    self.missing_state = is.read_bool()?;
                },
                32 => {
                    self.device_id = is.read_uint32()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.key != 0 {
            my_size += 1 + 4;
        }
        if !self.state.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.state);
        }
        if self.missing_state != false {
            my_size += 1 + 1;
        }
        if self.device_id != 0 {
            my_size += ::protobuf::rt::uint32_size(4, self.device_id);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.key != 0 {
            os.write_fixed32(1, self.key)?;
        }
        if !self.state.is_empty() {
            os.write_string(2, &self.state)?;
        }
        if self.missing_state != false {
            os.write_bool(3, self.missing_state)?;
        }
        if self.device_id != 0 {
            os.write_uint32(4, self.device_id)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> TextSensorStateResponse {
        TextSensorStateResponse::new()
    }

    fn clear(&mut self) {
        self.key = 0;
        self.state.clear();
        self.missing_state = false;
        self.device_id = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static TextSensorStateResponse {
        static instance: TextSensorStateResponse = TextSensorStateResponse {
            key: 0,
            state: ::std::string::String::new(),
            missing_state: false,
            device_id: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for TextSensorStateResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("TextSensorStateResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for TextSensorStateResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TextSensorStateResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:SubscribeLogsRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct SubscribeLogsRequest {
    // message fields
    // @@protoc_insertion_point(field:SubscribeLogsRequest.level)
    pub level: ::protobuf::EnumOrUnknown<LogLevel>,
    // @@protoc_insertion_point(field:SubscribeLogsRequest.dump_config)
    pub dump_config: bool,
    // special fields
    // @@protoc_insertion_point(special_field:SubscribeLogsRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a SubscribeLogsRequest {
    fn default() -> &'a SubscribeLogsRequest {
        <SubscribeLogsRequest as ::protobuf::Message>::default_instance()
    }
}

impl SubscribeLogsRequest {
    pub fn new() -> SubscribeLogsRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "level",
            |m: &SubscribeLogsRequest| { &m.level },
            |m: &mut SubscribeLogsRequest| { &mut m.level },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "dump_config",
            |m: &SubscribeLogsRequest| { &m.dump_config },
            |m: &mut SubscribeLogsRequest| { &mut m.dump_config },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<SubscribeLogsRequest>(
            "SubscribeLogsRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for SubscribeLogsRequest {
    const NAME: &'static str = "SubscribeLogsRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.level = is.read_enum_or_unknown()?;
                },
                16 => {
                    self.dump_config = is.read_bool()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.level != ::protobuf::EnumOrUnknown::new(LogLevel::LOG_LEVEL_NONE) {
            my_size += ::protobuf::rt::int32_size(1, self.level.value());
        }
        if self.dump_config != false {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.level != ::protobuf::EnumOrUnknown::new(LogLevel::LOG_LEVEL_NONE) {
            os.write_enum(1, ::protobuf::EnumOrUnknown::value(&self.level))?;
        }
        if self.dump_config != false {
            os.write_bool(2, self.dump_config)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> SubscribeLogsRequest {
        SubscribeLogsRequest::new()
    }

    fn clear(&mut self) {
        self.level = ::protobuf::EnumOrUnknown::new(LogLevel::LOG_LEVEL_NONE);
        self.dump_config = false;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static SubscribeLogsRequest {
        static instance: SubscribeLogsRequest = SubscribeLogsRequest {
            level: ::protobuf::EnumOrUnknown::from_i32(0),
            dump_config: false,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for SubscribeLogsRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("SubscribeLogsRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for SubscribeLogsRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SubscribeLogsRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:SubscribeLogsResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct SubscribeLogsResponse {
    // message fields
    // @@protoc_insertion_point(field:SubscribeLogsResponse.level)
    pub level: ::protobuf::EnumOrUnknown<LogLevel>,
    // @@protoc_insertion_point(field:SubscribeLogsResponse.message)
    pub message: ::std::vec::Vec<u8>,
    // @@protoc_insertion_point(field:SubscribeLogsResponse.send_failed)
    pub send_failed: bool,
    // special fields
    // @@protoc_insertion_point(special_field:SubscribeLogsResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a SubscribeLogsResponse {
    fn default() -> &'a SubscribeLogsResponse {
        <SubscribeLogsResponse as ::protobuf::Message>::default_instance()
    }
}

impl SubscribeLogsResponse {
    pub fn new() -> SubscribeLogsResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "level",
            |m: &SubscribeLogsResponse| { &m.level },
            |m: &mut SubscribeLogsResponse| { &mut m.level },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "message",
            |m: &SubscribeLogsResponse| { &m.message },
            |m: &mut SubscribeLogsResponse| { &mut m.message },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "send_failed",
            |m: &SubscribeLogsResponse| { &m.send_failed },
            |m: &mut SubscribeLogsResponse| { &mut m.send_failed },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<SubscribeLogsResponse>(
            "SubscribeLogsResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for SubscribeLogsResponse {
    const NAME: &'static str = "SubscribeLogsResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.level = is.read_enum_or_unknown()?;
                },
                26 => {
                    self.message = is.read_bytes()?;
                },
                32 => {
                    self.send_failed = is.read_bool()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.level != ::protobuf::EnumOrUnknown::new(LogLevel::LOG_LEVEL_NONE) {
            my_size += ::protobuf::rt::int32_size(1, self.level.value());
        }
        if !self.message.is_empty() {
            my_size += ::protobuf::rt::bytes_size(3, &self.message);
        }
        if self.send_failed != false {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.level != ::protobuf::EnumOrUnknown::new(LogLevel::LOG_LEVEL_NONE) {
            os.write_enum(1, ::protobuf::EnumOrUnknown::value(&self.level))?;
        }
        if !self.message.is_empty() {
            os.write_bytes(3, &self.message)?;
        }
        if self.send_failed != false {
            os.write_bool(4, self.send_failed)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> SubscribeLogsResponse {
        SubscribeLogsResponse::new()
    }

    fn clear(&mut self) {
        self.level = ::protobuf::EnumOrUnknown::new(LogLevel::LOG_LEVEL_NONE);
        self.message.clear();
        self.send_failed = false;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static SubscribeLogsResponse {
        static instance: SubscribeLogsResponse = SubscribeLogsResponse {
            level: ::protobuf::EnumOrUnknown::from_i32(0),
            message: ::std::vec::Vec::new(),
            send_failed: false,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for SubscribeLogsResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("SubscribeLogsResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for SubscribeLogsResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SubscribeLogsResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:NoiseEncryptionSetKeyRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct NoiseEncryptionSetKeyRequest {
    // message fields
    // @@protoc_insertion_point(field:NoiseEncryptionSetKeyRequest.key)
    pub key: ::std::vec::Vec<u8>,
    // special fields
    // @@protoc_insertion_point(special_field:NoiseEncryptionSetKeyRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a NoiseEncryptionSetKeyRequest {
    fn default() -> &'a NoiseEncryptionSetKeyRequest {
        <NoiseEncryptionSetKeyRequest as ::protobuf::Message>::default_instance()
    }
}

impl NoiseEncryptionSetKeyRequest {
    pub fn new() -> NoiseEncryptionSetKeyRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "key",
            |m: &NoiseEncryptionSetKeyRequest| { &m.key },
            |m: &mut NoiseEncryptionSetKeyRequest| { &mut m.key },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<NoiseEncryptionSetKeyRequest>(
            "NoiseEncryptionSetKeyRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for NoiseEncryptionSetKeyRequest {
    const NAME: &'static str = "NoiseEncryptionSetKeyRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.key = is.read_bytes()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.key.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.key);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.key.is_empty() {
            os.write_bytes(1, &self.key)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> NoiseEncryptionSetKeyRequest {
        NoiseEncryptionSetKeyRequest::new()
    }

    fn clear(&mut self) {
        self.key.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static NoiseEncryptionSetKeyRequest {
        static instance: NoiseEncryptionSetKeyRequest = NoiseEncryptionSetKeyRequest {
            key: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for NoiseEncryptionSetKeyRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("NoiseEncryptionSetKeyRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for NoiseEncryptionSetKeyRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for NoiseEncryptionSetKeyRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:NoiseEncryptionSetKeyResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct NoiseEncryptionSetKeyResponse {
    // message fields
    // @@protoc_insertion_point(field:NoiseEncryptionSetKeyResponse.success)
    pub success: bool,
    // special fields
    // @@protoc_insertion_point(special_field:NoiseEncryptionSetKeyResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a NoiseEncryptionSetKeyResponse {
    fn default() -> &'a NoiseEncryptionSetKeyResponse {
        <NoiseEncryptionSetKeyResponse as ::protobuf::Message>::default_instance()
    }
}

impl NoiseEncryptionSetKeyResponse {
    pub fn new() -> NoiseEncryptionSetKeyResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "success",
            |m: &NoiseEncryptionSetKeyResponse| { &m.success },
            |m: &mut NoiseEncryptionSetKeyResponse| { &mut m.success },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<NoiseEncryptionSetKeyResponse>(
            "NoiseEncryptionSetKeyResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for NoiseEncryptionSetKeyResponse {
    const NAME: &'static str = "NoiseEncryptionSetKeyResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.success = is.read_bool()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.success != false {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.success != false {
            os.write_bool(1, self.success)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> NoiseEncryptionSetKeyResponse {
        NoiseEncryptionSetKeyResponse::new()
    }

    fn clear(&mut self) {
        self.success = false;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static NoiseEncryptionSetKeyResponse {
        static instance: NoiseEncryptionSetKeyResponse = NoiseEncryptionSetKeyResponse {
            success: false,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for NoiseEncryptionSetKeyResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("NoiseEncryptionSetKeyResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for NoiseEncryptionSetKeyResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for NoiseEncryptionSetKeyResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:SubscribeHomeassistantServicesRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct SubscribeHomeassistantServicesRequest {
    // special fields
    // @@protoc_insertion_point(special_field:SubscribeHomeassistantServicesRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a SubscribeHomeassistantServicesRequest {
    fn default() -> &'a SubscribeHomeassistantServicesRequest {
        <SubscribeHomeassistantServicesRequest as ::protobuf::Message>::default_instance()
    }
}

impl SubscribeHomeassistantServicesRequest {
    pub fn new() -> SubscribeHomeassistantServicesRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(0);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<SubscribeHomeassistantServicesRequest>(
            "SubscribeHomeassistantServicesRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for SubscribeHomeassistantServicesRequest {
    const NAME: &'static str = "SubscribeHomeassistantServicesRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> SubscribeHomeassistantServicesRequest {
        SubscribeHomeassistantServicesRequest::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static SubscribeHomeassistantServicesRequest {
        static instance: SubscribeHomeassistantServicesRequest = SubscribeHomeassistantServicesRequest {
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for SubscribeHomeassistantServicesRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("SubscribeHomeassistantServicesRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for SubscribeHomeassistantServicesRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SubscribeHomeassistantServicesRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:HomeassistantServiceMap)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct HomeassistantServiceMap {
    // message fields
    // @@protoc_insertion_point(field:HomeassistantServiceMap.key)
    pub key: ::std::string::String,
    // @@protoc_insertion_point(field:HomeassistantServiceMap.value)
    pub value: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:HomeassistantServiceMap.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a HomeassistantServiceMap {
    fn default() -> &'a HomeassistantServiceMap {
        <HomeassistantServiceMap as ::protobuf::Message>::default_instance()
    }
}

impl HomeassistantServiceMap {
    pub fn new() -> HomeassistantServiceMap {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "key",
            |m: &HomeassistantServiceMap| { &m.key },
            |m: &mut HomeassistantServiceMap| { &mut m.key },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "value",
            |m: &HomeassistantServiceMap| { &m.value },
            |m: &mut HomeassistantServiceMap| { &mut m.value },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<HomeassistantServiceMap>(
            "HomeassistantServiceMap",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for HomeassistantServiceMap {
    const NAME: &'static str = "HomeassistantServiceMap";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.key = is.read_string()?;
                },
                18 => {
                    self.value = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.key.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.key);
        }
        if !self.value.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.value);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.key.is_empty() {
            os.write_string(1, &self.key)?;
        }
        if !self.value.is_empty() {
            os.write_string(2, &self.value)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> HomeassistantServiceMap {
        HomeassistantServiceMap::new()
    }

    fn clear(&mut self) {
        self.key.clear();
        self.value.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static HomeassistantServiceMap {
        static instance: HomeassistantServiceMap = HomeassistantServiceMap {
            key: ::std::string::String::new(),
            value: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for HomeassistantServiceMap {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("HomeassistantServiceMap").unwrap()).clone()
    }
}

impl ::std::fmt::Display for HomeassistantServiceMap {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for HomeassistantServiceMap {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:HomeassistantServiceResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct HomeassistantServiceResponse {
    // message fields
    // @@protoc_insertion_point(field:HomeassistantServiceResponse.service)
    pub service: ::std::string::String,
    // @@protoc_insertion_point(field:HomeassistantServiceResponse.data)
    pub data: ::std::vec::Vec<HomeassistantServiceMap>,
    // @@protoc_insertion_point(field:HomeassistantServiceResponse.data_template)
    pub data_template: ::std::vec::Vec<HomeassistantServiceMap>,
    // @@protoc_insertion_point(field:HomeassistantServiceResponse.variables)
    pub variables: ::std::vec::Vec<HomeassistantServiceMap>,
    // @@protoc_insertion_point(field:HomeassistantServiceResponse.is_event)
    pub is_event: bool,
    // special fields
    // @@protoc_insertion_point(special_field:HomeassistantServiceResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a HomeassistantServiceResponse {
    fn default() -> &'a HomeassistantServiceResponse {
        <HomeassistantServiceResponse as ::protobuf::Message>::default_instance()
    }
}

impl HomeassistantServiceResponse {
    pub fn new() -> HomeassistantServiceResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(5);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "service",
            |m: &HomeassistantServiceResponse| { &m.service },
            |m: &mut HomeassistantServiceResponse| { &mut m.service },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "data",
            |m: &HomeassistantServiceResponse| { &m.data },
            |m: &mut HomeassistantServiceResponse| { &mut m.data },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "data_template",
            |m: &HomeassistantServiceResponse| { &m.data_template },
            |m: &mut HomeassistantServiceResponse| { &mut m.data_template },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "variables",
            |m: &HomeassistantServiceResponse| { &m.variables },
            |m: &mut HomeassistantServiceResponse| { &mut m.variables },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "is_event",
            |m: &HomeassistantServiceResponse| { &m.is_event },
            |m: &mut HomeassistantServiceResponse| { &mut m.is_event },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<HomeassistantServiceResponse>(
            "HomeassistantServiceResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for HomeassistantServiceResponse {
    const NAME: &'static str = "HomeassistantServiceResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.service = is.read_string()?;
                },
                18 => {
                    self.data.push(is.read_message()?);
                },
                26 => {
                    self.data_template.push(is.read_message()?);
                },
                34 => {
                    self.variables.push(is.read_message()?);
                },
                40 => {
                    self.is_event = is.read_bool()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.service.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.service);
        }
        for value in &self.data {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.data_template {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.variables {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if self.is_event != false {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.service.is_empty() {
            os.write_string(1, &self.service)?;
        }
        for v in &self.data {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        for v in &self.data_template {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        };
        for v in &self.variables {
            ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        };
        if self.is_event != false {
            os.write_bool(5, self.is_event)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> HomeassistantServiceResponse {
        HomeassistantServiceResponse::new()
    }

    fn clear(&mut self) {
        self.service.clear();
        self.data.clear();
        self.data_template.clear();
        self.variables.clear();
        self.is_event = false;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static HomeassistantServiceResponse {
        static instance: HomeassistantServiceResponse = HomeassistantServiceResponse {
            service: ::std::string::String::new(),
            data: ::std::vec::Vec::new(),
            data_template: ::std::vec::Vec::new(),
            variables: ::std::vec::Vec::new(),
            is_event: false,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for HomeassistantServiceResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("HomeassistantServiceResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for HomeassistantServiceResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for HomeassistantServiceResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:SubscribeHomeAssistantStatesRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct SubscribeHomeAssistantStatesRequest {
    // special fields
    // @@protoc_insertion_point(special_field:SubscribeHomeAssistantStatesRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a SubscribeHomeAssistantStatesRequest {
    fn default() -> &'a SubscribeHomeAssistantStatesRequest {
        <SubscribeHomeAssistantStatesRequest as ::protobuf::Message>::default_instance()
    }
}

impl SubscribeHomeAssistantStatesRequest {
    pub fn new() -> SubscribeHomeAssistantStatesRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(0);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<SubscribeHomeAssistantStatesRequest>(
            "SubscribeHomeAssistantStatesRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for SubscribeHomeAssistantStatesRequest {
    const NAME: &'static str = "SubscribeHomeAssistantStatesRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> SubscribeHomeAssistantStatesRequest {
        SubscribeHomeAssistantStatesRequest::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static SubscribeHomeAssistantStatesRequest {
        static instance: SubscribeHomeAssistantStatesRequest = SubscribeHomeAssistantStatesRequest {
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for SubscribeHomeAssistantStatesRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("SubscribeHomeAssistantStatesRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for SubscribeHomeAssistantStatesRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SubscribeHomeAssistantStatesRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:SubscribeHomeAssistantStateResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct SubscribeHomeAssistantStateResponse {
    // message fields
    // @@protoc_insertion_point(field:SubscribeHomeAssistantStateResponse.entity_id)
    pub entity_id: ::std::string::String,
    // @@protoc_insertion_point(field:SubscribeHomeAssistantStateResponse.attribute)
    pub attribute: ::std::string::String,
    // @@protoc_insertion_point(field:SubscribeHomeAssistantStateResponse.once)
    pub once: bool,
    // special fields
    // @@protoc_insertion_point(special_field:SubscribeHomeAssistantStateResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a SubscribeHomeAssistantStateResponse {
    fn default() -> &'a SubscribeHomeAssistantStateResponse {
        <SubscribeHomeAssistantStateResponse as ::protobuf::Message>::default_instance()
    }
}

impl SubscribeHomeAssistantStateResponse {
    pub fn new() -> SubscribeHomeAssistantStateResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "entity_id",
            |m: &SubscribeHomeAssistantStateResponse| { &m.entity_id },
            |m: &mut SubscribeHomeAssistantStateResponse| { &mut m.entity_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "attribute",
            |m: &SubscribeHomeAssistantStateResponse| { &m.attribute },
            |m: &mut SubscribeHomeAssistantStateResponse| { &mut m.attribute },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "once",
            |m: &SubscribeHomeAssistantStateResponse| { &m.once },
            |m: &mut SubscribeHomeAssistantStateResponse| { &mut m.once },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<SubscribeHomeAssistantStateResponse>(
            "SubscribeHomeAssistantStateResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for SubscribeHomeAssistantStateResponse {
    const NAME: &'static str = "SubscribeHomeAssistantStateResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.entity_id = is.read_string()?;
                },
                18 => {
                    self.attribute = is.read_string()?;
                },
                24 => {
                    self.once = is.read_bool()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.entity_id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.entity_id);
        }
        if !self.attribute.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.attribute);
        }
        if self.once != false {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.entity_id.is_empty() {
            os.write_string(1, &self.entity_id)?;
        }
        if !self.attribute.is_empty() {
            os.write_string(2, &self.attribute)?;
        }
        if self.once != false {
            os.write_bool(3, self.once)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> SubscribeHomeAssistantStateResponse {
        SubscribeHomeAssistantStateResponse::new()
    }

    fn clear(&mut self) {
        self.entity_id.clear();
        self.attribute.clear();
        self.once = false;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static SubscribeHomeAssistantStateResponse {
        static instance: SubscribeHomeAssistantStateResponse = SubscribeHomeAssistantStateResponse {
            entity_id: ::std::string::String::new(),
            attribute: ::std::string::String::new(),
            once: false,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for SubscribeHomeAssistantStateResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("SubscribeHomeAssistantStateResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for SubscribeHomeAssistantStateResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SubscribeHomeAssistantStateResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:HomeAssistantStateResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct HomeAssistantStateResponse {
    // message fields
    // @@protoc_insertion_point(field:HomeAssistantStateResponse.entity_id)
    pub entity_id: ::std::string::String,
    // @@protoc_insertion_point(field:HomeAssistantStateResponse.state)
    pub state: ::std::string::String,
    // @@protoc_insertion_point(field:HomeAssistantStateResponse.attribute)
    pub attribute: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:HomeAssistantStateResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a HomeAssistantStateResponse {
    fn default() -> &'a HomeAssistantStateResponse {
        <HomeAssistantStateResponse as ::protobuf::Message>::default_instance()
    }
}

impl HomeAssistantStateResponse {
    pub fn new() -> HomeAssistantStateResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "entity_id",
            |m: &HomeAssistantStateResponse| { &m.entity_id },
            |m: &mut HomeAssistantStateResponse| { &mut m.entity_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "state",
            |m: &HomeAssistantStateResponse| { &m.state },
            |m: &mut HomeAssistantStateResponse| { &mut m.state },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "attribute",
            |m: &HomeAssistantStateResponse| { &m.attribute },
            |m: &mut HomeAssistantStateResponse| { &mut m.attribute },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<HomeAssistantStateResponse>(
            "HomeAssistantStateResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for HomeAssistantStateResponse {
    const NAME: &'static str = "HomeAssistantStateResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.entity_id = is.read_string()?;
                },
                18 => {
                    self.state = is.read_string()?;
                },
                26 => {
                    self.attribute = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.entity_id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.entity_id);
        }
        if !self.state.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.state);
        }
        if !self.attribute.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.attribute);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.entity_id.is_empty() {
            os.write_string(1, &self.entity_id)?;
        }
        if !self.state.is_empty() {
            os.write_string(2, &self.state)?;
        }
        if !self.attribute.is_empty() {
            os.write_string(3, &self.attribute)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> HomeAssistantStateResponse {
        HomeAssistantStateResponse::new()
    }

    fn clear(&mut self) {
        self.entity_id.clear();
        self.state.clear();
        self.attribute.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static HomeAssistantStateResponse {
        static instance: HomeAssistantStateResponse = HomeAssistantStateResponse {
            entity_id: ::std::string::String::new(),
            state: ::std::string::String::new(),
            attribute: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for HomeAssistantStateResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("HomeAssistantStateResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for HomeAssistantStateResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for HomeAssistantStateResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:GetTimeRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct GetTimeRequest {
    // special fields
    // @@protoc_insertion_point(special_field:GetTimeRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a GetTimeRequest {
    fn default() -> &'a GetTimeRequest {
        <GetTimeRequest as ::protobuf::Message>::default_instance()
    }
}

impl GetTimeRequest {
    pub fn new() -> GetTimeRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(0);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<GetTimeRequest>(
            "GetTimeRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for GetTimeRequest {
    const NAME: &'static str = "GetTimeRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> GetTimeRequest {
        GetTimeRequest::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static GetTimeRequest {
        static instance: GetTimeRequest = GetTimeRequest {
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for GetTimeRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("GetTimeRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for GetTimeRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetTimeRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:GetTimeResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct GetTimeResponse {
    // message fields
    // @@protoc_insertion_point(field:GetTimeResponse.epoch_seconds)
    pub epoch_seconds: u32,
    // special fields
    // @@protoc_insertion_point(special_field:GetTimeResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a GetTimeResponse {
    fn default() -> &'a GetTimeResponse {
        <GetTimeResponse as ::protobuf::Message>::default_instance()
    }
}

impl GetTimeResponse {
    pub fn new() -> GetTimeResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "epoch_seconds",
            |m: &GetTimeResponse| { &m.epoch_seconds },
            |m: &mut GetTimeResponse| { &mut m.epoch_seconds },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<GetTimeResponse>(
            "GetTimeResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for GetTimeResponse {
    const NAME: &'static str = "GetTimeResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                13 => {
                    self.epoch_seconds = is.read_fixed32()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.epoch_seconds != 0 {
            my_size += 1 + 4;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.epoch_seconds != 0 {
            os.write_fixed32(1, self.epoch_seconds)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> GetTimeResponse {
        GetTimeResponse::new()
    }

    fn clear(&mut self) {
        self.epoch_seconds = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static GetTimeResponse {
        static instance: GetTimeResponse = GetTimeResponse {
            epoch_seconds: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for GetTimeResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("GetTimeResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for GetTimeResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for GetTimeResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:ListEntitiesServicesArgument)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ListEntitiesServicesArgument {
    // message fields
    // @@protoc_insertion_point(field:ListEntitiesServicesArgument.name)
    pub name: ::std::string::String,
    // @@protoc_insertion_point(field:ListEntitiesServicesArgument.type)
    pub type_: ::protobuf::EnumOrUnknown<ServiceArgType>,
    // special fields
    // @@protoc_insertion_point(special_field:ListEntitiesServicesArgument.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ListEntitiesServicesArgument {
    fn default() -> &'a ListEntitiesServicesArgument {
        <ListEntitiesServicesArgument as ::protobuf::Message>::default_instance()
    }
}

impl ListEntitiesServicesArgument {
    pub fn new() -> ListEntitiesServicesArgument {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "name",
            |m: &ListEntitiesServicesArgument| { &m.name },
            |m: &mut ListEntitiesServicesArgument| { &mut m.name },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "type",
            |m: &ListEntitiesServicesArgument| { &m.type_ },
            |m: &mut ListEntitiesServicesArgument| { &mut m.type_ },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ListEntitiesServicesArgument>(
            "ListEntitiesServicesArgument",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ListEntitiesServicesArgument {
    const NAME: &'static str = "ListEntitiesServicesArgument";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.name = is.read_string()?;
                },
                16 => {
                    self.type_ = is.read_enum_or_unknown()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.name);
        }
        if self.type_ != ::protobuf::EnumOrUnknown::new(ServiceArgType::SERVICE_ARG_TYPE_BOOL) {
            my_size += ::protobuf::rt::int32_size(2, self.type_.value());
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.name.is_empty() {
            os.write_string(1, &self.name)?;
        }
        if self.type_ != ::protobuf::EnumOrUnknown::new(ServiceArgType::SERVICE_ARG_TYPE_BOOL) {
            os.write_enum(2, ::protobuf::EnumOrUnknown::value(&self.type_))?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ListEntitiesServicesArgument {
        ListEntitiesServicesArgument::new()
    }

    fn clear(&mut self) {
        self.name.clear();
        self.type_ = ::protobuf::EnumOrUnknown::new(ServiceArgType::SERVICE_ARG_TYPE_BOOL);
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ListEntitiesServicesArgument {
        static instance: ListEntitiesServicesArgument = ListEntitiesServicesArgument {
            name: ::std::string::String::new(),
            type_: ::protobuf::EnumOrUnknown::from_i32(0),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ListEntitiesServicesArgument {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ListEntitiesServicesArgument").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ListEntitiesServicesArgument {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ListEntitiesServicesArgument {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:ListEntitiesServicesResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ListEntitiesServicesResponse {
    // message fields
    // @@protoc_insertion_point(field:ListEntitiesServicesResponse.name)
    pub name: ::std::string::String,
    // @@protoc_insertion_point(field:ListEntitiesServicesResponse.key)
    pub key: u32,
    // @@protoc_insertion_point(field:ListEntitiesServicesResponse.args)
    pub args: ::std::vec::Vec<ListEntitiesServicesArgument>,
    // special fields
    // @@protoc_insertion_point(special_field:ListEntitiesServicesResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ListEntitiesServicesResponse {
    fn default() -> &'a ListEntitiesServicesResponse {
        <ListEntitiesServicesResponse as ::protobuf::Message>::default_instance()
    }
}

impl ListEntitiesServicesResponse {
    pub fn new() -> ListEntitiesServicesResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "name",
            |m: &ListEntitiesServicesResponse| { &m.name },
            |m: &mut ListEntitiesServicesResponse| { &mut m.name },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "key",
            |m: &ListEntitiesServicesResponse| { &m.key },
            |m: &mut ListEntitiesServicesResponse| { &mut m.key },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "args",
            |m: &ListEntitiesServicesResponse| { &m.args },
            |m: &mut ListEntitiesServicesResponse| { &mut m.args },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ListEntitiesServicesResponse>(
            "ListEntitiesServicesResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ListEntitiesServicesResponse {
    const NAME: &'static str = "ListEntitiesServicesResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.name = is.read_string()?;
                },
                21 => {
                    self.key = is.read_fixed32()?;
                },
                26 => {
                    self.args.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.name);
        }
        if self.key != 0 {
            my_size += 1 + 4;
        }
        for value in &self.args {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.name.is_empty() {
            os.write_string(1, &self.name)?;
        }
        if self.key != 0 {
            os.write_fixed32(2, self.key)?;
        }
        for v in &self.args {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ListEntitiesServicesResponse {
        ListEntitiesServicesResponse::new()
    }

    fn clear(&mut self) {
        self.name.clear();
        self.key = 0;
        self.args.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ListEntitiesServicesResponse {
        static instance: ListEntitiesServicesResponse = ListEntitiesServicesResponse {
            name: ::std::string::String::new(),
            key: 0,
            args: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ListEntitiesServicesResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ListEntitiesServicesResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ListEntitiesServicesResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ListEntitiesServicesResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:ExecuteServiceArgument)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ExecuteServiceArgument {
    // message fields
    // @@protoc_insertion_point(field:ExecuteServiceArgument.bool_)
    pub bool_: bool,
    // @@protoc_insertion_point(field:ExecuteServiceArgument.legacy_int)
    pub legacy_int: i32,
    // @@protoc_insertion_point(field:ExecuteServiceArgument.float_)
    pub float_: f32,
    // @@protoc_insertion_point(field:ExecuteServiceArgument.string_)
    pub string_: ::std::string::String,
    // @@protoc_insertion_point(field:ExecuteServiceArgument.int_)
    pub int_: i32,
    // @@protoc_insertion_point(field:ExecuteServiceArgument.bool_array)
    pub bool_array: ::std::vec::Vec<bool>,
    // @@protoc_insertion_point(field:ExecuteServiceArgument.int_array)
    pub int_array: ::std::vec::Vec<i32>,
    // @@protoc_insertion_point(field:ExecuteServiceArgument.float_array)
    pub float_array: ::std::vec::Vec<f32>,
    // @@protoc_insertion_point(field:ExecuteServiceArgument.string_array)
    pub string_array: ::std::vec::Vec<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:ExecuteServiceArgument.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ExecuteServiceArgument {
    fn default() -> &'a ExecuteServiceArgument {
        <ExecuteServiceArgument as ::protobuf::Message>::default_instance()
    }
}

impl ExecuteServiceArgument {
    pub fn new() -> ExecuteServiceArgument {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(9);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "bool_",
            |m: &ExecuteServiceArgument| { &m.bool_ },
            |m: &mut ExecuteServiceArgument| { &mut m.bool_ },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "legacy_int",
            |m: &ExecuteServiceArgument| { &m.legacy_int },
            |m: &mut ExecuteServiceArgument| { &mut m.legacy_int },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "float_",
            |m: &ExecuteServiceArgument| { &m.float_ },
            |m: &mut ExecuteServiceArgument| { &mut m.float_ },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "string_",
            |m: &ExecuteServiceArgument| { &m.string_ },
            |m: &mut ExecuteServiceArgument| { &mut m.string_ },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "int_",
            |m: &ExecuteServiceArgument| { &m.int_ },
            |m: &mut ExecuteServiceArgument| { &mut m.int_ },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "bool_array",
            |m: &ExecuteServiceArgument| { &m.bool_array },
            |m: &mut ExecuteServiceArgument| { &mut m.bool_array },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "int_array",
            |m: &ExecuteServiceArgument| { &m.int_array },
            |m: &mut ExecuteServiceArgument| { &mut m.int_array },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "float_array",
            |m: &ExecuteServiceArgument| { &m.float_array },
            |m: &mut ExecuteServiceArgument| { &mut m.float_array },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "string_array",
            |m: &ExecuteServiceArgument| { &m.string_array },
            |m: &mut ExecuteServiceArgument| { &mut m.string_array },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ExecuteServiceArgument>(
            "ExecuteServiceArgument",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ExecuteServiceArgument {
    const NAME: &'static str = "ExecuteServiceArgument";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.bool_ = is.read_bool()?;
                },
                16 => {
                    self.legacy_int = is.read_int32()?;
                },
                29 => {
                    self.float_ = is.read_float()?;
                },
                34 => {
                    self.string_ = is.read_string()?;
                },
                40 => {
                    self.int_ = is.read_sint32()?;
                },
                50 => {
                    is.read_repeated_packed_bool_into(&mut self.bool_array)?;
                },
                48 => {
                    self.bool_array.push(is.read_bool()?);
                },
                58 => {
                    is.read_repeated_packed_sint32_into(&mut self.int_array)?;
                },
                56 => {
                    self.int_array.push(is.read_sint32()?);
                },
                66 => {
                    is.read_repeated_packed_float_into(&mut self.float_array)?;
                },
                69 => {
                    self.float_array.push(is.read_float()?);
                },
                74 => {
                    self.string_array.push(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.bool_ != false {
            my_size += 1 + 1;
        }
        if self.legacy_int != 0 {
            my_size += ::protobuf::rt::int32_size(2, self.legacy_int);
        }
        if self.float_ != 0. {
            my_size += 1 + 4;
        }
        if !self.string_.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.string_);
        }
        if self.int_ != 0 {
            my_size += ::protobuf::rt::sint32_size(5, self.int_);
        }
        my_size += 2 * self.bool_array.len() as u64;
        for value in &self.int_array {
            my_size += ::protobuf::rt::sint32_size(7, *value);
        };
        my_size += 5 * self.float_array.len() as u64;
        for value in &self.string_array {
            my_size += ::protobuf::rt::string_size(9, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.bool_ != false {
            os.write_bool(1, self.bool_)?;
        }
        if self.legacy_int != 0 {
            os.write_int32(2, self.legacy_int)?;
        }
        if self.float_ != 0. {
            os.write_float(3, self.float_)?;
        }
        if !self.string_.is_empty() {
            os.write_string(4, &self.string_)?;
        }
        if self.int_ != 0 {
            os.write_sint32(5, self.int_)?;
        }
        for v in &self.bool_array {
            os.write_bool(6, *v)?;
        };
        for v in &self.int_array {
            os.write_sint32(7, *v)?;
        };
        for v in &self.float_array {
            os.write_float(8, *v)?;
        };
        for v in &self.string_array {
            os.write_string(9, &v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ExecuteServiceArgument {
        ExecuteServiceArgument::new()
    }

    fn clear(&mut self) {
        self.bool_ = false;
        self.legacy_int = 0;
        self.float_ = 0.;
        self.string_.clear();
        self.int_ = 0;
        self.bool_array.clear();
        self.int_array.clear();
        self.float_array.clear();
        self.string_array.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ExecuteServiceArgument {
        static instance: ExecuteServiceArgument = ExecuteServiceArgument {
            bool_: false,
            legacy_int: 0,
            float_: 0.,
            string_: ::std::string::String::new(),
            int_: 0,
            bool_array: ::std::vec::Vec::new(),
            int_array: ::std::vec::Vec::new(),
            float_array: ::std::vec::Vec::new(),
            string_array: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ExecuteServiceArgument {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ExecuteServiceArgument").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ExecuteServiceArgument {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ExecuteServiceArgument {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:ExecuteServiceRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ExecuteServiceRequest {
    // message fields
    // @@protoc_insertion_point(field:ExecuteServiceRequest.key)
    pub key: u32,
    // @@protoc_insertion_point(field:ExecuteServiceRequest.args)
    pub args: ::std::vec::Vec<ExecuteServiceArgument>,
    // special fields
    // @@protoc_insertion_point(special_field:ExecuteServiceRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ExecuteServiceRequest {
    fn default() -> &'a ExecuteServiceRequest {
        <ExecuteServiceRequest as ::protobuf::Message>::default_instance()
    }
}

impl ExecuteServiceRequest {
    pub fn new() -> ExecuteServiceRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "key",
            |m: &ExecuteServiceRequest| { &m.key },
            |m: &mut ExecuteServiceRequest| { &mut m.key },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "args",
            |m: &ExecuteServiceRequest| { &m.args },
            |m: &mut ExecuteServiceRequest| { &mut m.args },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ExecuteServiceRequest>(
            "ExecuteServiceRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ExecuteServiceRequest {
    const NAME: &'static str = "ExecuteServiceRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                13 => {
                    self.key = is.read_fixed32()?;
                },
                18 => {
                    self.args.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.key != 0 {
            my_size += 1 + 4;
        }
        for value in &self.args {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.key != 0 {
            os.write_fixed32(1, self.key)?;
        }
        for v in &self.args {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ExecuteServiceRequest {
        ExecuteServiceRequest::new()
    }

    fn clear(&mut self) {
        self.key = 0;
        self.args.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ExecuteServiceRequest {
        static instance: ExecuteServiceRequest = ExecuteServiceRequest {
            key: 0,
            args: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ExecuteServiceRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ExecuteServiceRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ExecuteServiceRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ExecuteServiceRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:ListEntitiesCameraResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ListEntitiesCameraResponse {
    // message fields
    // @@protoc_insertion_point(field:ListEntitiesCameraResponse.object_id)
    pub object_id: ::std::string::String,
    // @@protoc_insertion_point(field:ListEntitiesCameraResponse.key)
    pub key: u32,
    // @@protoc_insertion_point(field:ListEntitiesCameraResponse.name)
    pub name: ::std::string::String,
    // @@protoc_insertion_point(field:ListEntitiesCameraResponse.unique_id)
    pub unique_id: ::std::string::String,
    // @@protoc_insertion_point(field:ListEntitiesCameraResponse.disabled_by_default)
    pub disabled_by_default: bool,
    // @@protoc_insertion_point(field:ListEntitiesCameraResponse.icon)
    pub icon: ::std::string::String,
    // @@protoc_insertion_point(field:ListEntitiesCameraResponse.entity_category)
    pub entity_category: ::protobuf::EnumOrUnknown<EntityCategory>,
    // @@protoc_insertion_point(field:ListEntitiesCameraResponse.device_id)
    pub device_id: u32,
    // special fields
    // @@protoc_insertion_point(special_field:ListEntitiesCameraResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ListEntitiesCameraResponse {
    fn default() -> &'a ListEntitiesCameraResponse {
        <ListEntitiesCameraResponse as ::protobuf::Message>::default_instance()
    }
}

impl ListEntitiesCameraResponse {
    pub fn new() -> ListEntitiesCameraResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(8);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "object_id",
            |m: &ListEntitiesCameraResponse| { &m.object_id },
            |m: &mut ListEntitiesCameraResponse| { &mut m.object_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "key",
            |m: &ListEntitiesCameraResponse| { &m.key },
            |m: &mut ListEntitiesCameraResponse| { &mut m.key },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "name",
            |m: &ListEntitiesCameraResponse| { &m.name },
            |m: &mut ListEntitiesCameraResponse| { &mut m.name },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "unique_id",
            |m: &ListEntitiesCameraResponse| { &m.unique_id },
            |m: &mut ListEntitiesCameraResponse| { &mut m.unique_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "disabled_by_default",
            |m: &ListEntitiesCameraResponse| { &m.disabled_by_default },
            |m: &mut ListEntitiesCameraResponse| { &mut m.disabled_by_default },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "icon",
            |m: &ListEntitiesCameraResponse| { &m.icon },
            |m: &mut ListEntitiesCameraResponse| { &mut m.icon },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "entity_category",
            |m: &ListEntitiesCameraResponse| { &m.entity_category },
            |m: &mut ListEntitiesCameraResponse| { &mut m.entity_category },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "device_id",
            |m: &ListEntitiesCameraResponse| { &m.device_id },
            |m: &mut ListEntitiesCameraResponse| { &mut m.device_id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ListEntitiesCameraResponse>(
            "ListEntitiesCameraResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ListEntitiesCameraResponse {
    const NAME: &'static str = "ListEntitiesCameraResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.object_id = is.read_string()?;
                },
                21 => {
                    self.key = is.read_fixed32()?;
                },
                26 => {
                    self.name = is.read_string()?;
                },
                34 => {
                    self.unique_id = is.read_string()?;
                },
                40 => {
                    self.disabled_by_default = is.read_bool()?;
                },
                50 => {
                    self.icon = is.read_string()?;
                },
                56 => {
                    self.entity_category = is.read_enum_or_unknown()?;
                },
                64 => {
                    self.device_id = is.read_uint32()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.object_id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.object_id);
        }
        if self.key != 0 {
            my_size += 1 + 4;
        }
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.name);
        }
        if !self.unique_id.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.unique_id);
        }
        if self.disabled_by_default != false {
            my_size += 1 + 1;
        }
        if !self.icon.is_empty() {
            my_size += ::protobuf::rt::string_size(6, &self.icon);
        }
        if self.entity_category != ::protobuf::EnumOrUnknown::new(EntityCategory::ENTITY_CATEGORY_NONE) {
            my_size += ::protobuf::rt::int32_size(7, self.entity_category.value());
        }
        if self.device_id != 0 {
            my_size += ::protobuf::rt::uint32_size(8, self.device_id);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.object_id.is_empty() {
            os.write_string(1, &self.object_id)?;
        }
        if self.key != 0 {
            os.write_fixed32(2, self.key)?;
        }
        if !self.name.is_empty() {
            os.write_string(3, &self.name)?;
        }
        if !self.unique_id.is_empty() {
            os.write_string(4, &self.unique_id)?;
        }
        if self.disabled_by_default != false {
            os.write_bool(5, self.disabled_by_default)?;
        }
        if !self.icon.is_empty() {
            os.write_string(6, &self.icon)?;
        }
        if self.entity_category != ::protobuf::EnumOrUnknown::new(EntityCategory::ENTITY_CATEGORY_NONE) {
            os.write_enum(7, ::protobuf::EnumOrUnknown::value(&self.entity_category))?;
        }
        if self.device_id != 0 {
            os.write_uint32(8, self.device_id)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ListEntitiesCameraResponse {
        ListEntitiesCameraResponse::new()
    }

    fn clear(&mut self) {
        self.object_id.clear();
        self.key = 0;
        self.name.clear();
        self.unique_id.clear();
        self.disabled_by_default = false;
        self.icon.clear();
        self.entity_category = ::protobuf::EnumOrUnknown::new(EntityCategory::ENTITY_CATEGORY_NONE);
        self.device_id = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ListEntitiesCameraResponse {
        static instance: ListEntitiesCameraResponse = ListEntitiesCameraResponse {
            object_id: ::std::string::String::new(),
            key: 0,
            name: ::std::string::String::new(),
            unique_id: ::std::string::String::new(),
            disabled_by_default: false,
            icon: ::std::string::String::new(),
            entity_category: ::protobuf::EnumOrUnknown::from_i32(0),
            device_id: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ListEntitiesCameraResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ListEntitiesCameraResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ListEntitiesCameraResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ListEntitiesCameraResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CameraImageResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CameraImageResponse {
    // message fields
    // @@protoc_insertion_point(field:CameraImageResponse.key)
    pub key: u32,
    // @@protoc_insertion_point(field:CameraImageResponse.data)
    pub data: ::std::vec::Vec<u8>,
    // @@protoc_insertion_point(field:CameraImageResponse.done)
    pub done: bool,
    // @@protoc_insertion_point(field:CameraImageResponse.device_id)
    pub device_id: u32,
    // special fields
    // @@protoc_insertion_point(special_field:CameraImageResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CameraImageResponse {
    fn default() -> &'a CameraImageResponse {
        <CameraImageResponse as ::protobuf::Message>::default_instance()
    }
}

impl CameraImageResponse {
    pub fn new() -> CameraImageResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "key",
            |m: &CameraImageResponse| { &m.key },
            |m: &mut CameraImageResponse| { &mut m.key },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "data",
            |m: &CameraImageResponse| { &m.data },
            |m: &mut CameraImageResponse| { &mut m.data },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "done",
            |m: &CameraImageResponse| { &m.done },
            |m: &mut CameraImageResponse| { &mut m.done },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "device_id",
            |m: &CameraImageResponse| { &m.device_id },
            |m: &mut CameraImageResponse| { &mut m.device_id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CameraImageResponse>(
            "CameraImageResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CameraImageResponse {
    const NAME: &'static str = "CameraImageResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                13 => {
                    self.key = is.read_fixed32()?;
                },
                18 => {
                    self.data = is.read_bytes()?;
                },
                24 => {
                    self.done = is.read_bool()?;
                },
                32 => {
                    self.device_id = is.read_uint32()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.key != 0 {
            my_size += 1 + 4;
        }
        if !self.data.is_empty() {
            my_size += ::protobuf::rt::bytes_size(2, &self.data);
        }
        if self.done != false {
            my_size += 1 + 1;
        }
        if self.device_id != 0 {
            my_size += ::protobuf::rt::uint32_size(4, self.device_id);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.key != 0 {
            os.write_fixed32(1, self.key)?;
        }
        if !self.data.is_empty() {
            os.write_bytes(2, &self.data)?;
        }
        if self.done != false {
            os.write_bool(3, self.done)?;
        }
        if self.device_id != 0 {
            os.write_uint32(4, self.device_id)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CameraImageResponse {
        CameraImageResponse::new()
    }

    fn clear(&mut self) {
        self.key = 0;
        self.data.clear();
        self.done = false;
        self.device_id = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CameraImageResponse {
        static instance: CameraImageResponse = CameraImageResponse {
            key: 0,
            data: ::std::vec::Vec::new(),
            done: false,
            device_id: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CameraImageResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CameraImageResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CameraImageResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CameraImageResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:CameraImageRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct CameraImageRequest {
    // message fields
    // @@protoc_insertion_point(field:CameraImageRequest.single)
    pub single: bool,
    // @@protoc_insertion_point(field:CameraImageRequest.stream)
    pub stream: bool,
    // special fields
    // @@protoc_insertion_point(special_field:CameraImageRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a CameraImageRequest {
    fn default() -> &'a CameraImageRequest {
        <CameraImageRequest as ::protobuf::Message>::default_instance()
    }
}

impl CameraImageRequest {
    pub fn new() -> CameraImageRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "single",
            |m: &CameraImageRequest| { &m.single },
            |m: &mut CameraImageRequest| { &mut m.single },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "stream",
            |m: &CameraImageRequest| { &m.stream },
            |m: &mut CameraImageRequest| { &mut m.stream },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<CameraImageRequest>(
            "CameraImageRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for CameraImageRequest {
    const NAME: &'static str = "CameraImageRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.single = is.read_bool()?;
                },
                16 => {
                    self.stream = is.read_bool()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.single != false {
            my_size += 1 + 1;
        }
        if self.stream != false {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.single != false {
            os.write_bool(1, self.single)?;
        }
        if self.stream != false {
            os.write_bool(2, self.stream)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> CameraImageRequest {
        CameraImageRequest::new()
    }

    fn clear(&mut self) {
        self.single = false;
        self.stream = false;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static CameraImageRequest {
        static instance: CameraImageRequest = CameraImageRequest {
            single: false,
            stream: false,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for CameraImageRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("CameraImageRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for CameraImageRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for CameraImageRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:ListEntitiesClimateResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ListEntitiesClimateResponse {
    // message fields
    // @@protoc_insertion_point(field:ListEntitiesClimateResponse.object_id)
    pub object_id: ::std::string::String,
    // @@protoc_insertion_point(field:ListEntitiesClimateResponse.key)
    pub key: u32,
    // @@protoc_insertion_point(field:ListEntitiesClimateResponse.name)
    pub name: ::std::string::String,
    // @@protoc_insertion_point(field:ListEntitiesClimateResponse.unique_id)
    pub unique_id: ::std::string::String,
    // @@protoc_insertion_point(field:ListEntitiesClimateResponse.supports_current_temperature)
    pub supports_current_temperature: bool,
    // @@protoc_insertion_point(field:ListEntitiesClimateResponse.supports_two_point_target_temperature)
    pub supports_two_point_target_temperature: bool,
    // @@protoc_insertion_point(field:ListEntitiesClimateResponse.supported_modes)
    pub supported_modes: ::std::vec::Vec<::protobuf::EnumOrUnknown<ClimateMode>>,
    // @@protoc_insertion_point(field:ListEntitiesClimateResponse.visual_min_temperature)
    pub visual_min_temperature: f32,
    // @@protoc_insertion_point(field:ListEntitiesClimateResponse.visual_max_temperature)
    pub visual_max_temperature: f32,
    // @@protoc_insertion_point(field:ListEntitiesClimateResponse.visual_target_temperature_step)
    pub visual_target_temperature_step: f32,
    // @@protoc_insertion_point(field:ListEntitiesClimateResponse.legacy_supports_away)
    pub legacy_supports_away: bool,
    // @@protoc_insertion_point(field:ListEntitiesClimateResponse.supports_action)
    pub supports_action: bool,
    // @@protoc_insertion_point(field:ListEntitiesClimateResponse.supported_fan_modes)
    pub supported_fan_modes: ::std::vec::Vec<::protobuf::EnumOrUnknown<ClimateFanMode>>,
    // @@protoc_insertion_point(field:ListEntitiesClimateResponse.supported_swing_modes)
    pub supported_swing_modes: ::std::vec::Vec<::protobuf::EnumOrUnknown<ClimateSwingMode>>,
    // @@protoc_insertion_point(field:ListEntitiesClimateResponse.supported_custom_fan_modes)
    pub supported_custom_fan_modes: ::std::vec::Vec<::std::string::String>,
    // @@protoc_insertion_point(field:ListEntitiesClimateResponse.supported_presets)
    pub supported_presets: ::std::vec::Vec<::protobuf::EnumOrUnknown<ClimatePreset>>,
    // @@protoc_insertion_point(field:ListEntitiesClimateResponse.supported_custom_presets)
    pub supported_custom_presets: ::std::vec::Vec<::std::string::String>,
    // @@protoc_insertion_point(field:ListEntitiesClimateResponse.disabled_by_default)
    pub disabled_by_default: bool,
    // @@protoc_insertion_point(field:ListEntitiesClimateResponse.icon)
    pub icon: ::std::string::String,
    // @@protoc_insertion_point(field:ListEntitiesClimateResponse.entity_category)
    pub entity_category: ::protobuf::EnumOrUnknown<EntityCategory>,
    // @@protoc_insertion_point(field:ListEntitiesClimateResponse.visual_current_temperature_step)
    pub visual_current_temperature_step: f32,
    // @@protoc_insertion_point(field:ListEntitiesClimateResponse.supports_current_humidity)
    pub supports_current_humidity: bool,
    // @@protoc_insertion_point(field:ListEntitiesClimateResponse.supports_target_humidity)
    pub supports_target_humidity: bool,
    // @@protoc_insertion_point(field:ListEntitiesClimateResponse.visual_min_humidity)
    pub visual_min_humidity: f32,
    // @@protoc_insertion_point(field:ListEntitiesClimateResponse.visual_max_humidity)
    pub visual_max_humidity: f32,
    // @@protoc_insertion_point(field:ListEntitiesClimateResponse.device_id)
    pub device_id: u32,
    // special fields
    // @@protoc_insertion_point(special_field:ListEntitiesClimateResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ListEntitiesClimateResponse {
    fn default() -> &'a ListEntitiesClimateResponse {
        <ListEntitiesClimateResponse as ::protobuf::Message>::default_instance()
    }
}

impl ListEntitiesClimateResponse {
    pub fn new() -> ListEntitiesClimateResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(26);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "object_id",
            |m: &ListEntitiesClimateResponse| { &m.object_id },
            |m: &mut ListEntitiesClimateResponse| { &mut m.object_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "key",
            |m: &ListEntitiesClimateResponse| { &m.key },
            |m: &mut ListEntitiesClimateResponse| { &mut m.key },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "name",
            |m: &ListEntitiesClimateResponse| { &m.name },
            |m: &mut ListEntitiesClimateResponse| { &mut m.name },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "unique_id",
            |m: &ListEntitiesClimateResponse| { &m.unique_id },
            |m: &mut ListEntitiesClimateResponse| { &mut m.unique_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "supports_current_temperature",
            |m: &ListEntitiesClimateResponse| { &m.supports_current_temperature },
            |m: &mut ListEntitiesClimateResponse| { &mut m.supports_current_temperature },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "supports_two_point_target_temperature",
            |m: &ListEntitiesClimateResponse| { &m.supports_two_point_target_temperature },
            |m: &mut ListEntitiesClimateResponse| { &mut m.supports_two_point_target_temperature },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "supported_modes",
            |m: &ListEntitiesClimateResponse| { &m.supported_modes },
            |m: &mut ListEntitiesClimateResponse| { &mut m.supported_modes },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "visual_min_temperature",
            |m: &ListEntitiesClimateResponse| { &m.visual_min_temperature },
            |m: &mut ListEntitiesClimateResponse| { &mut m.visual_min_temperature },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "visual_max_temperature",
            |m: &ListEntitiesClimateResponse| { &m.visual_max_temperature },
            |m: &mut ListEntitiesClimateResponse| { &mut m.visual_max_temperature },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "visual_target_temperature_step",
            |m: &ListEntitiesClimateResponse| { &m.visual_target_temperature_step },
            |m: &mut ListEntitiesClimateResponse| { &mut m.visual_target_temperature_step },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "legacy_supports_away",
            |m: &ListEntitiesClimateResponse| { &m.legacy_supports_away },
            |m: &mut ListEntitiesClimateResponse| { &mut m.legacy_supports_away },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "supports_action",
            |m: &ListEntitiesClimateResponse| { &m.supports_action },
            |m: &mut ListEntitiesClimateResponse| { &mut m.supports_action },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "supported_fan_modes",
            |m: &ListEntitiesClimateResponse| { &m.supported_fan_modes },
            |m: &mut ListEntitiesClimateResponse| { &mut m.supported_fan_modes },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "supported_swing_modes",
            |m: &ListEntitiesClimateResponse| { &m.supported_swing_modes },
            |m: &mut ListEntitiesClimateResponse| { &mut m.supported_swing_modes },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "supported_custom_fan_modes",
            |m: &ListEntitiesClimateResponse| { &m.supported_custom_fan_modes },
            |m: &mut ListEntitiesClimateResponse| { &mut m.supported_custom_fan_modes },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "supported_presets",
            |m: &ListEntitiesClimateResponse| { &m.supported_presets },
            |m: &mut ListEntitiesClimateResponse| { &mut m.supported_presets },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "supported_custom_presets",
            |m: &ListEntitiesClimateResponse| { &m.supported_custom_presets },
            |m: &mut ListEntitiesClimateResponse| { &mut m.supported_custom_presets },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "disabled_by_default",
            |m: &ListEntitiesClimateResponse| { &m.disabled_by_default },
            |m: &mut ListEntitiesClimateResponse| { &mut m.disabled_by_default },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "icon",
            |m: &ListEntitiesClimateResponse| { &m.icon },
            |m: &mut ListEntitiesClimateResponse| { &mut m.icon },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "entity_category",
            |m: &ListEntitiesClimateResponse| { &m.entity_category },
            |m: &mut ListEntitiesClimateResponse| { &mut m.entity_category },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "visual_current_temperature_step",
            |m: &ListEntitiesClimateResponse| { &m.visual_current_temperature_step },
            |m: &mut ListEntitiesClimateResponse| { &mut m.visual_current_temperature_step },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "supports_current_humidity",
            |m: &ListEntitiesClimateResponse| { &m.supports_current_humidity },
            |m: &mut ListEntitiesClimateResponse| { &mut m.supports_current_humidity },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "supports_target_humidity",
            |m: &ListEntitiesClimateResponse| { &m.supports_target_humidity },
            |m: &mut ListEntitiesClimateResponse| { &mut m.supports_target_humidity },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "visual_min_humidity",
            |m: &ListEntitiesClimateResponse| { &m.visual_min_humidity },
            |m: &mut ListEntitiesClimateResponse| { &mut m.visual_min_humidity },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "visual_max_humidity",
            |m: &ListEntitiesClimateResponse| { &m.visual_max_humidity },
            |m: &mut ListEntitiesClimateResponse| { &mut m.visual_max_humidity },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "device_id",
            |m: &ListEntitiesClimateResponse| { &m.device_id },
            |m: &mut ListEntitiesClimateResponse| { &mut m.device_id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ListEntitiesClimateResponse>(
            "ListEntitiesClimateResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ListEntitiesClimateResponse {
    const NAME: &'static str = "ListEntitiesClimateResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.object_id = is.read_string()?;
                },
                21 => {
                    self.key = is.read_fixed32()?;
                },
                26 => {
                    self.name = is.read_string()?;
                },
                34 => {
                    self.unique_id = is.read_string()?;
                },
                40 => {
                    self.supports_current_temperature = is.read_bool()?;
                },
                48 => {
                    self.supports_two_point_target_temperature = is.read_bool()?;
                },
                56 => {
                    self.supported_modes.push(is.read_enum_or_unknown()?);
                },
                58 => {
                    ::protobuf::rt::read_repeated_packed_enum_or_unknown_into(is, &mut self.supported_modes)?
                },
                69 => {
                    self.visual_min_temperature = is.read_float()?;
                },
                77 => {
                    self.visual_max_temperature = is.read_float()?;
                },
                85 => {
                    self.visual_target_temperature_step = is.read_float()?;
                },
                88 => {
                    self.legacy_supports_away = is.read_bool()?;
                },
                96 => {
                    self.supports_action = is.read_bool()?;
                },
                104 => {
                    self.supported_fan_modes.push(is.read_enum_or_unknown()?);
                },
                106 => {
                    ::protobuf::rt::read_repeated_packed_enum_or_unknown_into(is, &mut self.supported_fan_modes)?
                },
                112 => {
                    self.supported_swing_modes.push(is.read_enum_or_unknown()?);
                },
                114 => {
                    ::protobuf::rt::read_repeated_packed_enum_or_unknown_into(is, &mut self.supported_swing_modes)?
                },
                122 => {
                    self.supported_custom_fan_modes.push(is.read_string()?);
                },
                128 => {
                    self.supported_presets.push(is.read_enum_or_unknown()?);
                },
                130 => {
                    ::protobuf::rt::read_repeated_packed_enum_or_unknown_into(is, &mut self.supported_presets)?
                },
                138 => {
                    self.supported_custom_presets.push(is.read_string()?);
                },
                144 => {
                    self.disabled_by_default = is.read_bool()?;
                },
                154 => {
                    self.icon = is.read_string()?;
                },
                160 => {
                    self.entity_category = is.read_enum_or_unknown()?;
                },
                173 => {
                    self.visual_current_temperature_step = is.read_float()?;
                },
                176 => {
                    self.supports_current_humidity = is.read_bool()?;
                },
                184 => {
                    self.supports_target_humidity = is.read_bool()?;
                },
                197 => {
                    self.visual_min_humidity = is.read_float()?;
                },
                205 => {
                    self.visual_max_humidity = is.read_float()?;
                },
                208 => {
                    self.device_id = is.read_uint32()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.object_id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.object_id);
        }
        if self.key != 0 {
            my_size += 1 + 4;
        }
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.name);
        }
        if !self.unique_id.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.unique_id);
        }
        if self.supports_current_temperature != false {
            my_size += 1 + 1;
        }
        if self.supports_two_point_target_temperature != false {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::vec_packed_enum_or_unknown_size(7, &self.supported_modes);
        if self.visual_min_temperature != 0. {
            my_size += 1 + 4;
        }
        if self.visual_max_temperature != 0. {
            my_size += 1 + 4;
        }
        if self.visual_target_temperature_step != 0. {
            my_size += 1 + 4;
        }
        if self.legacy_supports_away != false {
            my_size += 1 + 1;
        }
        if self.supports_action != false {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::vec_packed_enum_or_unknown_size(13, &self.supported_fan_modes);
        my_size += ::protobuf::rt::vec_packed_enum_or_unknown_size(14, &self.supported_swing_modes);
        for value in &self.supported_custom_fan_modes {
            my_size += ::protobuf::rt::string_size(15, &value);
        };
        my_size += ::protobuf::rt::vec_packed_enum_or_unknown_size(16, &self.supported_presets);
        for value in &self.supported_custom_presets {
            my_size += ::protobuf::rt::string_size(17, &value);
        };
        if self.disabled_by_default != false {
            my_size += 2 + 1;
        }
        if !self.icon.is_empty() {
            my_size += ::protobuf::rt::string_size(19, &self.icon);
        }
        if self.entity_category != ::protobuf::EnumOrUnknown::new(EntityCategory::ENTITY_CATEGORY_NONE) {
            my_size += ::protobuf::rt::int32_size(20, self.entity_category.value());
        }
        if self.visual_current_temperature_step != 0. {
            my_size += 2 + 4;
        }
        if self.supports_current_humidity != false {
            my_size += 2 + 1;
        }
        if self.supports_target_humidity != false {
            my_size += 2 + 1;
        }
        if self.visual_min_humidity != 0. {
            my_size += 2 + 4;
        }
        if self.visual_max_humidity != 0. {
            my_size += 2 + 4;
        }
        if self.device_id != 0 {
            my_size += ::protobuf::rt::uint32_size(26, self.device_id);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.object_id.is_empty() {
            os.write_string(1, &self.object_id)?;
        }
        if self.key != 0 {
            os.write_fixed32(2, self.key)?;
        }
        if !self.name.is_empty() {
            os.write_string(3, &self.name)?;
        }
        if !self.unique_id.is_empty() {
            os.write_string(4, &self.unique_id)?;
        }
        if self.supports_current_temperature != false {
            os.write_bool(5, self.supports_current_temperature)?;
        }
        if self.supports_two_point_target_temperature != false {
            os.write_bool(6, self.supports_two_point_target_temperature)?;
        }
        os.write_repeated_packed_enum_or_unknown(7, &self.supported_modes)?;
        if self.visual_min_temperature != 0. {
            os.write_float(8, self.visual_min_temperature)?;
        }
        if self.visual_max_temperature != 0. {
            os.write_float(9, self.visual_max_temperature)?;
        }
        if self.visual_target_temperature_step != 0. {
            os.write_float(10, self.visual_target_temperature_step)?;
        }
        if self.legacy_supports_away != false {
            os.write_bool(11, self.legacy_supports_away)?;
        }
        if self.supports_action != false {
            os.write_bool(12, self.supports_action)?;
        }
        os.write_repeated_packed_enum_or_unknown(13, &self.supported_fan_modes)?;
        os.write_repeated_packed_enum_or_unknown(14, &self.supported_swing_modes)?;
        for v in &self.supported_custom_fan_modes {
            os.write_string(15, &v)?;
        };
        os.write_repeated_packed_enum_or_unknown(16, &self.supported_presets)?;
        for v in &self.supported_custom_presets {
            os.write_string(17, &v)?;
        };
        if self.disabled_by_default != false {
            os.write_bool(18, self.disabled_by_default)?;
        }
        if !self.icon.is_empty() {
            os.write_string(19, &self.icon)?;
        }
        if self.entity_category != ::protobuf::EnumOrUnknown::new(EntityCategory::ENTITY_CATEGORY_NONE) {
            os.write_enum(20, ::protobuf::EnumOrUnknown::value(&self.entity_category))?;
        }
        if self.visual_current_temperature_step != 0. {
            os.write_float(21, self.visual_current_temperature_step)?;
        }
        if self.supports_current_humidity != false {
            os.write_bool(22, self.supports_current_humidity)?;
        }
        if self.supports_target_humidity != false {
            os.write_bool(23, self.supports_target_humidity)?;
        }
        if self.visual_min_humidity != 0. {
            os.write_float(24, self.visual_min_humidity)?;
        }
        if self.visual_max_humidity != 0. {
            os.write_float(25, self.visual_max_humidity)?;
        }
        if self.device_id != 0 {
            os.write_uint32(26, self.device_id)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ListEntitiesClimateResponse {
        ListEntitiesClimateResponse::new()
    }

    fn clear(&mut self) {
        self.object_id.clear();
        self.key = 0;
        self.name.clear();
        self.unique_id.clear();
        self.supports_current_temperature = false;
        self.supports_two_point_target_temperature = false;
        self.supported_modes.clear();
        self.visual_min_temperature = 0.;
        self.visual_max_temperature = 0.;
        self.visual_target_temperature_step = 0.;
        self.legacy_supports_away = false;
        self.supports_action = false;
        self.supported_fan_modes.clear();
        self.supported_swing_modes.clear();
        self.supported_custom_fan_modes.clear();
        self.supported_presets.clear();
        self.supported_custom_presets.clear();
        self.disabled_by_default = false;
        self.icon.clear();
        self.entity_category = ::protobuf::EnumOrUnknown::new(EntityCategory::ENTITY_CATEGORY_NONE);
        self.visual_current_temperature_step = 0.;
        self.supports_current_humidity = false;
        self.supports_target_humidity = false;
        self.visual_min_humidity = 0.;
        self.visual_max_humidity = 0.;
        self.device_id = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ListEntitiesClimateResponse {
        static instance: ListEntitiesClimateResponse = ListEntitiesClimateResponse {
            object_id: ::std::string::String::new(),
            key: 0,
            name: ::std::string::String::new(),
            unique_id: ::std::string::String::new(),
            supports_current_temperature: false,
            supports_two_point_target_temperature: false,
            supported_modes: ::std::vec::Vec::new(),
            visual_min_temperature: 0.,
            visual_max_temperature: 0.,
            visual_target_temperature_step: 0.,
            legacy_supports_away: false,
            supports_action: false,
            supported_fan_modes: ::std::vec::Vec::new(),
            supported_swing_modes: ::std::vec::Vec::new(),
            supported_custom_fan_modes: ::std::vec::Vec::new(),
            supported_presets: ::std::vec::Vec::new(),
            supported_custom_presets: ::std::vec::Vec::new(),
            disabled_by_default: false,
            icon: ::std::string::String::new(),
            entity_category: ::protobuf::EnumOrUnknown::from_i32(0),
            visual_current_temperature_step: 0.,
            supports_current_humidity: false,
            supports_target_humidity: false,
            visual_min_humidity: 0.,
            visual_max_humidity: 0.,
            device_id: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ListEntitiesClimateResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ListEntitiesClimateResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ListEntitiesClimateResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ListEntitiesClimateResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:ClimateStateResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ClimateStateResponse {
    // message fields
    // @@protoc_insertion_point(field:ClimateStateResponse.key)
    pub key: u32,
    // @@protoc_insertion_point(field:ClimateStateResponse.mode)
    pub mode: ::protobuf::EnumOrUnknown<ClimateMode>,
    // @@protoc_insertion_point(field:ClimateStateResponse.current_temperature)
    pub current_temperature: f32,
    // @@protoc_insertion_point(field:ClimateStateResponse.target_temperature)
    pub target_temperature: f32,
    // @@protoc_insertion_point(field:ClimateStateResponse.target_temperature_low)
    pub target_temperature_low: f32,
    // @@protoc_insertion_point(field:ClimateStateResponse.target_temperature_high)
    pub target_temperature_high: f32,
    // @@protoc_insertion_point(field:ClimateStateResponse.unused_legacy_away)
    pub unused_legacy_away: bool,
    // @@protoc_insertion_point(field:ClimateStateResponse.action)
    pub action: ::protobuf::EnumOrUnknown<ClimateAction>,
    // @@protoc_insertion_point(field:ClimateStateResponse.fan_mode)
    pub fan_mode: ::protobuf::EnumOrUnknown<ClimateFanMode>,
    // @@protoc_insertion_point(field:ClimateStateResponse.swing_mode)
    pub swing_mode: ::protobuf::EnumOrUnknown<ClimateSwingMode>,
    // @@protoc_insertion_point(field:ClimateStateResponse.custom_fan_mode)
    pub custom_fan_mode: ::std::string::String,
    // @@protoc_insertion_point(field:ClimateStateResponse.preset)
    pub preset: ::protobuf::EnumOrUnknown<ClimatePreset>,
    // @@protoc_insertion_point(field:ClimateStateResponse.custom_preset)
    pub custom_preset: ::std::string::String,
    // @@protoc_insertion_point(field:ClimateStateResponse.current_humidity)
    pub current_humidity: f32,
    // @@protoc_insertion_point(field:ClimateStateResponse.target_humidity)
    pub target_humidity: f32,
    // @@protoc_insertion_point(field:ClimateStateResponse.device_id)
    pub device_id: u32,
    // special fields
    // @@protoc_insertion_point(special_field:ClimateStateResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ClimateStateResponse {
    fn default() -> &'a ClimateStateResponse {
        <ClimateStateResponse as ::protobuf::Message>::default_instance()
    }
}

impl ClimateStateResponse {
    pub fn new() -> ClimateStateResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(16);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "key",
            |m: &ClimateStateResponse| { &m.key },
            |m: &mut ClimateStateResponse| { &mut m.key },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "mode",
            |m: &ClimateStateResponse| { &m.mode },
            |m: &mut ClimateStateResponse| { &mut m.mode },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "current_temperature",
            |m: &ClimateStateResponse| { &m.current_temperature },
            |m: &mut ClimateStateResponse| { &mut m.current_temperature },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "target_temperature",
            |m: &ClimateStateResponse| { &m.target_temperature },
            |m: &mut ClimateStateResponse| { &mut m.target_temperature },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "target_temperature_low",
            |m: &ClimateStateResponse| { &m.target_temperature_low },
            |m: &mut ClimateStateResponse| { &mut m.target_temperature_low },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "target_temperature_high",
            |m: &ClimateStateResponse| { &m.target_temperature_high },
            |m: &mut ClimateStateResponse| { &mut m.target_temperature_high },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "unused_legacy_away",
            |m: &ClimateStateResponse| { &m.unused_legacy_away },
            |m: &mut ClimateStateResponse| { &mut m.unused_legacy_away },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "action",
            |m: &ClimateStateResponse| { &m.action },
            |m: &mut ClimateStateResponse| { &mut m.action },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "fan_mode",
            |m: &ClimateStateResponse| { &m.fan_mode },
            |m: &mut ClimateStateResponse| { &mut m.fan_mode },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "swing_mode",
            |m: &ClimateStateResponse| { &m.swing_mode },
            |m: &mut ClimateStateResponse| { &mut m.swing_mode },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "custom_fan_mode",
            |m: &ClimateStateResponse| { &m.custom_fan_mode },
            |m: &mut ClimateStateResponse| { &mut m.custom_fan_mode },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "preset",
            |m: &ClimateStateResponse| { &m.preset },
            |m: &mut ClimateStateResponse| { &mut m.preset },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "custom_preset",
            |m: &ClimateStateResponse| { &m.custom_preset },
            |m: &mut ClimateStateResponse| { &mut m.custom_preset },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "current_humidity",
            |m: &ClimateStateResponse| { &m.current_humidity },
            |m: &mut ClimateStateResponse| { &mut m.current_humidity },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "target_humidity",
            |m: &ClimateStateResponse| { &m.target_humidity },
            |m: &mut ClimateStateResponse| { &mut m.target_humidity },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "device_id",
            |m: &ClimateStateResponse| { &m.device_id },
            |m: &mut ClimateStateResponse| { &mut m.device_id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ClimateStateResponse>(
            "ClimateStateResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ClimateStateResponse {
    const NAME: &'static str = "ClimateStateResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                13 => {
                    self.key = is.read_fixed32()?;
                },
                16 => {
                    self.mode = is.read_enum_or_unknown()?;
                },
                29 => {
                    self.current_temperature = is.read_float()?;
                },
                37 => {
                    self.target_temperature = is.read_float()?;
                },
                45 => {
                    self.target_temperature_low = is.read_float()?;
                },
                53 => {
                    self.target_temperature_high = is.read_float()?;
                },
                56 => {
                    self.unused_legacy_away = is.read_bool()?;
                },
                64 => {
                    self.action = is.read_enum_or_unknown()?;
                },
                72 => {
                    self.fan_mode = is.read_enum_or_unknown()?;
                },
                80 => {
                    self.swing_mode = is.read_enum_or_unknown()?;
                },
                90 => {
                    self.custom_fan_mode = is.read_string()?;
                },
                96 => {
                    self.preset = is.read_enum_or_unknown()?;
                },
                106 => {
                    self.custom_preset = is.read_string()?;
                },
                117 => {
                    self.current_humidity = is.read_float()?;
                },
                125 => {
                    self.target_humidity = is.read_float()?;
                },
                128 => {
                    self.device_id = is.read_uint32()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.key != 0 {
            my_size += 1 + 4;
        }
        if self.mode != ::protobuf::EnumOrUnknown::new(ClimateMode::CLIMATE_MODE_OFF) {
            my_size += ::protobuf::rt::int32_size(2, self.mode.value());
        }
        if self.current_temperature != 0. {
            my_size += 1 + 4;
        }
        if self.target_temperature != 0. {
            my_size += 1 + 4;
        }
        if self.target_temperature_low != 0. {
            my_size += 1 + 4;
        }
        if self.target_temperature_high != 0. {
            my_size += 1 + 4;
        }
        if self.unused_legacy_away != false {
            my_size += 1 + 1;
        }
        if self.action != ::protobuf::EnumOrUnknown::new(ClimateAction::CLIMATE_ACTION_OFF) {
            my_size += ::protobuf::rt::int32_size(8, self.action.value());
        }
        if self.fan_mode != ::protobuf::EnumOrUnknown::new(ClimateFanMode::CLIMATE_FAN_ON) {
            my_size += ::protobuf::rt::int32_size(9, self.fan_mode.value());
        }
        if self.swing_mode != ::protobuf::EnumOrUnknown::new(ClimateSwingMode::CLIMATE_SWING_OFF) {
            my_size += ::protobuf::rt::int32_size(10, self.swing_mode.value());
        }
        if !self.custom_fan_mode.is_empty() {
            my_size += ::protobuf::rt::string_size(11, &self.custom_fan_mode);
        }
        if self.preset != ::protobuf::EnumOrUnknown::new(ClimatePreset::CLIMATE_PRESET_NONE) {
            my_size += ::protobuf::rt::int32_size(12, self.preset.value());
        }
        if !self.custom_preset.is_empty() {
            my_size += ::protobuf::rt::string_size(13, &self.custom_preset);
        }
        if self.current_humidity != 0. {
            my_size += 1 + 4;
        }
        if self.target_humidity != 0. {
            my_size += 1 + 4;
        }
        if self.device_id != 0 {
            my_size += ::protobuf::rt::uint32_size(16, self.device_id);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.key != 0 {
            os.write_fixed32(1, self.key)?;
        }
        if self.mode != ::protobuf::EnumOrUnknown::new(ClimateMode::CLIMATE_MODE_OFF) {
            os.write_enum(2, ::protobuf::EnumOrUnknown::value(&self.mode))?;
        }
        if self.current_temperature != 0. {
            os.write_float(3, self.current_temperature)?;
        }
        if self.target_temperature != 0. {
            os.write_float(4, self.target_temperature)?;
        }
        if self.target_temperature_low != 0. {
            os.write_float(5, self.target_temperature_low)?;
        }
        if self.target_temperature_high != 0. {
            os.write_float(6, self.target_temperature_high)?;
        }
        if self.unused_legacy_away != false {
            os.write_bool(7, self.unused_legacy_away)?;
        }
        if self.action != ::protobuf::EnumOrUnknown::new(ClimateAction::CLIMATE_ACTION_OFF) {
            os.write_enum(8, ::protobuf::EnumOrUnknown::value(&self.action))?;
        }
        if self.fan_mode != ::protobuf::EnumOrUnknown::new(ClimateFanMode::CLIMATE_FAN_ON) {
            os.write_enum(9, ::protobuf::EnumOrUnknown::value(&self.fan_mode))?;
        }
        if self.swing_mode != ::protobuf::EnumOrUnknown::new(ClimateSwingMode::CLIMATE_SWING_OFF) {
            os.write_enum(10, ::protobuf::EnumOrUnknown::value(&self.swing_mode))?;
        }
        if !self.custom_fan_mode.is_empty() {
            os.write_string(11, &self.custom_fan_mode)?;
        }
        if self.preset != ::protobuf::EnumOrUnknown::new(ClimatePreset::CLIMATE_PRESET_NONE) {
            os.write_enum(12, ::protobuf::EnumOrUnknown::value(&self.preset))?;
        }
        if !self.custom_preset.is_empty() {
            os.write_string(13, &self.custom_preset)?;
        }
        if self.current_humidity != 0. {
            os.write_float(14, self.current_humidity)?;
        }
        if self.target_humidity != 0. {
            os.write_float(15, self.target_humidity)?;
        }
        if self.device_id != 0 {
            os.write_uint32(16, self.device_id)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ClimateStateResponse {
        ClimateStateResponse::new()
    }

    fn clear(&mut self) {
        self.key = 0;
        self.mode = ::protobuf::EnumOrUnknown::new(ClimateMode::CLIMATE_MODE_OFF);
        self.current_temperature = 0.;
        self.target_temperature = 0.;
        self.target_temperature_low = 0.;
        self.target_temperature_high = 0.;
        self.unused_legacy_away = false;
        self.action = ::protobuf::EnumOrUnknown::new(ClimateAction::CLIMATE_ACTION_OFF);
        self.fan_mode = ::protobuf::EnumOrUnknown::new(ClimateFanMode::CLIMATE_FAN_ON);
        self.swing_mode = ::protobuf::EnumOrUnknown::new(ClimateSwingMode::CLIMATE_SWING_OFF);
        self.custom_fan_mode.clear();
        self.preset = ::protobuf::EnumOrUnknown::new(ClimatePreset::CLIMATE_PRESET_NONE);
        self.custom_preset.clear();
        self.current_humidity = 0.;
        self.target_humidity = 0.;
        self.device_id = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ClimateStateResponse {
        static instance: ClimateStateResponse = ClimateStateResponse {
            key: 0,
            mode: ::protobuf::EnumOrUnknown::from_i32(0),
            current_temperature: 0.,
            target_temperature: 0.,
            target_temperature_low: 0.,
            target_temperature_high: 0.,
            unused_legacy_away: false,
            action: ::protobuf::EnumOrUnknown::from_i32(0),
            fan_mode: ::protobuf::EnumOrUnknown::from_i32(0),
            swing_mode: ::protobuf::EnumOrUnknown::from_i32(0),
            custom_fan_mode: ::std::string::String::new(),
            preset: ::protobuf::EnumOrUnknown::from_i32(0),
            custom_preset: ::std::string::String::new(),
            current_humidity: 0.,
            target_humidity: 0.,
            device_id: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ClimateStateResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ClimateStateResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ClimateStateResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ClimateStateResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:ClimateCommandRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ClimateCommandRequest {
    // message fields
    // @@protoc_insertion_point(field:ClimateCommandRequest.key)
    pub key: u32,
    // @@protoc_insertion_point(field:ClimateCommandRequest.has_mode)
    pub has_mode: bool,
    // @@protoc_insertion_point(field:ClimateCommandRequest.mode)
    pub mode: ::protobuf::EnumOrUnknown<ClimateMode>,
    // @@protoc_insertion_point(field:ClimateCommandRequest.has_target_temperature)
    pub has_target_temperature: bool,
    // @@protoc_insertion_point(field:ClimateCommandRequest.target_temperature)
    pub target_temperature: f32,
    // @@protoc_insertion_point(field:ClimateCommandRequest.has_target_temperature_low)
    pub has_target_temperature_low: bool,
    // @@protoc_insertion_point(field:ClimateCommandRequest.target_temperature_low)
    pub target_temperature_low: f32,
    // @@protoc_insertion_point(field:ClimateCommandRequest.has_target_temperature_high)
    pub has_target_temperature_high: bool,
    // @@protoc_insertion_point(field:ClimateCommandRequest.target_temperature_high)
    pub target_temperature_high: f32,
    // @@protoc_insertion_point(field:ClimateCommandRequest.unused_has_legacy_away)
    pub unused_has_legacy_away: bool,
    // @@protoc_insertion_point(field:ClimateCommandRequest.unused_legacy_away)
    pub unused_legacy_away: bool,
    // @@protoc_insertion_point(field:ClimateCommandRequest.has_fan_mode)
    pub has_fan_mode: bool,
    // @@protoc_insertion_point(field:ClimateCommandRequest.fan_mode)
    pub fan_mode: ::protobuf::EnumOrUnknown<ClimateFanMode>,
    // @@protoc_insertion_point(field:ClimateCommandRequest.has_swing_mode)
    pub has_swing_mode: bool,
    // @@protoc_insertion_point(field:ClimateCommandRequest.swing_mode)
    pub swing_mode: ::protobuf::EnumOrUnknown<ClimateSwingMode>,
    // @@protoc_insertion_point(field:ClimateCommandRequest.has_custom_fan_mode)
    pub has_custom_fan_mode: bool,
    // @@protoc_insertion_point(field:ClimateCommandRequest.custom_fan_mode)
    pub custom_fan_mode: ::std::string::String,
    // @@protoc_insertion_point(field:ClimateCommandRequest.has_preset)
    pub has_preset: bool,
    // @@protoc_insertion_point(field:ClimateCommandRequest.preset)
    pub preset: ::protobuf::EnumOrUnknown<ClimatePreset>,
    // @@protoc_insertion_point(field:ClimateCommandRequest.has_custom_preset)
    pub has_custom_preset: bool,
    // @@protoc_insertion_point(field:ClimateCommandRequest.custom_preset)
    pub custom_preset: ::std::string::String,
    // @@protoc_insertion_point(field:ClimateCommandRequest.has_target_humidity)
    pub has_target_humidity: bool,
    // @@protoc_insertion_point(field:ClimateCommandRequest.target_humidity)
    pub target_humidity: f32,
    // @@protoc_insertion_point(field:ClimateCommandRequest.device_id)
    pub device_id: u32,
    // special fields
    // @@protoc_insertion_point(special_field:ClimateCommandRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ClimateCommandRequest {
    fn default() -> &'a ClimateCommandRequest {
        <ClimateCommandRequest as ::protobuf::Message>::default_instance()
    }
}

impl ClimateCommandRequest {
    pub fn new() -> ClimateCommandRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(24);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "key",
            |m: &ClimateCommandRequest| { &m.key },
            |m: &mut ClimateCommandRequest| { &mut m.key },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "has_mode",
            |m: &ClimateCommandRequest| { &m.has_mode },
            |m: &mut ClimateCommandRequest| { &mut m.has_mode },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "mode",
            |m: &ClimateCommandRequest| { &m.mode },
            |m: &mut ClimateCommandRequest| { &mut m.mode },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "has_target_temperature",
            |m: &ClimateCommandRequest| { &m.has_target_temperature },
            |m: &mut ClimateCommandRequest| { &mut m.has_target_temperature },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "target_temperature",
            |m: &ClimateCommandRequest| { &m.target_temperature },
            |m: &mut ClimateCommandRequest| { &mut m.target_temperature },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "has_target_temperature_low",
            |m: &ClimateCommandRequest| { &m.has_target_temperature_low },
            |m: &mut ClimateCommandRequest| { &mut m.has_target_temperature_low },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "target_temperature_low",
            |m: &ClimateCommandRequest| { &m.target_temperature_low },
            |m: &mut ClimateCommandRequest| { &mut m.target_temperature_low },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "has_target_temperature_high",
            |m: &ClimateCommandRequest| { &m.has_target_temperature_high },
            |m: &mut ClimateCommandRequest| { &mut m.has_target_temperature_high },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "target_temperature_high",
            |m: &ClimateCommandRequest| { &m.target_temperature_high },
            |m: &mut ClimateCommandRequest| { &mut m.target_temperature_high },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "unused_has_legacy_away",
            |m: &ClimateCommandRequest| { &m.unused_has_legacy_away },
            |m: &mut ClimateCommandRequest| { &mut m.unused_has_legacy_away },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "unused_legacy_away",
            |m: &ClimateCommandRequest| { &m.unused_legacy_away },
            |m: &mut ClimateCommandRequest| { &mut m.unused_legacy_away },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "has_fan_mode",
            |m: &ClimateCommandRequest| { &m.has_fan_mode },
            |m: &mut ClimateCommandRequest| { &mut m.has_fan_mode },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "fan_mode",
            |m: &ClimateCommandRequest| { &m.fan_mode },
            |m: &mut ClimateCommandRequest| { &mut m.fan_mode },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "has_swing_mode",
            |m: &ClimateCommandRequest| { &m.has_swing_mode },
            |m: &mut ClimateCommandRequest| { &mut m.has_swing_mode },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "swing_mode",
            |m: &ClimateCommandRequest| { &m.swing_mode },
            |m: &mut ClimateCommandRequest| { &mut m.swing_mode },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "has_custom_fan_mode",
            |m: &ClimateCommandRequest| { &m.has_custom_fan_mode },
            |m: &mut ClimateCommandRequest| { &mut m.has_custom_fan_mode },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "custom_fan_mode",
            |m: &ClimateCommandRequest| { &m.custom_fan_mode },
            |m: &mut ClimateCommandRequest| { &mut m.custom_fan_mode },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "has_preset",
            |m: &ClimateCommandRequest| { &m.has_preset },
            |m: &mut ClimateCommandRequest| { &mut m.has_preset },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "preset",
            |m: &ClimateCommandRequest| { &m.preset },
            |m: &mut ClimateCommandRequest| { &mut m.preset },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "has_custom_preset",
            |m: &ClimateCommandRequest| { &m.has_custom_preset },
            |m: &mut ClimateCommandRequest| { &mut m.has_custom_preset },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "custom_preset",
            |m: &ClimateCommandRequest| { &m.custom_preset },
            |m: &mut ClimateCommandRequest| { &mut m.custom_preset },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "has_target_humidity",
            |m: &ClimateCommandRequest| { &m.has_target_humidity },
            |m: &mut ClimateCommandRequest| { &mut m.has_target_humidity },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "target_humidity",
            |m: &ClimateCommandRequest| { &m.target_humidity },
            |m: &mut ClimateCommandRequest| { &mut m.target_humidity },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "device_id",
            |m: &ClimateCommandRequest| { &m.device_id },
            |m: &mut ClimateCommandRequest| { &mut m.device_id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ClimateCommandRequest>(
            "ClimateCommandRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ClimateCommandRequest {
    const NAME: &'static str = "ClimateCommandRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                13 => {
                    self.key = is.read_fixed32()?;
                },
                16 => {
                    self.has_mode = is.read_bool()?;
                },
                24 => {
                    self.mode = is.read_enum_or_unknown()?;
                },
                32 => {
                    self.has_target_temperature = is.read_bool()?;
                },
                45 => {
                    self.target_temperature = is.read_float()?;
                },
                48 => {
                    self.has_target_temperature_low = is.read_bool()?;
                },
                61 => {
                    self.target_temperature_low = is.read_float()?;
                },
                64 => {
                    self.has_target_temperature_high = is.read_bool()?;
                },
                77 => {
                    self.target_temperature_high = is.read_float()?;
                },
                80 => {
                    self.unused_has_legacy_away = is.read_bool()?;
                },
                88 => {
                    self.unused_legacy_away = is.read_bool()?;
                },
                96 => {
                    self.has_fan_mode = is.read_bool()?;
                },
                104 => {
                    self.fan_mode = is.read_enum_or_unknown()?;
                },
                112 => {
                    self.has_swing_mode = is.read_bool()?;
                },
                120 => {
                    self.swing_mode = is.read_enum_or_unknown()?;
                },
                128 => {
                    self.has_custom_fan_mode = is.read_bool()?;
                },
                138 => {
                    self.custom_fan_mode = is.read_string()?;
                },
                144 => {
                    self.has_preset = is.read_bool()?;
                },
                152 => {
                    self.preset = is.read_enum_or_unknown()?;
                },
                160 => {
                    self.has_custom_preset = is.read_bool()?;
                },
                170 => {
                    self.custom_preset = is.read_string()?;
                },
                176 => {
                    self.has_target_humidity = is.read_bool()?;
                },
                189 => {
                    self.target_humidity = is.read_float()?;
                },
                192 => {
                    self.device_id = is.read_uint32()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.key != 0 {
            my_size += 1 + 4;
        }
        if self.has_mode != false {
            my_size += 1 + 1;
        }
        if self.mode != ::protobuf::EnumOrUnknown::new(ClimateMode::CLIMATE_MODE_OFF) {
            my_size += ::protobuf::rt::int32_size(3, self.mode.value());
        }
        if self.has_target_temperature != false {
            my_size += 1 + 1;
        }
        if self.target_temperature != 0. {
            my_size += 1 + 4;
        }
        if self.has_target_temperature_low != false {
            my_size += 1 + 1;
        }
        if self.target_temperature_low != 0. {
            my_size += 1 + 4;
        }
        if self.has_target_temperature_high != false {
            my_size += 1 + 1;
        }
        if self.target_temperature_high != 0. {
            my_size += 1 + 4;
        }
        if self.unused_has_legacy_away != false {
            my_size += 1 + 1;
        }
        if self.unused_legacy_away != false {
            my_size += 1 + 1;
        }
        if self.has_fan_mode != false {
            my_size += 1 + 1;
        }
        if self.fan_mode != ::protobuf::EnumOrUnknown::new(ClimateFanMode::CLIMATE_FAN_ON) {
            my_size += ::protobuf::rt::int32_size(13, self.fan_mode.value());
        }
        if self.has_swing_mode != false {
            my_size += 1 + 1;
        }
        if self.swing_mode != ::protobuf::EnumOrUnknown::new(ClimateSwingMode::CLIMATE_SWING_OFF) {
            my_size += ::protobuf::rt::int32_size(15, self.swing_mode.value());
        }
        if self.has_custom_fan_mode != false {
            my_size += 2 + 1;
        }
        if !self.custom_fan_mode.is_empty() {
            my_size += ::protobuf::rt::string_size(17, &self.custom_fan_mode);
        }
        if self.has_preset != false {
            my_size += 2 + 1;
        }
        if self.preset != ::protobuf::EnumOrUnknown::new(ClimatePreset::CLIMATE_PRESET_NONE) {
            my_size += ::protobuf::rt::int32_size(19, self.preset.value());
        }
        if self.has_custom_preset != false {
            my_size += 2 + 1;
        }
        if !self.custom_preset.is_empty() {
            my_size += ::protobuf::rt::string_size(21, &self.custom_preset);
        }
        if self.has_target_humidity != false {
            my_size += 2 + 1;
        }
        if self.target_humidity != 0. {
            my_size += 2 + 4;
        }
        if self.device_id != 0 {
            my_size += ::protobuf::rt::uint32_size(24, self.device_id);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.key != 0 {
            os.write_fixed32(1, self.key)?;
        }
        if self.has_mode != false {
            os.write_bool(2, self.has_mode)?;
        }
        if self.mode != ::protobuf::EnumOrUnknown::new(ClimateMode::CLIMATE_MODE_OFF) {
            os.write_enum(3, ::protobuf::EnumOrUnknown::value(&self.mode))?;
        }
        if self.has_target_temperature != false {
            os.write_bool(4, self.has_target_temperature)?;
        }
        if self.target_temperature != 0. {
            os.write_float(5, self.target_temperature)?;
        }
        if self.has_target_temperature_low != false {
            os.write_bool(6, self.has_target_temperature_low)?;
        }
        if self.target_temperature_low != 0. {
            os.write_float(7, self.target_temperature_low)?;
        }
        if self.has_target_temperature_high != false {
            os.write_bool(8, self.has_target_temperature_high)?;
        }
        if self.target_temperature_high != 0. {
            os.write_float(9, self.target_temperature_high)?;
        }
        if self.unused_has_legacy_away != false {
            os.write_bool(10, self.unused_has_legacy_away)?;
        }
        if self.unused_legacy_away != false {
            os.write_bool(11, self.unused_legacy_away)?;
        }
        if self.has_fan_mode != false {
            os.write_bool(12, self.has_fan_mode)?;
        }
        if self.fan_mode != ::protobuf::EnumOrUnknown::new(ClimateFanMode::CLIMATE_FAN_ON) {
            os.write_enum(13, ::protobuf::EnumOrUnknown::value(&self.fan_mode))?;
        }
        if self.has_swing_mode != false {
            os.write_bool(14, self.has_swing_mode)?;
        }
        if self.swing_mode != ::protobuf::EnumOrUnknown::new(ClimateSwingMode::CLIMATE_SWING_OFF) {
            os.write_enum(15, ::protobuf::EnumOrUnknown::value(&self.swing_mode))?;
        }
        if self.has_custom_fan_mode != false {
            os.write_bool(16, self.has_custom_fan_mode)?;
        }
        if !self.custom_fan_mode.is_empty() {
            os.write_string(17, &self.custom_fan_mode)?;
        }
        if self.has_preset != false {
            os.write_bool(18, self.has_preset)?;
        }
        if self.preset != ::protobuf::EnumOrUnknown::new(ClimatePreset::CLIMATE_PRESET_NONE) {
            os.write_enum(19, ::protobuf::EnumOrUnknown::value(&self.preset))?;
        }
        if self.has_custom_preset != false {
            os.write_bool(20, self.has_custom_preset)?;
        }
        if !self.custom_preset.is_empty() {
            os.write_string(21, &self.custom_preset)?;
        }
        if self.has_target_humidity != false {
            os.write_bool(22, self.has_target_humidity)?;
        }
        if self.target_humidity != 0. {
            os.write_float(23, self.target_humidity)?;
        }
        if self.device_id != 0 {
            os.write_uint32(24, self.device_id)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ClimateCommandRequest {
        ClimateCommandRequest::new()
    }

    fn clear(&mut self) {
        self.key = 0;
        self.has_mode = false;
        self.mode = ::protobuf::EnumOrUnknown::new(ClimateMode::CLIMATE_MODE_OFF);
        self.has_target_temperature = false;
        self.target_temperature = 0.;
        self.has_target_temperature_low = false;
        self.target_temperature_low = 0.;
        self.has_target_temperature_high = false;
        self.target_temperature_high = 0.;
        self.unused_has_legacy_away = false;
        self.unused_legacy_away = false;
        self.has_fan_mode = false;
        self.fan_mode = ::protobuf::EnumOrUnknown::new(ClimateFanMode::CLIMATE_FAN_ON);
        self.has_swing_mode = false;
        self.swing_mode = ::protobuf::EnumOrUnknown::new(ClimateSwingMode::CLIMATE_SWING_OFF);
        self.has_custom_fan_mode = false;
        self.custom_fan_mode.clear();
        self.has_preset = false;
        self.preset = ::protobuf::EnumOrUnknown::new(ClimatePreset::CLIMATE_PRESET_NONE);
        self.has_custom_preset = false;
        self.custom_preset.clear();
        self.has_target_humidity = false;
        self.target_humidity = 0.;
        self.device_id = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ClimateCommandRequest {
        static instance: ClimateCommandRequest = ClimateCommandRequest {
            key: 0,
            has_mode: false,
            mode: ::protobuf::EnumOrUnknown::from_i32(0),
            has_target_temperature: false,
            target_temperature: 0.,
            has_target_temperature_low: false,
            target_temperature_low: 0.,
            has_target_temperature_high: false,
            target_temperature_high: 0.,
            unused_has_legacy_away: false,
            unused_legacy_away: false,
            has_fan_mode: false,
            fan_mode: ::protobuf::EnumOrUnknown::from_i32(0),
            has_swing_mode: false,
            swing_mode: ::protobuf::EnumOrUnknown::from_i32(0),
            has_custom_fan_mode: false,
            custom_fan_mode: ::std::string::String::new(),
            has_preset: false,
            preset: ::protobuf::EnumOrUnknown::from_i32(0),
            has_custom_preset: false,
            custom_preset: ::std::string::String::new(),
            has_target_humidity: false,
            target_humidity: 0.,
            device_id: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ClimateCommandRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ClimateCommandRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ClimateCommandRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ClimateCommandRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:ListEntitiesNumberResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ListEntitiesNumberResponse {
    // message fields
    // @@protoc_insertion_point(field:ListEntitiesNumberResponse.object_id)
    pub object_id: ::std::string::String,
    // @@protoc_insertion_point(field:ListEntitiesNumberResponse.key)
    pub key: u32,
    // @@protoc_insertion_point(field:ListEntitiesNumberResponse.name)
    pub name: ::std::string::String,
    // @@protoc_insertion_point(field:ListEntitiesNumberResponse.unique_id)
    pub unique_id: ::std::string::String,
    // @@protoc_insertion_point(field:ListEntitiesNumberResponse.icon)
    pub icon: ::std::string::String,
    // @@protoc_insertion_point(field:ListEntitiesNumberResponse.min_value)
    pub min_value: f32,
    // @@protoc_insertion_point(field:ListEntitiesNumberResponse.max_value)
    pub max_value: f32,
    // @@protoc_insertion_point(field:ListEntitiesNumberResponse.step)
    pub step: f32,
    // @@protoc_insertion_point(field:ListEntitiesNumberResponse.disabled_by_default)
    pub disabled_by_default: bool,
    // @@protoc_insertion_point(field:ListEntitiesNumberResponse.entity_category)
    pub entity_category: ::protobuf::EnumOrUnknown<EntityCategory>,
    // @@protoc_insertion_point(field:ListEntitiesNumberResponse.unit_of_measurement)
    pub unit_of_measurement: ::std::string::String,
    // @@protoc_insertion_point(field:ListEntitiesNumberResponse.mode)
    pub mode: ::protobuf::EnumOrUnknown<NumberMode>,
    // @@protoc_insertion_point(field:ListEntitiesNumberResponse.device_class)
    pub device_class: ::std::string::String,
    // @@protoc_insertion_point(field:ListEntitiesNumberResponse.device_id)
    pub device_id: u32,
    // special fields
    // @@protoc_insertion_point(special_field:ListEntitiesNumberResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ListEntitiesNumberResponse {
    fn default() -> &'a ListEntitiesNumberResponse {
        <ListEntitiesNumberResponse as ::protobuf::Message>::default_instance()
    }
}

impl ListEntitiesNumberResponse {
    pub fn new() -> ListEntitiesNumberResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(14);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "object_id",
            |m: &ListEntitiesNumberResponse| { &m.object_id },
            |m: &mut ListEntitiesNumberResponse| { &mut m.object_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "key",
            |m: &ListEntitiesNumberResponse| { &m.key },
            |m: &mut ListEntitiesNumberResponse| { &mut m.key },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "name",
            |m: &ListEntitiesNumberResponse| { &m.name },
            |m: &mut ListEntitiesNumberResponse| { &mut m.name },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "unique_id",
            |m: &ListEntitiesNumberResponse| { &m.unique_id },
            |m: &mut ListEntitiesNumberResponse| { &mut m.unique_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "icon",
            |m: &ListEntitiesNumberResponse| { &m.icon },
            |m: &mut ListEntitiesNumberResponse| { &mut m.icon },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "min_value",
            |m: &ListEntitiesNumberResponse| { &m.min_value },
            |m: &mut ListEntitiesNumberResponse| { &mut m.min_value },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "max_value",
            |m: &ListEntitiesNumberResponse| { &m.max_value },
            |m: &mut ListEntitiesNumberResponse| { &mut m.max_value },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "step",
            |m: &ListEntitiesNumberResponse| { &m.step },
            |m: &mut ListEntitiesNumberResponse| { &mut m.step },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "disabled_by_default",
            |m: &ListEntitiesNumberResponse| { &m.disabled_by_default },
            |m: &mut ListEntitiesNumberResponse| { &mut m.disabled_by_default },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "entity_category",
            |m: &ListEntitiesNumberResponse| { &m.entity_category },
            |m: &mut ListEntitiesNumberResponse| { &mut m.entity_category },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "unit_of_measurement",
            |m: &ListEntitiesNumberResponse| { &m.unit_of_measurement },
            |m: &mut ListEntitiesNumberResponse| { &mut m.unit_of_measurement },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "mode",
            |m: &ListEntitiesNumberResponse| { &m.mode },
            |m: &mut ListEntitiesNumberResponse| { &mut m.mode },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "device_class",
            |m: &ListEntitiesNumberResponse| { &m.device_class },
            |m: &mut ListEntitiesNumberResponse| { &mut m.device_class },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "device_id",
            |m: &ListEntitiesNumberResponse| { &m.device_id },
            |m: &mut ListEntitiesNumberResponse| { &mut m.device_id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ListEntitiesNumberResponse>(
            "ListEntitiesNumberResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ListEntitiesNumberResponse {
    const NAME: &'static str = "ListEntitiesNumberResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.object_id = is.read_string()?;
                },
                21 => {
                    self.key = is.read_fixed32()?;
                },
                26 => {
                    self.name = is.read_string()?;
                },
                34 => {
                    self.unique_id = is.read_string()?;
                },
                42 => {
                    self.icon = is.read_string()?;
                },
                53 => {
                    self.min_value = is.read_float()?;
                },
                61 => {
                    self.max_value = is.read_float()?;
                },
                69 => {
                    self.step = is.read_float()?;
                },
                72 => {
                    self.disabled_by_default = is.read_bool()?;
                },
                80 => {
                    self.entity_category = is.read_enum_or_unknown()?;
                },
                90 => {
                    self.unit_of_measurement = is.read_string()?;
                },
                96 => {
                    self.mode = is.read_enum_or_unknown()?;
                },
                106 => {
                    self.device_class = is.read_string()?;
                },
                112 => {
                    self.device_id = is.read_uint32()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.object_id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.object_id);
        }
        if self.key != 0 {
            my_size += 1 + 4;
        }
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.name);
        }
        if !self.unique_id.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.unique_id);
        }
        if !self.icon.is_empty() {
            my_size += ::protobuf::rt::string_size(5, &self.icon);
        }
        if self.min_value != 0. {
            my_size += 1 + 4;
        }
        if self.max_value != 0. {
            my_size += 1 + 4;
        }
        if self.step != 0. {
            my_size += 1 + 4;
        }
        if self.disabled_by_default != false {
            my_size += 1 + 1;
        }
        if self.entity_category != ::protobuf::EnumOrUnknown::new(EntityCategory::ENTITY_CATEGORY_NONE) {
            my_size += ::protobuf::rt::int32_size(10, self.entity_category.value());
        }
        if !self.unit_of_measurement.is_empty() {
            my_size += ::protobuf::rt::string_size(11, &self.unit_of_measurement);
        }
        if self.mode != ::protobuf::EnumOrUnknown::new(NumberMode::NUMBER_MODE_AUTO) {
            my_size += ::protobuf::rt::int32_size(12, self.mode.value());
        }
        if !self.device_class.is_empty() {
            my_size += ::protobuf::rt::string_size(13, &self.device_class);
        }
        if self.device_id != 0 {
            my_size += ::protobuf::rt::uint32_size(14, self.device_id);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.object_id.is_empty() {
            os.write_string(1, &self.object_id)?;
        }
        if self.key != 0 {
            os.write_fixed32(2, self.key)?;
        }
        if !self.name.is_empty() {
            os.write_string(3, &self.name)?;
        }
        if !self.unique_id.is_empty() {
            os.write_string(4, &self.unique_id)?;
        }
        if !self.icon.is_empty() {
            os.write_string(5, &self.icon)?;
        }
        if self.min_value != 0. {
            os.write_float(6, self.min_value)?;
        }
        if self.max_value != 0. {
            os.write_float(7, self.max_value)?;
        }
        if self.step != 0. {
            os.write_float(8, self.step)?;
        }
        if self.disabled_by_default != false {
            os.write_bool(9, self.disabled_by_default)?;
        }
        if self.entity_category != ::protobuf::EnumOrUnknown::new(EntityCategory::ENTITY_CATEGORY_NONE) {
            os.write_enum(10, ::protobuf::EnumOrUnknown::value(&self.entity_category))?;
        }
        if !self.unit_of_measurement.is_empty() {
            os.write_string(11, &self.unit_of_measurement)?;
        }
        if self.mode != ::protobuf::EnumOrUnknown::new(NumberMode::NUMBER_MODE_AUTO) {
            os.write_enum(12, ::protobuf::EnumOrUnknown::value(&self.mode))?;
        }
        if !self.device_class.is_empty() {
            os.write_string(13, &self.device_class)?;
        }
        if self.device_id != 0 {
            os.write_uint32(14, self.device_id)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ListEntitiesNumberResponse {
        ListEntitiesNumberResponse::new()
    }

    fn clear(&mut self) {
        self.object_id.clear();
        self.key = 0;
        self.name.clear();
        self.unique_id.clear();
        self.icon.clear();
        self.min_value = 0.;
        self.max_value = 0.;
        self.step = 0.;
        self.disabled_by_default = false;
        self.entity_category = ::protobuf::EnumOrUnknown::new(EntityCategory::ENTITY_CATEGORY_NONE);
        self.unit_of_measurement.clear();
        self.mode = ::protobuf::EnumOrUnknown::new(NumberMode::NUMBER_MODE_AUTO);
        self.device_class.clear();
        self.device_id = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ListEntitiesNumberResponse {
        static instance: ListEntitiesNumberResponse = ListEntitiesNumberResponse {
            object_id: ::std::string::String::new(),
            key: 0,
            name: ::std::string::String::new(),
            unique_id: ::std::string::String::new(),
            icon: ::std::string::String::new(),
            min_value: 0.,
            max_value: 0.,
            step: 0.,
            disabled_by_default: false,
            entity_category: ::protobuf::EnumOrUnknown::from_i32(0),
            unit_of_measurement: ::std::string::String::new(),
            mode: ::protobuf::EnumOrUnknown::from_i32(0),
            device_class: ::std::string::String::new(),
            device_id: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ListEntitiesNumberResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ListEntitiesNumberResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ListEntitiesNumberResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ListEntitiesNumberResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:NumberStateResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct NumberStateResponse {
    // message fields
    // @@protoc_insertion_point(field:NumberStateResponse.key)
    pub key: u32,
    // @@protoc_insertion_point(field:NumberStateResponse.state)
    pub state: f32,
    // @@protoc_insertion_point(field:NumberStateResponse.missing_state)
    pub missing_state: bool,
    // @@protoc_insertion_point(field:NumberStateResponse.device_id)
    pub device_id: u32,
    // special fields
    // @@protoc_insertion_point(special_field:NumberStateResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a NumberStateResponse {
    fn default() -> &'a NumberStateResponse {
        <NumberStateResponse as ::protobuf::Message>::default_instance()
    }
}

impl NumberStateResponse {
    pub fn new() -> NumberStateResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "key",
            |m: &NumberStateResponse| { &m.key },
            |m: &mut NumberStateResponse| { &mut m.key },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "state",
            |m: &NumberStateResponse| { &m.state },
            |m: &mut NumberStateResponse| { &mut m.state },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "missing_state",
            |m: &NumberStateResponse| { &m.missing_state },
            |m: &mut NumberStateResponse| { &mut m.missing_state },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "device_id",
            |m: &NumberStateResponse| { &m.device_id },
            |m: &mut NumberStateResponse| { &mut m.device_id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<NumberStateResponse>(
            "NumberStateResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for NumberStateResponse {
    const NAME: &'static str = "NumberStateResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                13 => {
                    self.key = is.read_fixed32()?;
                },
                21 => {
                    self.state = is.read_float()?;
                },
                24 => {
                    self.missing_state = is.read_bool()?;
                },
                32 => {
                    self.device_id = is.read_uint32()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.key != 0 {
            my_size += 1 + 4;
        }
        if self.state != 0. {
            my_size += 1 + 4;
        }
        if self.missing_state != false {
            my_size += 1 + 1;
        }
        if self.device_id != 0 {
            my_size += ::protobuf::rt::uint32_size(4, self.device_id);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.key != 0 {
            os.write_fixed32(1, self.key)?;
        }
        if self.state != 0. {
            os.write_float(2, self.state)?;
        }
        if self.missing_state != false {
            os.write_bool(3, self.missing_state)?;
        }
        if self.device_id != 0 {
            os.write_uint32(4, self.device_id)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> NumberStateResponse {
        NumberStateResponse::new()
    }

    fn clear(&mut self) {
        self.key = 0;
        self.state = 0.;
        self.missing_state = false;
        self.device_id = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static NumberStateResponse {
        static instance: NumberStateResponse = NumberStateResponse {
            key: 0,
            state: 0.,
            missing_state: false,
            device_id: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for NumberStateResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("NumberStateResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for NumberStateResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for NumberStateResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:NumberCommandRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct NumberCommandRequest {
    // message fields
    // @@protoc_insertion_point(field:NumberCommandRequest.key)
    pub key: u32,
    // @@protoc_insertion_point(field:NumberCommandRequest.state)
    pub state: f32,
    // @@protoc_insertion_point(field:NumberCommandRequest.device_id)
    pub device_id: u32,
    // special fields
    // @@protoc_insertion_point(special_field:NumberCommandRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a NumberCommandRequest {
    fn default() -> &'a NumberCommandRequest {
        <NumberCommandRequest as ::protobuf::Message>::default_instance()
    }
}

impl NumberCommandRequest {
    pub fn new() -> NumberCommandRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "key",
            |m: &NumberCommandRequest| { &m.key },
            |m: &mut NumberCommandRequest| { &mut m.key },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "state",
            |m: &NumberCommandRequest| { &m.state },
            |m: &mut NumberCommandRequest| { &mut m.state },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "device_id",
            |m: &NumberCommandRequest| { &m.device_id },
            |m: &mut NumberCommandRequest| { &mut m.device_id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<NumberCommandRequest>(
            "NumberCommandRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for NumberCommandRequest {
    const NAME: &'static str = "NumberCommandRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                13 => {
                    self.key = is.read_fixed32()?;
                },
                21 => {
                    self.state = is.read_float()?;
                },
                24 => {
                    self.device_id = is.read_uint32()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.key != 0 {
            my_size += 1 + 4;
        }
        if self.state != 0. {
            my_size += 1 + 4;
        }
        if self.device_id != 0 {
            my_size += ::protobuf::rt::uint32_size(3, self.device_id);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.key != 0 {
            os.write_fixed32(1, self.key)?;
        }
        if self.state != 0. {
            os.write_float(2, self.state)?;
        }
        if self.device_id != 0 {
            os.write_uint32(3, self.device_id)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> NumberCommandRequest {
        NumberCommandRequest::new()
    }

    fn clear(&mut self) {
        self.key = 0;
        self.state = 0.;
        self.device_id = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static NumberCommandRequest {
        static instance: NumberCommandRequest = NumberCommandRequest {
            key: 0,
            state: 0.,
            device_id: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for NumberCommandRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("NumberCommandRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for NumberCommandRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for NumberCommandRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:ListEntitiesSelectResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ListEntitiesSelectResponse {
    // message fields
    // @@protoc_insertion_point(field:ListEntitiesSelectResponse.object_id)
    pub object_id: ::std::string::String,
    // @@protoc_insertion_point(field:ListEntitiesSelectResponse.key)
    pub key: u32,
    // @@protoc_insertion_point(field:ListEntitiesSelectResponse.name)
    pub name: ::std::string::String,
    // @@protoc_insertion_point(field:ListEntitiesSelectResponse.unique_id)
    pub unique_id: ::std::string::String,
    // @@protoc_insertion_point(field:ListEntitiesSelectResponse.icon)
    pub icon: ::std::string::String,
    // @@protoc_insertion_point(field:ListEntitiesSelectResponse.options)
    pub options: ::std::vec::Vec<::std::string::String>,
    // @@protoc_insertion_point(field:ListEntitiesSelectResponse.disabled_by_default)
    pub disabled_by_default: bool,
    // @@protoc_insertion_point(field:ListEntitiesSelectResponse.entity_category)
    pub entity_category: ::protobuf::EnumOrUnknown<EntityCategory>,
    // @@protoc_insertion_point(field:ListEntitiesSelectResponse.device_id)
    pub device_id: u32,
    // special fields
    // @@protoc_insertion_point(special_field:ListEntitiesSelectResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ListEntitiesSelectResponse {
    fn default() -> &'a ListEntitiesSelectResponse {
        <ListEntitiesSelectResponse as ::protobuf::Message>::default_instance()
    }
}

impl ListEntitiesSelectResponse {
    pub fn new() -> ListEntitiesSelectResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(9);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "object_id",
            |m: &ListEntitiesSelectResponse| { &m.object_id },
            |m: &mut ListEntitiesSelectResponse| { &mut m.object_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "key",
            |m: &ListEntitiesSelectResponse| { &m.key },
            |m: &mut ListEntitiesSelectResponse| { &mut m.key },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "name",
            |m: &ListEntitiesSelectResponse| { &m.name },
            |m: &mut ListEntitiesSelectResponse| { &mut m.name },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "unique_id",
            |m: &ListEntitiesSelectResponse| { &m.unique_id },
            |m: &mut ListEntitiesSelectResponse| { &mut m.unique_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "icon",
            |m: &ListEntitiesSelectResponse| { &m.icon },
            |m: &mut ListEntitiesSelectResponse| { &mut m.icon },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "options",
            |m: &ListEntitiesSelectResponse| { &m.options },
            |m: &mut ListEntitiesSelectResponse| { &mut m.options },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "disabled_by_default",
            |m: &ListEntitiesSelectResponse| { &m.disabled_by_default },
            |m: &mut ListEntitiesSelectResponse| { &mut m.disabled_by_default },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "entity_category",
            |m: &ListEntitiesSelectResponse| { &m.entity_category },
            |m: &mut ListEntitiesSelectResponse| { &mut m.entity_category },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "device_id",
            |m: &ListEntitiesSelectResponse| { &m.device_id },
            |m: &mut ListEntitiesSelectResponse| { &mut m.device_id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ListEntitiesSelectResponse>(
            "ListEntitiesSelectResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ListEntitiesSelectResponse {
    const NAME: &'static str = "ListEntitiesSelectResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.object_id = is.read_string()?;
                },
                21 => {
                    self.key = is.read_fixed32()?;
                },
                26 => {
                    self.name = is.read_string()?;
                },
                34 => {
                    self.unique_id = is.read_string()?;
                },
                42 => {
                    self.icon = is.read_string()?;
                },
                50 => {
                    self.options.push(is.read_string()?);
                },
                56 => {
                    self.disabled_by_default = is.read_bool()?;
                },
                64 => {
                    self.entity_category = is.read_enum_or_unknown()?;
                },
                72 => {
                    self.device_id = is.read_uint32()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.object_id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.object_id);
        }
        if self.key != 0 {
            my_size += 1 + 4;
        }
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.name);
        }
        if !self.unique_id.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.unique_id);
        }
        if !self.icon.is_empty() {
            my_size += ::protobuf::rt::string_size(5, &self.icon);
        }
        for value in &self.options {
            my_size += ::protobuf::rt::string_size(6, &value);
        };
        if self.disabled_by_default != false {
            my_size += 1 + 1;
        }
        if self.entity_category != ::protobuf::EnumOrUnknown::new(EntityCategory::ENTITY_CATEGORY_NONE) {
            my_size += ::protobuf::rt::int32_size(8, self.entity_category.value());
        }
        if self.device_id != 0 {
            my_size += ::protobuf::rt::uint32_size(9, self.device_id);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.object_id.is_empty() {
            os.write_string(1, &self.object_id)?;
        }
        if self.key != 0 {
            os.write_fixed32(2, self.key)?;
        }
        if !self.name.is_empty() {
            os.write_string(3, &self.name)?;
        }
        if !self.unique_id.is_empty() {
            os.write_string(4, &self.unique_id)?;
        }
        if !self.icon.is_empty() {
            os.write_string(5, &self.icon)?;
        }
        for v in &self.options {
            os.write_string(6, &v)?;
        };
        if self.disabled_by_default != false {
            os.write_bool(7, self.disabled_by_default)?;
        }
        if self.entity_category != ::protobuf::EnumOrUnknown::new(EntityCategory::ENTITY_CATEGORY_NONE) {
            os.write_enum(8, ::protobuf::EnumOrUnknown::value(&self.entity_category))?;
        }
        if self.device_id != 0 {
            os.write_uint32(9, self.device_id)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ListEntitiesSelectResponse {
        ListEntitiesSelectResponse::new()
    }

    fn clear(&mut self) {
        self.object_id.clear();
        self.key = 0;
        self.name.clear();
        self.unique_id.clear();
        self.icon.clear();
        self.options.clear();
        self.disabled_by_default = false;
        self.entity_category = ::protobuf::EnumOrUnknown::new(EntityCategory::ENTITY_CATEGORY_NONE);
        self.device_id = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ListEntitiesSelectResponse {
        static instance: ListEntitiesSelectResponse = ListEntitiesSelectResponse {
            object_id: ::std::string::String::new(),
            key: 0,
            name: ::std::string::String::new(),
            unique_id: ::std::string::String::new(),
            icon: ::std::string::String::new(),
            options: ::std::vec::Vec::new(),
            disabled_by_default: false,
            entity_category: ::protobuf::EnumOrUnknown::from_i32(0),
            device_id: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ListEntitiesSelectResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ListEntitiesSelectResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ListEntitiesSelectResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ListEntitiesSelectResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:SelectStateResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct SelectStateResponse {
    // message fields
    // @@protoc_insertion_point(field:SelectStateResponse.key)
    pub key: u32,
    // @@protoc_insertion_point(field:SelectStateResponse.state)
    pub state: ::std::string::String,
    // @@protoc_insertion_point(field:SelectStateResponse.missing_state)
    pub missing_state: bool,
    // @@protoc_insertion_point(field:SelectStateResponse.device_id)
    pub device_id: u32,
    // special fields
    // @@protoc_insertion_point(special_field:SelectStateResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a SelectStateResponse {
    fn default() -> &'a SelectStateResponse {
        <SelectStateResponse as ::protobuf::Message>::default_instance()
    }
}

impl SelectStateResponse {
    pub fn new() -> SelectStateResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "key",
            |m: &SelectStateResponse| { &m.key },
            |m: &mut SelectStateResponse| { &mut m.key },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "state",
            |m: &SelectStateResponse| { &m.state },
            |m: &mut SelectStateResponse| { &mut m.state },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "missing_state",
            |m: &SelectStateResponse| { &m.missing_state },
            |m: &mut SelectStateResponse| { &mut m.missing_state },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "device_id",
            |m: &SelectStateResponse| { &m.device_id },
            |m: &mut SelectStateResponse| { &mut m.device_id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<SelectStateResponse>(
            "SelectStateResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for SelectStateResponse {
    const NAME: &'static str = "SelectStateResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                13 => {
                    self.key = is.read_fixed32()?;
                },
                18 => {
                    self.state = is.read_string()?;
                },
                24 => {
                    self.missing_state = is.read_bool()?;
                },
                32 => {
                    self.device_id = is.read_uint32()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.key != 0 {
            my_size += 1 + 4;
        }
        if !self.state.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.state);
        }
        if self.missing_state != false {
            my_size += 1 + 1;
        }
        if self.device_id != 0 {
            my_size += ::protobuf::rt::uint32_size(4, self.device_id);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.key != 0 {
            os.write_fixed32(1, self.key)?;
        }
        if !self.state.is_empty() {
            os.write_string(2, &self.state)?;
        }
        if self.missing_state != false {
            os.write_bool(3, self.missing_state)?;
        }
        if self.device_id != 0 {
            os.write_uint32(4, self.device_id)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> SelectStateResponse {
        SelectStateResponse::new()
    }

    fn clear(&mut self) {
        self.key = 0;
        self.state.clear();
        self.missing_state = false;
        self.device_id = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static SelectStateResponse {
        static instance: SelectStateResponse = SelectStateResponse {
            key: 0,
            state: ::std::string::String::new(),
            missing_state: false,
            device_id: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for SelectStateResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("SelectStateResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for SelectStateResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SelectStateResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:SelectCommandRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct SelectCommandRequest {
    // message fields
    // @@protoc_insertion_point(field:SelectCommandRequest.key)
    pub key: u32,
    // @@protoc_insertion_point(field:SelectCommandRequest.state)
    pub state: ::std::string::String,
    // @@protoc_insertion_point(field:SelectCommandRequest.device_id)
    pub device_id: u32,
    // special fields
    // @@protoc_insertion_point(special_field:SelectCommandRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a SelectCommandRequest {
    fn default() -> &'a SelectCommandRequest {
        <SelectCommandRequest as ::protobuf::Message>::default_instance()
    }
}

impl SelectCommandRequest {
    pub fn new() -> SelectCommandRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "key",
            |m: &SelectCommandRequest| { &m.key },
            |m: &mut SelectCommandRequest| { &mut m.key },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "state",
            |m: &SelectCommandRequest| { &m.state },
            |m: &mut SelectCommandRequest| { &mut m.state },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "device_id",
            |m: &SelectCommandRequest| { &m.device_id },
            |m: &mut SelectCommandRequest| { &mut m.device_id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<SelectCommandRequest>(
            "SelectCommandRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for SelectCommandRequest {
    const NAME: &'static str = "SelectCommandRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                13 => {
                    self.key = is.read_fixed32()?;
                },
                18 => {
                    self.state = is.read_string()?;
                },
                24 => {
                    self.device_id = is.read_uint32()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.key != 0 {
            my_size += 1 + 4;
        }
        if !self.state.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.state);
        }
        if self.device_id != 0 {
            my_size += ::protobuf::rt::uint32_size(3, self.device_id);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.key != 0 {
            os.write_fixed32(1, self.key)?;
        }
        if !self.state.is_empty() {
            os.write_string(2, &self.state)?;
        }
        if self.device_id != 0 {
            os.write_uint32(3, self.device_id)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> SelectCommandRequest {
        SelectCommandRequest::new()
    }

    fn clear(&mut self) {
        self.key = 0;
        self.state.clear();
        self.device_id = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static SelectCommandRequest {
        static instance: SelectCommandRequest = SelectCommandRequest {
            key: 0,
            state: ::std::string::String::new(),
            device_id: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for SelectCommandRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("SelectCommandRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for SelectCommandRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SelectCommandRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:ListEntitiesSirenResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ListEntitiesSirenResponse {
    // message fields
    // @@protoc_insertion_point(field:ListEntitiesSirenResponse.object_id)
    pub object_id: ::std::string::String,
    // @@protoc_insertion_point(field:ListEntitiesSirenResponse.key)
    pub key: u32,
    // @@protoc_insertion_point(field:ListEntitiesSirenResponse.name)
    pub name: ::std::string::String,
    // @@protoc_insertion_point(field:ListEntitiesSirenResponse.unique_id)
    pub unique_id: ::std::string::String,
    // @@protoc_insertion_point(field:ListEntitiesSirenResponse.icon)
    pub icon: ::std::string::String,
    // @@protoc_insertion_point(field:ListEntitiesSirenResponse.disabled_by_default)
    pub disabled_by_default: bool,
    // @@protoc_insertion_point(field:ListEntitiesSirenResponse.tones)
    pub tones: ::std::vec::Vec<::std::string::String>,
    // @@protoc_insertion_point(field:ListEntitiesSirenResponse.supports_duration)
    pub supports_duration: bool,
    // @@protoc_insertion_point(field:ListEntitiesSirenResponse.supports_volume)
    pub supports_volume: bool,
    // @@protoc_insertion_point(field:ListEntitiesSirenResponse.entity_category)
    pub entity_category: ::protobuf::EnumOrUnknown<EntityCategory>,
    // @@protoc_insertion_point(field:ListEntitiesSirenResponse.device_id)
    pub device_id: u32,
    // special fields
    // @@protoc_insertion_point(special_field:ListEntitiesSirenResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ListEntitiesSirenResponse {
    fn default() -> &'a ListEntitiesSirenResponse {
        <ListEntitiesSirenResponse as ::protobuf::Message>::default_instance()
    }
}

impl ListEntitiesSirenResponse {
    pub fn new() -> ListEntitiesSirenResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(11);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "object_id",
            |m: &ListEntitiesSirenResponse| { &m.object_id },
            |m: &mut ListEntitiesSirenResponse| { &mut m.object_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "key",
            |m: &ListEntitiesSirenResponse| { &m.key },
            |m: &mut ListEntitiesSirenResponse| { &mut m.key },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "name",
            |m: &ListEntitiesSirenResponse| { &m.name },
            |m: &mut ListEntitiesSirenResponse| { &mut m.name },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "unique_id",
            |m: &ListEntitiesSirenResponse| { &m.unique_id },
            |m: &mut ListEntitiesSirenResponse| { &mut m.unique_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "icon",
            |m: &ListEntitiesSirenResponse| { &m.icon },
            |m: &mut ListEntitiesSirenResponse| { &mut m.icon },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "disabled_by_default",
            |m: &ListEntitiesSirenResponse| { &m.disabled_by_default },
            |m: &mut ListEntitiesSirenResponse| { &mut m.disabled_by_default },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "tones",
            |m: &ListEntitiesSirenResponse| { &m.tones },
            |m: &mut ListEntitiesSirenResponse| { &mut m.tones },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "supports_duration",
            |m: &ListEntitiesSirenResponse| { &m.supports_duration },
            |m: &mut ListEntitiesSirenResponse| { &mut m.supports_duration },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "supports_volume",
            |m: &ListEntitiesSirenResponse| { &m.supports_volume },
            |m: &mut ListEntitiesSirenResponse| { &mut m.supports_volume },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "entity_category",
            |m: &ListEntitiesSirenResponse| { &m.entity_category },
            |m: &mut ListEntitiesSirenResponse| { &mut m.entity_category },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "device_id",
            |m: &ListEntitiesSirenResponse| { &m.device_id },
            |m: &mut ListEntitiesSirenResponse| { &mut m.device_id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ListEntitiesSirenResponse>(
            "ListEntitiesSirenResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ListEntitiesSirenResponse {
    const NAME: &'static str = "ListEntitiesSirenResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.object_id = is.read_string()?;
                },
                21 => {
                    self.key = is.read_fixed32()?;
                },
                26 => {
                    self.name = is.read_string()?;
                },
                34 => {
                    self.unique_id = is.read_string()?;
                },
                42 => {
                    self.icon = is.read_string()?;
                },
                48 => {
                    self.disabled_by_default = is.read_bool()?;
                },
                58 => {
                    self.tones.push(is.read_string()?);
                },
                64 => {
                    self.supports_duration = is.read_bool()?;
                },
                72 => {
                    self.supports_volume = is.read_bool()?;
                },
                80 => {
                    self.entity_category = is.read_enum_or_unknown()?;
                },
                88 => {
                    self.device_id = is.read_uint32()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.object_id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.object_id);
        }
        if self.key != 0 {
            my_size += 1 + 4;
        }
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.name);
        }
        if !self.unique_id.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.unique_id);
        }
        if !self.icon.is_empty() {
            my_size += ::protobuf::rt::string_size(5, &self.icon);
        }
        if self.disabled_by_default != false {
            my_size += 1 + 1;
        }
        for value in &self.tones {
            my_size += ::protobuf::rt::string_size(7, &value);
        };
        if self.supports_duration != false {
            my_size += 1 + 1;
        }
        if self.supports_volume != false {
            my_size += 1 + 1;
        }
        if self.entity_category != ::protobuf::EnumOrUnknown::new(EntityCategory::ENTITY_CATEGORY_NONE) {
            my_size += ::protobuf::rt::int32_size(10, self.entity_category.value());
        }
        if self.device_id != 0 {
            my_size += ::protobuf::rt::uint32_size(11, self.device_id);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.object_id.is_empty() {
            os.write_string(1, &self.object_id)?;
        }
        if self.key != 0 {
            os.write_fixed32(2, self.key)?;
        }
        if !self.name.is_empty() {
            os.write_string(3, &self.name)?;
        }
        if !self.unique_id.is_empty() {
            os.write_string(4, &self.unique_id)?;
        }
        if !self.icon.is_empty() {
            os.write_string(5, &self.icon)?;
        }
        if self.disabled_by_default != false {
            os.write_bool(6, self.disabled_by_default)?;
        }
        for v in &self.tones {
            os.write_string(7, &v)?;
        };
        if self.supports_duration != false {
            os.write_bool(8, self.supports_duration)?;
        }
        if self.supports_volume != false {
            os.write_bool(9, self.supports_volume)?;
        }
        if self.entity_category != ::protobuf::EnumOrUnknown::new(EntityCategory::ENTITY_CATEGORY_NONE) {
            os.write_enum(10, ::protobuf::EnumOrUnknown::value(&self.entity_category))?;
        }
        if self.device_id != 0 {
            os.write_uint32(11, self.device_id)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ListEntitiesSirenResponse {
        ListEntitiesSirenResponse::new()
    }

    fn clear(&mut self) {
        self.object_id.clear();
        self.key = 0;
        self.name.clear();
        self.unique_id.clear();
        self.icon.clear();
        self.disabled_by_default = false;
        self.tones.clear();
        self.supports_duration = false;
        self.supports_volume = false;
        self.entity_category = ::protobuf::EnumOrUnknown::new(EntityCategory::ENTITY_CATEGORY_NONE);
        self.device_id = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ListEntitiesSirenResponse {
        static instance: ListEntitiesSirenResponse = ListEntitiesSirenResponse {
            object_id: ::std::string::String::new(),
            key: 0,
            name: ::std::string::String::new(),
            unique_id: ::std::string::String::new(),
            icon: ::std::string::String::new(),
            disabled_by_default: false,
            tones: ::std::vec::Vec::new(),
            supports_duration: false,
            supports_volume: false,
            entity_category: ::protobuf::EnumOrUnknown::from_i32(0),
            device_id: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ListEntitiesSirenResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ListEntitiesSirenResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ListEntitiesSirenResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ListEntitiesSirenResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:SirenStateResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct SirenStateResponse {
    // message fields
    // @@protoc_insertion_point(field:SirenStateResponse.key)
    pub key: u32,
    // @@protoc_insertion_point(field:SirenStateResponse.state)
    pub state: bool,
    // @@protoc_insertion_point(field:SirenStateResponse.device_id)
    pub device_id: u32,
    // special fields
    // @@protoc_insertion_point(special_field:SirenStateResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a SirenStateResponse {
    fn default() -> &'a SirenStateResponse {
        <SirenStateResponse as ::protobuf::Message>::default_instance()
    }
}

impl SirenStateResponse {
    pub fn new() -> SirenStateResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "key",
            |m: &SirenStateResponse| { &m.key },
            |m: &mut SirenStateResponse| { &mut m.key },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "state",
            |m: &SirenStateResponse| { &m.state },
            |m: &mut SirenStateResponse| { &mut m.state },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "device_id",
            |m: &SirenStateResponse| { &m.device_id },
            |m: &mut SirenStateResponse| { &mut m.device_id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<SirenStateResponse>(
            "SirenStateResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for SirenStateResponse {
    const NAME: &'static str = "SirenStateResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                13 => {
                    self.key = is.read_fixed32()?;
                },
                16 => {
                    self.state = is.read_bool()?;
                },
                24 => {
                    self.device_id = is.read_uint32()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.key != 0 {
            my_size += 1 + 4;
        }
        if self.state != false {
            my_size += 1 + 1;
        }
        if self.device_id != 0 {
            my_size += ::protobuf::rt::uint32_size(3, self.device_id);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.key != 0 {
            os.write_fixed32(1, self.key)?;
        }
        if self.state != false {
            os.write_bool(2, self.state)?;
        }
        if self.device_id != 0 {
            os.write_uint32(3, self.device_id)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> SirenStateResponse {
        SirenStateResponse::new()
    }

    fn clear(&mut self) {
        self.key = 0;
        self.state = false;
        self.device_id = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static SirenStateResponse {
        static instance: SirenStateResponse = SirenStateResponse {
            key: 0,
            state: false,
            device_id: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for SirenStateResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("SirenStateResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for SirenStateResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SirenStateResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:SirenCommandRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct SirenCommandRequest {
    // message fields
    // @@protoc_insertion_point(field:SirenCommandRequest.key)
    pub key: u32,
    // @@protoc_insertion_point(field:SirenCommandRequest.has_state)
    pub has_state: bool,
    // @@protoc_insertion_point(field:SirenCommandRequest.state)
    pub state: bool,
    // @@protoc_insertion_point(field:SirenCommandRequest.has_tone)
    pub has_tone: bool,
    // @@protoc_insertion_point(field:SirenCommandRequest.tone)
    pub tone: ::std::string::String,
    // @@protoc_insertion_point(field:SirenCommandRequest.has_duration)
    pub has_duration: bool,
    // @@protoc_insertion_point(field:SirenCommandRequest.duration)
    pub duration: u32,
    // @@protoc_insertion_point(field:SirenCommandRequest.has_volume)
    pub has_volume: bool,
    // @@protoc_insertion_point(field:SirenCommandRequest.volume)
    pub volume: f32,
    // @@protoc_insertion_point(field:SirenCommandRequest.device_id)
    pub device_id: u32,
    // special fields
    // @@protoc_insertion_point(special_field:SirenCommandRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a SirenCommandRequest {
    fn default() -> &'a SirenCommandRequest {
        <SirenCommandRequest as ::protobuf::Message>::default_instance()
    }
}

impl SirenCommandRequest {
    pub fn new() -> SirenCommandRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(10);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "key",
            |m: &SirenCommandRequest| { &m.key },
            |m: &mut SirenCommandRequest| { &mut m.key },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "has_state",
            |m: &SirenCommandRequest| { &m.has_state },
            |m: &mut SirenCommandRequest| { &mut m.has_state },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "state",
            |m: &SirenCommandRequest| { &m.state },
            |m: &mut SirenCommandRequest| { &mut m.state },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "has_tone",
            |m: &SirenCommandRequest| { &m.has_tone },
            |m: &mut SirenCommandRequest| { &mut m.has_tone },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "tone",
            |m: &SirenCommandRequest| { &m.tone },
            |m: &mut SirenCommandRequest| { &mut m.tone },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "has_duration",
            |m: &SirenCommandRequest| { &m.has_duration },
            |m: &mut SirenCommandRequest| { &mut m.has_duration },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "duration",
            |m: &SirenCommandRequest| { &m.duration },
            |m: &mut SirenCommandRequest| { &mut m.duration },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "has_volume",
            |m: &SirenCommandRequest| { &m.has_volume },
            |m: &mut SirenCommandRequest| { &mut m.has_volume },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "volume",
            |m: &SirenCommandRequest| { &m.volume },
            |m: &mut SirenCommandRequest| { &mut m.volume },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "device_id",
            |m: &SirenCommandRequest| { &m.device_id },
            |m: &mut SirenCommandRequest| { &mut m.device_id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<SirenCommandRequest>(
            "SirenCommandRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for SirenCommandRequest {
    const NAME: &'static str = "SirenCommandRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                13 => {
                    self.key = is.read_fixed32()?;
                },
                16 => {
                    self.has_state = is.read_bool()?;
                },
                24 => {
                    self.state = is.read_bool()?;
                },
                32 => {
                    self.has_tone = is.read_bool()?;
                },
                42 => {
                    self.tone = is.read_string()?;
                },
                48 => {
                    self.has_duration = is.read_bool()?;
                },
                56 => {
                    self.duration = is.read_uint32()?;
                },
                64 => {
                    self.has_volume = is.read_bool()?;
                },
                77 => {
                    self.volume = is.read_float()?;
                },
                80 => {
                    self.device_id = is.read_uint32()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.key != 0 {
            my_size += 1 + 4;
        }
        if self.has_state != false {
            my_size += 1 + 1;
        }
        if self.state != false {
            my_size += 1 + 1;
        }
        if self.has_tone != false {
            my_size += 1 + 1;
        }
        if !self.tone.is_empty() {
            my_size += ::protobuf::rt::string_size(5, &self.tone);
        }
        if self.has_duration != false {
            my_size += 1 + 1;
        }
        if self.duration != 0 {
            my_size += ::protobuf::rt::uint32_size(7, self.duration);
        }
        if self.has_volume != false {
            my_size += 1 + 1;
        }
        if self.volume != 0. {
            my_size += 1 + 4;
        }
        if self.device_id != 0 {
            my_size += ::protobuf::rt::uint32_size(10, self.device_id);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.key != 0 {
            os.write_fixed32(1, self.key)?;
        }
        if self.has_state != false {
            os.write_bool(2, self.has_state)?;
        }
        if self.state != false {
            os.write_bool(3, self.state)?;
        }
        if self.has_tone != false {
            os.write_bool(4, self.has_tone)?;
        }
        if !self.tone.is_empty() {
            os.write_string(5, &self.tone)?;
        }
        if self.has_duration != false {
            os.write_bool(6, self.has_duration)?;
        }
        if self.duration != 0 {
            os.write_uint32(7, self.duration)?;
        }
        if self.has_volume != false {
            os.write_bool(8, self.has_volume)?;
        }
        if self.volume != 0. {
            os.write_float(9, self.volume)?;
        }
        if self.device_id != 0 {
            os.write_uint32(10, self.device_id)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> SirenCommandRequest {
        SirenCommandRequest::new()
    }

    fn clear(&mut self) {
        self.key = 0;
        self.has_state = false;
        self.state = false;
        self.has_tone = false;
        self.tone.clear();
        self.has_duration = false;
        self.duration = 0;
        self.has_volume = false;
        self.volume = 0.;
        self.device_id = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static SirenCommandRequest {
        static instance: SirenCommandRequest = SirenCommandRequest {
            key: 0,
            has_state: false,
            state: false,
            has_tone: false,
            tone: ::std::string::String::new(),
            has_duration: false,
            duration: 0,
            has_volume: false,
            volume: 0.,
            device_id: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for SirenCommandRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("SirenCommandRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for SirenCommandRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SirenCommandRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:ListEntitiesLockResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ListEntitiesLockResponse {
    // message fields
    // @@protoc_insertion_point(field:ListEntitiesLockResponse.object_id)
    pub object_id: ::std::string::String,
    // @@protoc_insertion_point(field:ListEntitiesLockResponse.key)
    pub key: u32,
    // @@protoc_insertion_point(field:ListEntitiesLockResponse.name)
    pub name: ::std::string::String,
    // @@protoc_insertion_point(field:ListEntitiesLockResponse.unique_id)
    pub unique_id: ::std::string::String,
    // @@protoc_insertion_point(field:ListEntitiesLockResponse.icon)
    pub icon: ::std::string::String,
    // @@protoc_insertion_point(field:ListEntitiesLockResponse.disabled_by_default)
    pub disabled_by_default: bool,
    // @@protoc_insertion_point(field:ListEntitiesLockResponse.entity_category)
    pub entity_category: ::protobuf::EnumOrUnknown<EntityCategory>,
    // @@protoc_insertion_point(field:ListEntitiesLockResponse.assumed_state)
    pub assumed_state: bool,
    // @@protoc_insertion_point(field:ListEntitiesLockResponse.supports_open)
    pub supports_open: bool,
    // @@protoc_insertion_point(field:ListEntitiesLockResponse.requires_code)
    pub requires_code: bool,
    // @@protoc_insertion_point(field:ListEntitiesLockResponse.code_format)
    pub code_format: ::std::string::String,
    // @@protoc_insertion_point(field:ListEntitiesLockResponse.device_id)
    pub device_id: u32,
    // special fields
    // @@protoc_insertion_point(special_field:ListEntitiesLockResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ListEntitiesLockResponse {
    fn default() -> &'a ListEntitiesLockResponse {
        <ListEntitiesLockResponse as ::protobuf::Message>::default_instance()
    }
}

impl ListEntitiesLockResponse {
    pub fn new() -> ListEntitiesLockResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(12);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "object_id",
            |m: &ListEntitiesLockResponse| { &m.object_id },
            |m: &mut ListEntitiesLockResponse| { &mut m.object_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "key",
            |m: &ListEntitiesLockResponse| { &m.key },
            |m: &mut ListEntitiesLockResponse| { &mut m.key },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "name",
            |m: &ListEntitiesLockResponse| { &m.name },
            |m: &mut ListEntitiesLockResponse| { &mut m.name },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "unique_id",
            |m: &ListEntitiesLockResponse| { &m.unique_id },
            |m: &mut ListEntitiesLockResponse| { &mut m.unique_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "icon",
            |m: &ListEntitiesLockResponse| { &m.icon },
            |m: &mut ListEntitiesLockResponse| { &mut m.icon },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "disabled_by_default",
            |m: &ListEntitiesLockResponse| { &m.disabled_by_default },
            |m: &mut ListEntitiesLockResponse| { &mut m.disabled_by_default },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "entity_category",
            |m: &ListEntitiesLockResponse| { &m.entity_category },
            |m: &mut ListEntitiesLockResponse| { &mut m.entity_category },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "assumed_state",
            |m: &ListEntitiesLockResponse| { &m.assumed_state },
            |m: &mut ListEntitiesLockResponse| { &mut m.assumed_state },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "supports_open",
            |m: &ListEntitiesLockResponse| { &m.supports_open },
            |m: &mut ListEntitiesLockResponse| { &mut m.supports_open },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "requires_code",
            |m: &ListEntitiesLockResponse| { &m.requires_code },
            |m: &mut ListEntitiesLockResponse| { &mut m.requires_code },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "code_format",
            |m: &ListEntitiesLockResponse| { &m.code_format },
            |m: &mut ListEntitiesLockResponse| { &mut m.code_format },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "device_id",
            |m: &ListEntitiesLockResponse| { &m.device_id },
            |m: &mut ListEntitiesLockResponse| { &mut m.device_id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ListEntitiesLockResponse>(
            "ListEntitiesLockResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ListEntitiesLockResponse {
    const NAME: &'static str = "ListEntitiesLockResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.object_id = is.read_string()?;
                },
                21 => {
                    self.key = is.read_fixed32()?;
                },
                26 => {
                    self.name = is.read_string()?;
                },
                34 => {
                    self.unique_id = is.read_string()?;
                },
                42 => {
                    self.icon = is.read_string()?;
                },
                48 => {
                    self.disabled_by_default = is.read_bool()?;
                },
                56 => {
                    self.entity_category = is.read_enum_or_unknown()?;
                },
                64 => {
                    self.assumed_state = is.read_bool()?;
                },
                72 => {
                    self.supports_open = is.read_bool()?;
                },
                80 => {
                    self.requires_code = is.read_bool()?;
                },
                90 => {
                    self.code_format = is.read_string()?;
                },
                96 => {
                    self.device_id = is.read_uint32()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.object_id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.object_id);
        }
        if self.key != 0 {
            my_size += 1 + 4;
        }
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.name);
        }
        if !self.unique_id.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.unique_id);
        }
        if !self.icon.is_empty() {
            my_size += ::protobuf::rt::string_size(5, &self.icon);
        }
        if self.disabled_by_default != false {
            my_size += 1 + 1;
        }
        if self.entity_category != ::protobuf::EnumOrUnknown::new(EntityCategory::ENTITY_CATEGORY_NONE) {
            my_size += ::protobuf::rt::int32_size(7, self.entity_category.value());
        }
        if self.assumed_state != false {
            my_size += 1 + 1;
        }
        if self.supports_open != false {
            my_size += 1 + 1;
        }
        if self.requires_code != false {
            my_size += 1 + 1;
        }
        if !self.code_format.is_empty() {
            my_size += ::protobuf::rt::string_size(11, &self.code_format);
        }
        if self.device_id != 0 {
            my_size += ::protobuf::rt::uint32_size(12, self.device_id);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.object_id.is_empty() {
            os.write_string(1, &self.object_id)?;
        }
        if self.key != 0 {
            os.write_fixed32(2, self.key)?;
        }
        if !self.name.is_empty() {
            os.write_string(3, &self.name)?;
        }
        if !self.unique_id.is_empty() {
            os.write_string(4, &self.unique_id)?;
        }
        if !self.icon.is_empty() {
            os.write_string(5, &self.icon)?;
        }
        if self.disabled_by_default != false {
            os.write_bool(6, self.disabled_by_default)?;
        }
        if self.entity_category != ::protobuf::EnumOrUnknown::new(EntityCategory::ENTITY_CATEGORY_NONE) {
            os.write_enum(7, ::protobuf::EnumOrUnknown::value(&self.entity_category))?;
        }
        if self.assumed_state != false {
            os.write_bool(8, self.assumed_state)?;
        }
        if self.supports_open != false {
            os.write_bool(9, self.supports_open)?;
        }
        if self.requires_code != false {
            os.write_bool(10, self.requires_code)?;
        }
        if !self.code_format.is_empty() {
            os.write_string(11, &self.code_format)?;
        }
        if self.device_id != 0 {
            os.write_uint32(12, self.device_id)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ListEntitiesLockResponse {
        ListEntitiesLockResponse::new()
    }

    fn clear(&mut self) {
        self.object_id.clear();
        self.key = 0;
        self.name.clear();
        self.unique_id.clear();
        self.icon.clear();
        self.disabled_by_default = false;
        self.entity_category = ::protobuf::EnumOrUnknown::new(EntityCategory::ENTITY_CATEGORY_NONE);
        self.assumed_state = false;
        self.supports_open = false;
        self.requires_code = false;
        self.code_format.clear();
        self.device_id = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ListEntitiesLockResponse {
        static instance: ListEntitiesLockResponse = ListEntitiesLockResponse {
            object_id: ::std::string::String::new(),
            key: 0,
            name: ::std::string::String::new(),
            unique_id: ::std::string::String::new(),
            icon: ::std::string::String::new(),
            disabled_by_default: false,
            entity_category: ::protobuf::EnumOrUnknown::from_i32(0),
            assumed_state: false,
            supports_open: false,
            requires_code: false,
            code_format: ::std::string::String::new(),
            device_id: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ListEntitiesLockResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ListEntitiesLockResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ListEntitiesLockResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ListEntitiesLockResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:LockStateResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct LockStateResponse {
    // message fields
    // @@protoc_insertion_point(field:LockStateResponse.key)
    pub key: u32,
    // @@protoc_insertion_point(field:LockStateResponse.state)
    pub state: ::protobuf::EnumOrUnknown<LockState>,
    // @@protoc_insertion_point(field:LockStateResponse.device_id)
    pub device_id: u32,
    // special fields
    // @@protoc_insertion_point(special_field:LockStateResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a LockStateResponse {
    fn default() -> &'a LockStateResponse {
        <LockStateResponse as ::protobuf::Message>::default_instance()
    }
}

impl LockStateResponse {
    pub fn new() -> LockStateResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "key",
            |m: &LockStateResponse| { &m.key },
            |m: &mut LockStateResponse| { &mut m.key },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "state",
            |m: &LockStateResponse| { &m.state },
            |m: &mut LockStateResponse| { &mut m.state },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "device_id",
            |m: &LockStateResponse| { &m.device_id },
            |m: &mut LockStateResponse| { &mut m.device_id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<LockStateResponse>(
            "LockStateResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for LockStateResponse {
    const NAME: &'static str = "LockStateResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                13 => {
                    self.key = is.read_fixed32()?;
                },
                16 => {
                    self.state = is.read_enum_or_unknown()?;
                },
                24 => {
                    self.device_id = is.read_uint32()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.key != 0 {
            my_size += 1 + 4;
        }
        if self.state != ::protobuf::EnumOrUnknown::new(LockState::LOCK_STATE_NONE) {
            my_size += ::protobuf::rt::int32_size(2, self.state.value());
        }
        if self.device_id != 0 {
            my_size += ::protobuf::rt::uint32_size(3, self.device_id);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.key != 0 {
            os.write_fixed32(1, self.key)?;
        }
        if self.state != ::protobuf::EnumOrUnknown::new(LockState::LOCK_STATE_NONE) {
            os.write_enum(2, ::protobuf::EnumOrUnknown::value(&self.state))?;
        }
        if self.device_id != 0 {
            os.write_uint32(3, self.device_id)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> LockStateResponse {
        LockStateResponse::new()
    }

    fn clear(&mut self) {
        self.key = 0;
        self.state = ::protobuf::EnumOrUnknown::new(LockState::LOCK_STATE_NONE);
        self.device_id = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static LockStateResponse {
        static instance: LockStateResponse = LockStateResponse {
            key: 0,
            state: ::protobuf::EnumOrUnknown::from_i32(0),
            device_id: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for LockStateResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("LockStateResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for LockStateResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for LockStateResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:LockCommandRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct LockCommandRequest {
    // message fields
    // @@protoc_insertion_point(field:LockCommandRequest.key)
    pub key: u32,
    // @@protoc_insertion_point(field:LockCommandRequest.command)
    pub command: ::protobuf::EnumOrUnknown<LockCommand>,
    // @@protoc_insertion_point(field:LockCommandRequest.has_code)
    pub has_code: bool,
    // @@protoc_insertion_point(field:LockCommandRequest.code)
    pub code: ::std::string::String,
    // @@protoc_insertion_point(field:LockCommandRequest.device_id)
    pub device_id: u32,
    // special fields
    // @@protoc_insertion_point(special_field:LockCommandRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a LockCommandRequest {
    fn default() -> &'a LockCommandRequest {
        <LockCommandRequest as ::protobuf::Message>::default_instance()
    }
}

impl LockCommandRequest {
    pub fn new() -> LockCommandRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(5);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "key",
            |m: &LockCommandRequest| { &m.key },
            |m: &mut LockCommandRequest| { &mut m.key },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "command",
            |m: &LockCommandRequest| { &m.command },
            |m: &mut LockCommandRequest| { &mut m.command },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "has_code",
            |m: &LockCommandRequest| { &m.has_code },
            |m: &mut LockCommandRequest| { &mut m.has_code },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "code",
            |m: &LockCommandRequest| { &m.code },
            |m: &mut LockCommandRequest| { &mut m.code },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "device_id",
            |m: &LockCommandRequest| { &m.device_id },
            |m: &mut LockCommandRequest| { &mut m.device_id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<LockCommandRequest>(
            "LockCommandRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for LockCommandRequest {
    const NAME: &'static str = "LockCommandRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                13 => {
                    self.key = is.read_fixed32()?;
                },
                16 => {
                    self.command = is.read_enum_or_unknown()?;
                },
                24 => {
                    self.has_code = is.read_bool()?;
                },
                34 => {
                    self.code = is.read_string()?;
                },
                40 => {
                    self.device_id = is.read_uint32()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.key != 0 {
            my_size += 1 + 4;
        }
        if self.command != ::protobuf::EnumOrUnknown::new(LockCommand::LOCK_UNLOCK) {
            my_size += ::protobuf::rt::int32_size(2, self.command.value());
        }
        if self.has_code != false {
            my_size += 1 + 1;
        }
        if !self.code.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.code);
        }
        if self.device_id != 0 {
            my_size += ::protobuf::rt::uint32_size(5, self.device_id);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.key != 0 {
            os.write_fixed32(1, self.key)?;
        }
        if self.command != ::protobuf::EnumOrUnknown::new(LockCommand::LOCK_UNLOCK) {
            os.write_enum(2, ::protobuf::EnumOrUnknown::value(&self.command))?;
        }
        if self.has_code != false {
            os.write_bool(3, self.has_code)?;
        }
        if !self.code.is_empty() {
            os.write_string(4, &self.code)?;
        }
        if self.device_id != 0 {
            os.write_uint32(5, self.device_id)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> LockCommandRequest {
        LockCommandRequest::new()
    }

    fn clear(&mut self) {
        self.key = 0;
        self.command = ::protobuf::EnumOrUnknown::new(LockCommand::LOCK_UNLOCK);
        self.has_code = false;
        self.code.clear();
        self.device_id = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static LockCommandRequest {
        static instance: LockCommandRequest = LockCommandRequest {
            key: 0,
            command: ::protobuf::EnumOrUnknown::from_i32(0),
            has_code: false,
            code: ::std::string::String::new(),
            device_id: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for LockCommandRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("LockCommandRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for LockCommandRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for LockCommandRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:ListEntitiesButtonResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ListEntitiesButtonResponse {
    // message fields
    // @@protoc_insertion_point(field:ListEntitiesButtonResponse.object_id)
    pub object_id: ::std::string::String,
    // @@protoc_insertion_point(field:ListEntitiesButtonResponse.key)
    pub key: u32,
    // @@protoc_insertion_point(field:ListEntitiesButtonResponse.name)
    pub name: ::std::string::String,
    // @@protoc_insertion_point(field:ListEntitiesButtonResponse.unique_id)
    pub unique_id: ::std::string::String,
    // @@protoc_insertion_point(field:ListEntitiesButtonResponse.icon)
    pub icon: ::std::string::String,
    // @@protoc_insertion_point(field:ListEntitiesButtonResponse.disabled_by_default)
    pub disabled_by_default: bool,
    // @@protoc_insertion_point(field:ListEntitiesButtonResponse.entity_category)
    pub entity_category: ::protobuf::EnumOrUnknown<EntityCategory>,
    // @@protoc_insertion_point(field:ListEntitiesButtonResponse.device_class)
    pub device_class: ::std::string::String,
    // @@protoc_insertion_point(field:ListEntitiesButtonResponse.device_id)
    pub device_id: u32,
    // special fields
    // @@protoc_insertion_point(special_field:ListEntitiesButtonResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ListEntitiesButtonResponse {
    fn default() -> &'a ListEntitiesButtonResponse {
        <ListEntitiesButtonResponse as ::protobuf::Message>::default_instance()
    }
}

impl ListEntitiesButtonResponse {
    pub fn new() -> ListEntitiesButtonResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(9);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "object_id",
            |m: &ListEntitiesButtonResponse| { &m.object_id },
            |m: &mut ListEntitiesButtonResponse| { &mut m.object_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "key",
            |m: &ListEntitiesButtonResponse| { &m.key },
            |m: &mut ListEntitiesButtonResponse| { &mut m.key },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "name",
            |m: &ListEntitiesButtonResponse| { &m.name },
            |m: &mut ListEntitiesButtonResponse| { &mut m.name },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "unique_id",
            |m: &ListEntitiesButtonResponse| { &m.unique_id },
            |m: &mut ListEntitiesButtonResponse| { &mut m.unique_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "icon",
            |m: &ListEntitiesButtonResponse| { &m.icon },
            |m: &mut ListEntitiesButtonResponse| { &mut m.icon },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "disabled_by_default",
            |m: &ListEntitiesButtonResponse| { &m.disabled_by_default },
            |m: &mut ListEntitiesButtonResponse| { &mut m.disabled_by_default },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "entity_category",
            |m: &ListEntitiesButtonResponse| { &m.entity_category },
            |m: &mut ListEntitiesButtonResponse| { &mut m.entity_category },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "device_class",
            |m: &ListEntitiesButtonResponse| { &m.device_class },
            |m: &mut ListEntitiesButtonResponse| { &mut m.device_class },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "device_id",
            |m: &ListEntitiesButtonResponse| { &m.device_id },
            |m: &mut ListEntitiesButtonResponse| { &mut m.device_id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ListEntitiesButtonResponse>(
            "ListEntitiesButtonResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ListEntitiesButtonResponse {
    const NAME: &'static str = "ListEntitiesButtonResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.object_id = is.read_string()?;
                },
                21 => {
                    self.key = is.read_fixed32()?;
                },
                26 => {
                    self.name = is.read_string()?;
                },
                34 => {
                    self.unique_id = is.read_string()?;
                },
                42 => {
                    self.icon = is.read_string()?;
                },
                48 => {
                    self.disabled_by_default = is.read_bool()?;
                },
                56 => {
                    self.entity_category = is.read_enum_or_unknown()?;
                },
                66 => {
                    self.device_class = is.read_string()?;
                },
                72 => {
                    self.device_id = is.read_uint32()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.object_id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.object_id);
        }
        if self.key != 0 {
            my_size += 1 + 4;
        }
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.name);
        }
        if !self.unique_id.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.unique_id);
        }
        if !self.icon.is_empty() {
            my_size += ::protobuf::rt::string_size(5, &self.icon);
        }
        if self.disabled_by_default != false {
            my_size += 1 + 1;
        }
        if self.entity_category != ::protobuf::EnumOrUnknown::new(EntityCategory::ENTITY_CATEGORY_NONE) {
            my_size += ::protobuf::rt::int32_size(7, self.entity_category.value());
        }
        if !self.device_class.is_empty() {
            my_size += ::protobuf::rt::string_size(8, &self.device_class);
        }
        if self.device_id != 0 {
            my_size += ::protobuf::rt::uint32_size(9, self.device_id);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.object_id.is_empty() {
            os.write_string(1, &self.object_id)?;
        }
        if self.key != 0 {
            os.write_fixed32(2, self.key)?;
        }
        if !self.name.is_empty() {
            os.write_string(3, &self.name)?;
        }
        if !self.unique_id.is_empty() {
            os.write_string(4, &self.unique_id)?;
        }
        if !self.icon.is_empty() {
            os.write_string(5, &self.icon)?;
        }
        if self.disabled_by_default != false {
            os.write_bool(6, self.disabled_by_default)?;
        }
        if self.entity_category != ::protobuf::EnumOrUnknown::new(EntityCategory::ENTITY_CATEGORY_NONE) {
            os.write_enum(7, ::protobuf::EnumOrUnknown::value(&self.entity_category))?;
        }
        if !self.device_class.is_empty() {
            os.write_string(8, &self.device_class)?;
        }
        if self.device_id != 0 {
            os.write_uint32(9, self.device_id)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ListEntitiesButtonResponse {
        ListEntitiesButtonResponse::new()
    }

    fn clear(&mut self) {
        self.object_id.clear();
        self.key = 0;
        self.name.clear();
        self.unique_id.clear();
        self.icon.clear();
        self.disabled_by_default = false;
        self.entity_category = ::protobuf::EnumOrUnknown::new(EntityCategory::ENTITY_CATEGORY_NONE);
        self.device_class.clear();
        self.device_id = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ListEntitiesButtonResponse {
        static instance: ListEntitiesButtonResponse = ListEntitiesButtonResponse {
            object_id: ::std::string::String::new(),
            key: 0,
            name: ::std::string::String::new(),
            unique_id: ::std::string::String::new(),
            icon: ::std::string::String::new(),
            disabled_by_default: false,
            entity_category: ::protobuf::EnumOrUnknown::from_i32(0),
            device_class: ::std::string::String::new(),
            device_id: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ListEntitiesButtonResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ListEntitiesButtonResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ListEntitiesButtonResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ListEntitiesButtonResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:ButtonCommandRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ButtonCommandRequest {
    // message fields
    // @@protoc_insertion_point(field:ButtonCommandRequest.key)
    pub key: u32,
    // @@protoc_insertion_point(field:ButtonCommandRequest.device_id)
    pub device_id: u32,
    // special fields
    // @@protoc_insertion_point(special_field:ButtonCommandRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ButtonCommandRequest {
    fn default() -> &'a ButtonCommandRequest {
        <ButtonCommandRequest as ::protobuf::Message>::default_instance()
    }
}

impl ButtonCommandRequest {
    pub fn new() -> ButtonCommandRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "key",
            |m: &ButtonCommandRequest| { &m.key },
            |m: &mut ButtonCommandRequest| { &mut m.key },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "device_id",
            |m: &ButtonCommandRequest| { &m.device_id },
            |m: &mut ButtonCommandRequest| { &mut m.device_id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ButtonCommandRequest>(
            "ButtonCommandRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ButtonCommandRequest {
    const NAME: &'static str = "ButtonCommandRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                13 => {
                    self.key = is.read_fixed32()?;
                },
                16 => {
                    self.device_id = is.read_uint32()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.key != 0 {
            my_size += 1 + 4;
        }
        if self.device_id != 0 {
            my_size += ::protobuf::rt::uint32_size(2, self.device_id);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.key != 0 {
            os.write_fixed32(1, self.key)?;
        }
        if self.device_id != 0 {
            os.write_uint32(2, self.device_id)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ButtonCommandRequest {
        ButtonCommandRequest::new()
    }

    fn clear(&mut self) {
        self.key = 0;
        self.device_id = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ButtonCommandRequest {
        static instance: ButtonCommandRequest = ButtonCommandRequest {
            key: 0,
            device_id: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ButtonCommandRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ButtonCommandRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ButtonCommandRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ButtonCommandRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:MediaPlayerSupportedFormat)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct MediaPlayerSupportedFormat {
    // message fields
    // @@protoc_insertion_point(field:MediaPlayerSupportedFormat.format)
    pub format: ::std::string::String,
    // @@protoc_insertion_point(field:MediaPlayerSupportedFormat.sample_rate)
    pub sample_rate: u32,
    // @@protoc_insertion_point(field:MediaPlayerSupportedFormat.num_channels)
    pub num_channels: u32,
    // @@protoc_insertion_point(field:MediaPlayerSupportedFormat.purpose)
    pub purpose: ::protobuf::EnumOrUnknown<MediaPlayerFormatPurpose>,
    // @@protoc_insertion_point(field:MediaPlayerSupportedFormat.sample_bytes)
    pub sample_bytes: u32,
    // special fields
    // @@protoc_insertion_point(special_field:MediaPlayerSupportedFormat.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a MediaPlayerSupportedFormat {
    fn default() -> &'a MediaPlayerSupportedFormat {
        <MediaPlayerSupportedFormat as ::protobuf::Message>::default_instance()
    }
}

impl MediaPlayerSupportedFormat {
    pub fn new() -> MediaPlayerSupportedFormat {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(5);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "format",
            |m: &MediaPlayerSupportedFormat| { &m.format },
            |m: &mut MediaPlayerSupportedFormat| { &mut m.format },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "sample_rate",
            |m: &MediaPlayerSupportedFormat| { &m.sample_rate },
            |m: &mut MediaPlayerSupportedFormat| { &mut m.sample_rate },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "num_channels",
            |m: &MediaPlayerSupportedFormat| { &m.num_channels },
            |m: &mut MediaPlayerSupportedFormat| { &mut m.num_channels },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "purpose",
            |m: &MediaPlayerSupportedFormat| { &m.purpose },
            |m: &mut MediaPlayerSupportedFormat| { &mut m.purpose },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "sample_bytes",
            |m: &MediaPlayerSupportedFormat| { &m.sample_bytes },
            |m: &mut MediaPlayerSupportedFormat| { &mut m.sample_bytes },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<MediaPlayerSupportedFormat>(
            "MediaPlayerSupportedFormat",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for MediaPlayerSupportedFormat {
    const NAME: &'static str = "MediaPlayerSupportedFormat";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.format = is.read_string()?;
                },
                16 => {
                    self.sample_rate = is.read_uint32()?;
                },
                24 => {
                    self.num_channels = is.read_uint32()?;
                },
                32 => {
                    self.purpose = is.read_enum_or_unknown()?;
                },
                40 => {
                    self.sample_bytes = is.read_uint32()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.format.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.format);
        }
        if self.sample_rate != 0 {
            my_size += ::protobuf::rt::uint32_size(2, self.sample_rate);
        }
        if self.num_channels != 0 {
            my_size += ::protobuf::rt::uint32_size(3, self.num_channels);
        }
        if self.purpose != ::protobuf::EnumOrUnknown::new(MediaPlayerFormatPurpose::MEDIA_PLAYER_FORMAT_PURPOSE_DEFAULT) {
            my_size += ::protobuf::rt::int32_size(4, self.purpose.value());
        }
        if self.sample_bytes != 0 {
            my_size += ::protobuf::rt::uint32_size(5, self.sample_bytes);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.format.is_empty() {
            os.write_string(1, &self.format)?;
        }
        if self.sample_rate != 0 {
            os.write_uint32(2, self.sample_rate)?;
        }
        if self.num_channels != 0 {
            os.write_uint32(3, self.num_channels)?;
        }
        if self.purpose != ::protobuf::EnumOrUnknown::new(MediaPlayerFormatPurpose::MEDIA_PLAYER_FORMAT_PURPOSE_DEFAULT) {
            os.write_enum(4, ::protobuf::EnumOrUnknown::value(&self.purpose))?;
        }
        if self.sample_bytes != 0 {
            os.write_uint32(5, self.sample_bytes)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> MediaPlayerSupportedFormat {
        MediaPlayerSupportedFormat::new()
    }

    fn clear(&mut self) {
        self.format.clear();
        self.sample_rate = 0;
        self.num_channels = 0;
        self.purpose = ::protobuf::EnumOrUnknown::new(MediaPlayerFormatPurpose::MEDIA_PLAYER_FORMAT_PURPOSE_DEFAULT);
        self.sample_bytes = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static MediaPlayerSupportedFormat {
        static instance: MediaPlayerSupportedFormat = MediaPlayerSupportedFormat {
            format: ::std::string::String::new(),
            sample_rate: 0,
            num_channels: 0,
            purpose: ::protobuf::EnumOrUnknown::from_i32(0),
            sample_bytes: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for MediaPlayerSupportedFormat {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("MediaPlayerSupportedFormat").unwrap()).clone()
    }
}

impl ::std::fmt::Display for MediaPlayerSupportedFormat {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MediaPlayerSupportedFormat {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:ListEntitiesMediaPlayerResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ListEntitiesMediaPlayerResponse {
    // message fields
    // @@protoc_insertion_point(field:ListEntitiesMediaPlayerResponse.object_id)
    pub object_id: ::std::string::String,
    // @@protoc_insertion_point(field:ListEntitiesMediaPlayerResponse.key)
    pub key: u32,
    // @@protoc_insertion_point(field:ListEntitiesMediaPlayerResponse.name)
    pub name: ::std::string::String,
    // @@protoc_insertion_point(field:ListEntitiesMediaPlayerResponse.unique_id)
    pub unique_id: ::std::string::String,
    // @@protoc_insertion_point(field:ListEntitiesMediaPlayerResponse.icon)
    pub icon: ::std::string::String,
    // @@protoc_insertion_point(field:ListEntitiesMediaPlayerResponse.disabled_by_default)
    pub disabled_by_default: bool,
    // @@protoc_insertion_point(field:ListEntitiesMediaPlayerResponse.entity_category)
    pub entity_category: ::protobuf::EnumOrUnknown<EntityCategory>,
    // @@protoc_insertion_point(field:ListEntitiesMediaPlayerResponse.supports_pause)
    pub supports_pause: bool,
    // @@protoc_insertion_point(field:ListEntitiesMediaPlayerResponse.supported_formats)
    pub supported_formats: ::std::vec::Vec<MediaPlayerSupportedFormat>,
    // @@protoc_insertion_point(field:ListEntitiesMediaPlayerResponse.device_id)
    pub device_id: u32,
    // special fields
    // @@protoc_insertion_point(special_field:ListEntitiesMediaPlayerResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ListEntitiesMediaPlayerResponse {
    fn default() -> &'a ListEntitiesMediaPlayerResponse {
        <ListEntitiesMediaPlayerResponse as ::protobuf::Message>::default_instance()
    }
}

impl ListEntitiesMediaPlayerResponse {
    pub fn new() -> ListEntitiesMediaPlayerResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(10);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "object_id",
            |m: &ListEntitiesMediaPlayerResponse| { &m.object_id },
            |m: &mut ListEntitiesMediaPlayerResponse| { &mut m.object_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "key",
            |m: &ListEntitiesMediaPlayerResponse| { &m.key },
            |m: &mut ListEntitiesMediaPlayerResponse| { &mut m.key },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "name",
            |m: &ListEntitiesMediaPlayerResponse| { &m.name },
            |m: &mut ListEntitiesMediaPlayerResponse| { &mut m.name },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "unique_id",
            |m: &ListEntitiesMediaPlayerResponse| { &m.unique_id },
            |m: &mut ListEntitiesMediaPlayerResponse| { &mut m.unique_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "icon",
            |m: &ListEntitiesMediaPlayerResponse| { &m.icon },
            |m: &mut ListEntitiesMediaPlayerResponse| { &mut m.icon },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "disabled_by_default",
            |m: &ListEntitiesMediaPlayerResponse| { &m.disabled_by_default },
            |m: &mut ListEntitiesMediaPlayerResponse| { &mut m.disabled_by_default },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "entity_category",
            |m: &ListEntitiesMediaPlayerResponse| { &m.entity_category },
            |m: &mut ListEntitiesMediaPlayerResponse| { &mut m.entity_category },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "supports_pause",
            |m: &ListEntitiesMediaPlayerResponse| { &m.supports_pause },
            |m: &mut ListEntitiesMediaPlayerResponse| { &mut m.supports_pause },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "supported_formats",
            |m: &ListEntitiesMediaPlayerResponse| { &m.supported_formats },
            |m: &mut ListEntitiesMediaPlayerResponse| { &mut m.supported_formats },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "device_id",
            |m: &ListEntitiesMediaPlayerResponse| { &m.device_id },
            |m: &mut ListEntitiesMediaPlayerResponse| { &mut m.device_id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ListEntitiesMediaPlayerResponse>(
            "ListEntitiesMediaPlayerResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ListEntitiesMediaPlayerResponse {
    const NAME: &'static str = "ListEntitiesMediaPlayerResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.object_id = is.read_string()?;
                },
                21 => {
                    self.key = is.read_fixed32()?;
                },
                26 => {
                    self.name = is.read_string()?;
                },
                34 => {
                    self.unique_id = is.read_string()?;
                },
                42 => {
                    self.icon = is.read_string()?;
                },
                48 => {
                    self.disabled_by_default = is.read_bool()?;
                },
                56 => {
                    self.entity_category = is.read_enum_or_unknown()?;
                },
                64 => {
                    self.supports_pause = is.read_bool()?;
                },
                74 => {
                    self.supported_formats.push(is.read_message()?);
                },
                80 => {
                    self.device_id = is.read_uint32()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.object_id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.object_id);
        }
        if self.key != 0 {
            my_size += 1 + 4;
        }
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.name);
        }
        if !self.unique_id.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.unique_id);
        }
        if !self.icon.is_empty() {
            my_size += ::protobuf::rt::string_size(5, &self.icon);
        }
        if self.disabled_by_default != false {
            my_size += 1 + 1;
        }
        if self.entity_category != ::protobuf::EnumOrUnknown::new(EntityCategory::ENTITY_CATEGORY_NONE) {
            my_size += ::protobuf::rt::int32_size(7, self.entity_category.value());
        }
        if self.supports_pause != false {
            my_size += 1 + 1;
        }
        for value in &self.supported_formats {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if self.device_id != 0 {
            my_size += ::protobuf::rt::uint32_size(10, self.device_id);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.object_id.is_empty() {
            os.write_string(1, &self.object_id)?;
        }
        if self.key != 0 {
            os.write_fixed32(2, self.key)?;
        }
        if !self.name.is_empty() {
            os.write_string(3, &self.name)?;
        }
        if !self.unique_id.is_empty() {
            os.write_string(4, &self.unique_id)?;
        }
        if !self.icon.is_empty() {
            os.write_string(5, &self.icon)?;
        }
        if self.disabled_by_default != false {
            os.write_bool(6, self.disabled_by_default)?;
        }
        if self.entity_category != ::protobuf::EnumOrUnknown::new(EntityCategory::ENTITY_CATEGORY_NONE) {
            os.write_enum(7, ::protobuf::EnumOrUnknown::value(&self.entity_category))?;
        }
        if self.supports_pause != false {
            os.write_bool(8, self.supports_pause)?;
        }
        for v in &self.supported_formats {
            ::protobuf::rt::write_message_field_with_cached_size(9, v, os)?;
        };
        if self.device_id != 0 {
            os.write_uint32(10, self.device_id)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ListEntitiesMediaPlayerResponse {
        ListEntitiesMediaPlayerResponse::new()
    }

    fn clear(&mut self) {
        self.object_id.clear();
        self.key = 0;
        self.name.clear();
        self.unique_id.clear();
        self.icon.clear();
        self.disabled_by_default = false;
        self.entity_category = ::protobuf::EnumOrUnknown::new(EntityCategory::ENTITY_CATEGORY_NONE);
        self.supports_pause = false;
        self.supported_formats.clear();
        self.device_id = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ListEntitiesMediaPlayerResponse {
        static instance: ListEntitiesMediaPlayerResponse = ListEntitiesMediaPlayerResponse {
            object_id: ::std::string::String::new(),
            key: 0,
            name: ::std::string::String::new(),
            unique_id: ::std::string::String::new(),
            icon: ::std::string::String::new(),
            disabled_by_default: false,
            entity_category: ::protobuf::EnumOrUnknown::from_i32(0),
            supports_pause: false,
            supported_formats: ::std::vec::Vec::new(),
            device_id: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ListEntitiesMediaPlayerResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ListEntitiesMediaPlayerResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ListEntitiesMediaPlayerResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ListEntitiesMediaPlayerResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:MediaPlayerStateResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct MediaPlayerStateResponse {
    // message fields
    // @@protoc_insertion_point(field:MediaPlayerStateResponse.key)
    pub key: u32,
    // @@protoc_insertion_point(field:MediaPlayerStateResponse.state)
    pub state: ::protobuf::EnumOrUnknown<MediaPlayerState>,
    // @@protoc_insertion_point(field:MediaPlayerStateResponse.volume)
    pub volume: f32,
    // @@protoc_insertion_point(field:MediaPlayerStateResponse.muted)
    pub muted: bool,
    // @@protoc_insertion_point(field:MediaPlayerStateResponse.device_id)
    pub device_id: u32,
    // special fields
    // @@protoc_insertion_point(special_field:MediaPlayerStateResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a MediaPlayerStateResponse {
    fn default() -> &'a MediaPlayerStateResponse {
        <MediaPlayerStateResponse as ::protobuf::Message>::default_instance()
    }
}

impl MediaPlayerStateResponse {
    pub fn new() -> MediaPlayerStateResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(5);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "key",
            |m: &MediaPlayerStateResponse| { &m.key },
            |m: &mut MediaPlayerStateResponse| { &mut m.key },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "state",
            |m: &MediaPlayerStateResponse| { &m.state },
            |m: &mut MediaPlayerStateResponse| { &mut m.state },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "volume",
            |m: &MediaPlayerStateResponse| { &m.volume },
            |m: &mut MediaPlayerStateResponse| { &mut m.volume },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "muted",
            |m: &MediaPlayerStateResponse| { &m.muted },
            |m: &mut MediaPlayerStateResponse| { &mut m.muted },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "device_id",
            |m: &MediaPlayerStateResponse| { &m.device_id },
            |m: &mut MediaPlayerStateResponse| { &mut m.device_id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<MediaPlayerStateResponse>(
            "MediaPlayerStateResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for MediaPlayerStateResponse {
    const NAME: &'static str = "MediaPlayerStateResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                13 => {
                    self.key = is.read_fixed32()?;
                },
                16 => {
                    self.state = is.read_enum_or_unknown()?;
                },
                29 => {
                    self.volume = is.read_float()?;
                },
                32 => {
                    self.muted = is.read_bool()?;
                },
                40 => {
                    self.device_id = is.read_uint32()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.key != 0 {
            my_size += 1 + 4;
        }
        if self.state != ::protobuf::EnumOrUnknown::new(MediaPlayerState::MEDIA_PLAYER_STATE_NONE) {
            my_size += ::protobuf::rt::int32_size(2, self.state.value());
        }
        if self.volume != 0. {
            my_size += 1 + 4;
        }
        if self.muted != false {
            my_size += 1 + 1;
        }
        if self.device_id != 0 {
            my_size += ::protobuf::rt::uint32_size(5, self.device_id);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.key != 0 {
            os.write_fixed32(1, self.key)?;
        }
        if self.state != ::protobuf::EnumOrUnknown::new(MediaPlayerState::MEDIA_PLAYER_STATE_NONE) {
            os.write_enum(2, ::protobuf::EnumOrUnknown::value(&self.state))?;
        }
        if self.volume != 0. {
            os.write_float(3, self.volume)?;
        }
        if self.muted != false {
            os.write_bool(4, self.muted)?;
        }
        if self.device_id != 0 {
            os.write_uint32(5, self.device_id)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> MediaPlayerStateResponse {
        MediaPlayerStateResponse::new()
    }

    fn clear(&mut self) {
        self.key = 0;
        self.state = ::protobuf::EnumOrUnknown::new(MediaPlayerState::MEDIA_PLAYER_STATE_NONE);
        self.volume = 0.;
        self.muted = false;
        self.device_id = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static MediaPlayerStateResponse {
        static instance: MediaPlayerStateResponse = MediaPlayerStateResponse {
            key: 0,
            state: ::protobuf::EnumOrUnknown::from_i32(0),
            volume: 0.,
            muted: false,
            device_id: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for MediaPlayerStateResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("MediaPlayerStateResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for MediaPlayerStateResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MediaPlayerStateResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:MediaPlayerCommandRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct MediaPlayerCommandRequest {
    // message fields
    // @@protoc_insertion_point(field:MediaPlayerCommandRequest.key)
    pub key: u32,
    // @@protoc_insertion_point(field:MediaPlayerCommandRequest.has_command)
    pub has_command: bool,
    // @@protoc_insertion_point(field:MediaPlayerCommandRequest.command)
    pub command: ::protobuf::EnumOrUnknown<MediaPlayerCommand>,
    // @@protoc_insertion_point(field:MediaPlayerCommandRequest.has_volume)
    pub has_volume: bool,
    // @@protoc_insertion_point(field:MediaPlayerCommandRequest.volume)
    pub volume: f32,
    // @@protoc_insertion_point(field:MediaPlayerCommandRequest.has_media_url)
    pub has_media_url: bool,
    // @@protoc_insertion_point(field:MediaPlayerCommandRequest.media_url)
    pub media_url: ::std::string::String,
    // @@protoc_insertion_point(field:MediaPlayerCommandRequest.has_announcement)
    pub has_announcement: bool,
    // @@protoc_insertion_point(field:MediaPlayerCommandRequest.announcement)
    pub announcement: bool,
    // @@protoc_insertion_point(field:MediaPlayerCommandRequest.device_id)
    pub device_id: u32,
    // special fields
    // @@protoc_insertion_point(special_field:MediaPlayerCommandRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a MediaPlayerCommandRequest {
    fn default() -> &'a MediaPlayerCommandRequest {
        <MediaPlayerCommandRequest as ::protobuf::Message>::default_instance()
    }
}

impl MediaPlayerCommandRequest {
    pub fn new() -> MediaPlayerCommandRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(10);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "key",
            |m: &MediaPlayerCommandRequest| { &m.key },
            |m: &mut MediaPlayerCommandRequest| { &mut m.key },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "has_command",
            |m: &MediaPlayerCommandRequest| { &m.has_command },
            |m: &mut MediaPlayerCommandRequest| { &mut m.has_command },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "command",
            |m: &MediaPlayerCommandRequest| { &m.command },
            |m: &mut MediaPlayerCommandRequest| { &mut m.command },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "has_volume",
            |m: &MediaPlayerCommandRequest| { &m.has_volume },
            |m: &mut MediaPlayerCommandRequest| { &mut m.has_volume },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "volume",
            |m: &MediaPlayerCommandRequest| { &m.volume },
            |m: &mut MediaPlayerCommandRequest| { &mut m.volume },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "has_media_url",
            |m: &MediaPlayerCommandRequest| { &m.has_media_url },
            |m: &mut MediaPlayerCommandRequest| { &mut m.has_media_url },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "media_url",
            |m: &MediaPlayerCommandRequest| { &m.media_url },
            |m: &mut MediaPlayerCommandRequest| { &mut m.media_url },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "has_announcement",
            |m: &MediaPlayerCommandRequest| { &m.has_announcement },
            |m: &mut MediaPlayerCommandRequest| { &mut m.has_announcement },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "announcement",
            |m: &MediaPlayerCommandRequest| { &m.announcement },
            |m: &mut MediaPlayerCommandRequest| { &mut m.announcement },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "device_id",
            |m: &MediaPlayerCommandRequest| { &m.device_id },
            |m: &mut MediaPlayerCommandRequest| { &mut m.device_id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<MediaPlayerCommandRequest>(
            "MediaPlayerCommandRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for MediaPlayerCommandRequest {
    const NAME: &'static str = "MediaPlayerCommandRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                13 => {
                    self.key = is.read_fixed32()?;
                },
                16 => {
                    self.has_command = is.read_bool()?;
                },
                24 => {
                    self.command = is.read_enum_or_unknown()?;
                },
                32 => {
                    self.has_volume = is.read_bool()?;
                },
                45 => {
                    self.volume = is.read_float()?;
                },
                48 => {
                    self.has_media_url = is.read_bool()?;
                },
                58 => {
                    self.media_url = is.read_string()?;
                },
                64 => {
                    self.has_announcement = is.read_bool()?;
                },
                72 => {
                    self.announcement = is.read_bool()?;
                },
                80 => {
                    self.device_id = is.read_uint32()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.key != 0 {
            my_size += 1 + 4;
        }
        if self.has_command != false {
            my_size += 1 + 1;
        }
        if self.command != ::protobuf::EnumOrUnknown::new(MediaPlayerCommand::MEDIA_PLAYER_COMMAND_PLAY) {
            my_size += ::protobuf::rt::int32_size(3, self.command.value());
        }
        if self.has_volume != false {
            my_size += 1 + 1;
        }
        if self.volume != 0. {
            my_size += 1 + 4;
        }
        if self.has_media_url != false {
            my_size += 1 + 1;
        }
        if !self.media_url.is_empty() {
            my_size += ::protobuf::rt::string_size(7, &self.media_url);
        }
        if self.has_announcement != false {
            my_size += 1 + 1;
        }
        if self.announcement != false {
            my_size += 1 + 1;
        }
        if self.device_id != 0 {
            my_size += ::protobuf::rt::uint32_size(10, self.device_id);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.key != 0 {
            os.write_fixed32(1, self.key)?;
        }
        if self.has_command != false {
            os.write_bool(2, self.has_command)?;
        }
        if self.command != ::protobuf::EnumOrUnknown::new(MediaPlayerCommand::MEDIA_PLAYER_COMMAND_PLAY) {
            os.write_enum(3, ::protobuf::EnumOrUnknown::value(&self.command))?;
        }
        if self.has_volume != false {
            os.write_bool(4, self.has_volume)?;
        }
        if self.volume != 0. {
            os.write_float(5, self.volume)?;
        }
        if self.has_media_url != false {
            os.write_bool(6, self.has_media_url)?;
        }
        if !self.media_url.is_empty() {
            os.write_string(7, &self.media_url)?;
        }
        if self.has_announcement != false {
            os.write_bool(8, self.has_announcement)?;
        }
        if self.announcement != false {
            os.write_bool(9, self.announcement)?;
        }
        if self.device_id != 0 {
            os.write_uint32(10, self.device_id)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> MediaPlayerCommandRequest {
        MediaPlayerCommandRequest::new()
    }

    fn clear(&mut self) {
        self.key = 0;
        self.has_command = false;
        self.command = ::protobuf::EnumOrUnknown::new(MediaPlayerCommand::MEDIA_PLAYER_COMMAND_PLAY);
        self.has_volume = false;
        self.volume = 0.;
        self.has_media_url = false;
        self.media_url.clear();
        self.has_announcement = false;
        self.announcement = false;
        self.device_id = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static MediaPlayerCommandRequest {
        static instance: MediaPlayerCommandRequest = MediaPlayerCommandRequest {
            key: 0,
            has_command: false,
            command: ::protobuf::EnumOrUnknown::from_i32(0),
            has_volume: false,
            volume: 0.,
            has_media_url: false,
            media_url: ::std::string::String::new(),
            has_announcement: false,
            announcement: false,
            device_id: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for MediaPlayerCommandRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("MediaPlayerCommandRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for MediaPlayerCommandRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for MediaPlayerCommandRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:SubscribeBluetoothLEAdvertisementsRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct SubscribeBluetoothLEAdvertisementsRequest {
    // message fields
    // @@protoc_insertion_point(field:SubscribeBluetoothLEAdvertisementsRequest.flags)
    pub flags: u32,
    // special fields
    // @@protoc_insertion_point(special_field:SubscribeBluetoothLEAdvertisementsRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a SubscribeBluetoothLEAdvertisementsRequest {
    fn default() -> &'a SubscribeBluetoothLEAdvertisementsRequest {
        <SubscribeBluetoothLEAdvertisementsRequest as ::protobuf::Message>::default_instance()
    }
}

impl SubscribeBluetoothLEAdvertisementsRequest {
    pub fn new() -> SubscribeBluetoothLEAdvertisementsRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "flags",
            |m: &SubscribeBluetoothLEAdvertisementsRequest| { &m.flags },
            |m: &mut SubscribeBluetoothLEAdvertisementsRequest| { &mut m.flags },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<SubscribeBluetoothLEAdvertisementsRequest>(
            "SubscribeBluetoothLEAdvertisementsRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for SubscribeBluetoothLEAdvertisementsRequest {
    const NAME: &'static str = "SubscribeBluetoothLEAdvertisementsRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.flags = is.read_uint32()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.flags != 0 {
            my_size += ::protobuf::rt::uint32_size(1, self.flags);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.flags != 0 {
            os.write_uint32(1, self.flags)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> SubscribeBluetoothLEAdvertisementsRequest {
        SubscribeBluetoothLEAdvertisementsRequest::new()
    }

    fn clear(&mut self) {
        self.flags = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static SubscribeBluetoothLEAdvertisementsRequest {
        static instance: SubscribeBluetoothLEAdvertisementsRequest = SubscribeBluetoothLEAdvertisementsRequest {
            flags: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for SubscribeBluetoothLEAdvertisementsRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("SubscribeBluetoothLEAdvertisementsRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for SubscribeBluetoothLEAdvertisementsRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SubscribeBluetoothLEAdvertisementsRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:BluetoothServiceData)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct BluetoothServiceData {
    // message fields
    // @@protoc_insertion_point(field:BluetoothServiceData.uuid)
    pub uuid: ::std::string::String,
    // @@protoc_insertion_point(field:BluetoothServiceData.legacy_data)
    pub legacy_data: ::std::vec::Vec<u32>,
    // @@protoc_insertion_point(field:BluetoothServiceData.data)
    pub data: ::std::vec::Vec<u8>,
    // special fields
    // @@protoc_insertion_point(special_field:BluetoothServiceData.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a BluetoothServiceData {
    fn default() -> &'a BluetoothServiceData {
        <BluetoothServiceData as ::protobuf::Message>::default_instance()
    }
}

impl BluetoothServiceData {
    pub fn new() -> BluetoothServiceData {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "uuid",
            |m: &BluetoothServiceData| { &m.uuid },
            |m: &mut BluetoothServiceData| { &mut m.uuid },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "legacy_data",
            |m: &BluetoothServiceData| { &m.legacy_data },
            |m: &mut BluetoothServiceData| { &mut m.legacy_data },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "data",
            |m: &BluetoothServiceData| { &m.data },
            |m: &mut BluetoothServiceData| { &mut m.data },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<BluetoothServiceData>(
            "BluetoothServiceData",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for BluetoothServiceData {
    const NAME: &'static str = "BluetoothServiceData";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.uuid = is.read_string()?;
                },
                18 => {
                    is.read_repeated_packed_uint32_into(&mut self.legacy_data)?;
                },
                16 => {
                    self.legacy_data.push(is.read_uint32()?);
                },
                26 => {
                    self.data = is.read_bytes()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.uuid.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.uuid);
        }
        my_size += ::protobuf::rt::vec_packed_uint32_size(2, &self.legacy_data);
        if !self.data.is_empty() {
            my_size += ::protobuf::rt::bytes_size(3, &self.data);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.uuid.is_empty() {
            os.write_string(1, &self.uuid)?;
        }
        os.write_repeated_packed_uint32(2, &self.legacy_data)?;
        if !self.data.is_empty() {
            os.write_bytes(3, &self.data)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> BluetoothServiceData {
        BluetoothServiceData::new()
    }

    fn clear(&mut self) {
        self.uuid.clear();
        self.legacy_data.clear();
        self.data.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static BluetoothServiceData {
        static instance: BluetoothServiceData = BluetoothServiceData {
            uuid: ::std::string::String::new(),
            legacy_data: ::std::vec::Vec::new(),
            data: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for BluetoothServiceData {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("BluetoothServiceData").unwrap()).clone()
    }
}

impl ::std::fmt::Display for BluetoothServiceData {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for BluetoothServiceData {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:BluetoothLEAdvertisementResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct BluetoothLEAdvertisementResponse {
    // message fields
    // @@protoc_insertion_point(field:BluetoothLEAdvertisementResponse.address)
    pub address: u64,
    // @@protoc_insertion_point(field:BluetoothLEAdvertisementResponse.name)
    pub name: ::std::vec::Vec<u8>,
    // @@protoc_insertion_point(field:BluetoothLEAdvertisementResponse.rssi)
    pub rssi: i32,
    // @@protoc_insertion_point(field:BluetoothLEAdvertisementResponse.service_uuids)
    pub service_uuids: ::std::vec::Vec<::std::string::String>,
    // @@protoc_insertion_point(field:BluetoothLEAdvertisementResponse.service_data)
    pub service_data: ::std::vec::Vec<BluetoothServiceData>,
    // @@protoc_insertion_point(field:BluetoothLEAdvertisementResponse.manufacturer_data)
    pub manufacturer_data: ::std::vec::Vec<BluetoothServiceData>,
    // @@protoc_insertion_point(field:BluetoothLEAdvertisementResponse.address_type)
    pub address_type: u32,
    // special fields
    // @@protoc_insertion_point(special_field:BluetoothLEAdvertisementResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a BluetoothLEAdvertisementResponse {
    fn default() -> &'a BluetoothLEAdvertisementResponse {
        <BluetoothLEAdvertisementResponse as ::protobuf::Message>::default_instance()
    }
}

impl BluetoothLEAdvertisementResponse {
    pub fn new() -> BluetoothLEAdvertisementResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(7);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "address",
            |m: &BluetoothLEAdvertisementResponse| { &m.address },
            |m: &mut BluetoothLEAdvertisementResponse| { &mut m.address },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "name",
            |m: &BluetoothLEAdvertisementResponse| { &m.name },
            |m: &mut BluetoothLEAdvertisementResponse| { &mut m.name },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "rssi",
            |m: &BluetoothLEAdvertisementResponse| { &m.rssi },
            |m: &mut BluetoothLEAdvertisementResponse| { &mut m.rssi },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "service_uuids",
            |m: &BluetoothLEAdvertisementResponse| { &m.service_uuids },
            |m: &mut BluetoothLEAdvertisementResponse| { &mut m.service_uuids },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "service_data",
            |m: &BluetoothLEAdvertisementResponse| { &m.service_data },
            |m: &mut BluetoothLEAdvertisementResponse| { &mut m.service_data },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "manufacturer_data",
            |m: &BluetoothLEAdvertisementResponse| { &m.manufacturer_data },
            |m: &mut BluetoothLEAdvertisementResponse| { &mut m.manufacturer_data },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "address_type",
            |m: &BluetoothLEAdvertisementResponse| { &m.address_type },
            |m: &mut BluetoothLEAdvertisementResponse| { &mut m.address_type },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<BluetoothLEAdvertisementResponse>(
            "BluetoothLEAdvertisementResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for BluetoothLEAdvertisementResponse {
    const NAME: &'static str = "BluetoothLEAdvertisementResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.address = is.read_uint64()?;
                },
                18 => {
                    self.name = is.read_bytes()?;
                },
                24 => {
                    self.rssi = is.read_sint32()?;
                },
                34 => {
                    self.service_uuids.push(is.read_string()?);
                },
                42 => {
                    self.service_data.push(is.read_message()?);
                },
                50 => {
                    self.manufacturer_data.push(is.read_message()?);
                },
                56 => {
                    self.address_type = is.read_uint32()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.address != 0 {
            my_size += ::protobuf::rt::uint64_size(1, self.address);
        }
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::bytes_size(2, &self.name);
        }
        if self.rssi != 0 {
            my_size += ::protobuf::rt::sint32_size(3, self.rssi);
        }
        for value in &self.service_uuids {
            my_size += ::protobuf::rt::string_size(4, &value);
        };
        for value in &self.service_data {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.manufacturer_data {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        if self.address_type != 0 {
            my_size += ::protobuf::rt::uint32_size(7, self.address_type);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.address != 0 {
            os.write_uint64(1, self.address)?;
        }
        if !self.name.is_empty() {
            os.write_bytes(2, &self.name)?;
        }
        if self.rssi != 0 {
            os.write_sint32(3, self.rssi)?;
        }
        for v in &self.service_uuids {
            os.write_string(4, &v)?;
        };
        for v in &self.service_data {
            ::protobuf::rt::write_message_field_with_cached_size(5, v, os)?;
        };
        for v in &self.manufacturer_data {
            ::protobuf::rt::write_message_field_with_cached_size(6, v, os)?;
        };
        if self.address_type != 0 {
            os.write_uint32(7, self.address_type)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> BluetoothLEAdvertisementResponse {
        BluetoothLEAdvertisementResponse::new()
    }

    fn clear(&mut self) {
        self.address = 0;
        self.name.clear();
        self.rssi = 0;
        self.service_uuids.clear();
        self.service_data.clear();
        self.manufacturer_data.clear();
        self.address_type = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static BluetoothLEAdvertisementResponse {
        static instance: BluetoothLEAdvertisementResponse = BluetoothLEAdvertisementResponse {
            address: 0,
            name: ::std::vec::Vec::new(),
            rssi: 0,
            service_uuids: ::std::vec::Vec::new(),
            service_data: ::std::vec::Vec::new(),
            manufacturer_data: ::std::vec::Vec::new(),
            address_type: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for BluetoothLEAdvertisementResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("BluetoothLEAdvertisementResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for BluetoothLEAdvertisementResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for BluetoothLEAdvertisementResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:BluetoothLERawAdvertisement)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct BluetoothLERawAdvertisement {
    // message fields
    // @@protoc_insertion_point(field:BluetoothLERawAdvertisement.address)
    pub address: u64,
    // @@protoc_insertion_point(field:BluetoothLERawAdvertisement.rssi)
    pub rssi: i32,
    // @@protoc_insertion_point(field:BluetoothLERawAdvertisement.address_type)
    pub address_type: u32,
    // @@protoc_insertion_point(field:BluetoothLERawAdvertisement.data)
    pub data: ::std::vec::Vec<u8>,
    // special fields
    // @@protoc_insertion_point(special_field:BluetoothLERawAdvertisement.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a BluetoothLERawAdvertisement {
    fn default() -> &'a BluetoothLERawAdvertisement {
        <BluetoothLERawAdvertisement as ::protobuf::Message>::default_instance()
    }
}

impl BluetoothLERawAdvertisement {
    pub fn new() -> BluetoothLERawAdvertisement {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "address",
            |m: &BluetoothLERawAdvertisement| { &m.address },
            |m: &mut BluetoothLERawAdvertisement| { &mut m.address },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "rssi",
            |m: &BluetoothLERawAdvertisement| { &m.rssi },
            |m: &mut BluetoothLERawAdvertisement| { &mut m.rssi },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "address_type",
            |m: &BluetoothLERawAdvertisement| { &m.address_type },
            |m: &mut BluetoothLERawAdvertisement| { &mut m.address_type },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "data",
            |m: &BluetoothLERawAdvertisement| { &m.data },
            |m: &mut BluetoothLERawAdvertisement| { &mut m.data },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<BluetoothLERawAdvertisement>(
            "BluetoothLERawAdvertisement",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for BluetoothLERawAdvertisement {
    const NAME: &'static str = "BluetoothLERawAdvertisement";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.address = is.read_uint64()?;
                },
                16 => {
                    self.rssi = is.read_sint32()?;
                },
                24 => {
                    self.address_type = is.read_uint32()?;
                },
                34 => {
                    self.data = is.read_bytes()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.address != 0 {
            my_size += ::protobuf::rt::uint64_size(1, self.address);
        }
        if self.rssi != 0 {
            my_size += ::protobuf::rt::sint32_size(2, self.rssi);
        }
        if self.address_type != 0 {
            my_size += ::protobuf::rt::uint32_size(3, self.address_type);
        }
        if !self.data.is_empty() {
            my_size += ::protobuf::rt::bytes_size(4, &self.data);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.address != 0 {
            os.write_uint64(1, self.address)?;
        }
        if self.rssi != 0 {
            os.write_sint32(2, self.rssi)?;
        }
        if self.address_type != 0 {
            os.write_uint32(3, self.address_type)?;
        }
        if !self.data.is_empty() {
            os.write_bytes(4, &self.data)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> BluetoothLERawAdvertisement {
        BluetoothLERawAdvertisement::new()
    }

    fn clear(&mut self) {
        self.address = 0;
        self.rssi = 0;
        self.address_type = 0;
        self.data.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static BluetoothLERawAdvertisement {
        static instance: BluetoothLERawAdvertisement = BluetoothLERawAdvertisement {
            address: 0,
            rssi: 0,
            address_type: 0,
            data: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for BluetoothLERawAdvertisement {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("BluetoothLERawAdvertisement").unwrap()).clone()
    }
}

impl ::std::fmt::Display for BluetoothLERawAdvertisement {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for BluetoothLERawAdvertisement {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:BluetoothLERawAdvertisementsResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct BluetoothLERawAdvertisementsResponse {
    // message fields
    // @@protoc_insertion_point(field:BluetoothLERawAdvertisementsResponse.advertisements)
    pub advertisements: ::std::vec::Vec<BluetoothLERawAdvertisement>,
    // special fields
    // @@protoc_insertion_point(special_field:BluetoothLERawAdvertisementsResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a BluetoothLERawAdvertisementsResponse {
    fn default() -> &'a BluetoothLERawAdvertisementsResponse {
        <BluetoothLERawAdvertisementsResponse as ::protobuf::Message>::default_instance()
    }
}

impl BluetoothLERawAdvertisementsResponse {
    pub fn new() -> BluetoothLERawAdvertisementsResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "advertisements",
            |m: &BluetoothLERawAdvertisementsResponse| { &m.advertisements },
            |m: &mut BluetoothLERawAdvertisementsResponse| { &mut m.advertisements },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<BluetoothLERawAdvertisementsResponse>(
            "BluetoothLERawAdvertisementsResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for BluetoothLERawAdvertisementsResponse {
    const NAME: &'static str = "BluetoothLERawAdvertisementsResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.advertisements.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.advertisements {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.advertisements {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> BluetoothLERawAdvertisementsResponse {
        BluetoothLERawAdvertisementsResponse::new()
    }

    fn clear(&mut self) {
        self.advertisements.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static BluetoothLERawAdvertisementsResponse {
        static instance: BluetoothLERawAdvertisementsResponse = BluetoothLERawAdvertisementsResponse {
            advertisements: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for BluetoothLERawAdvertisementsResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("BluetoothLERawAdvertisementsResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for BluetoothLERawAdvertisementsResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for BluetoothLERawAdvertisementsResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:BluetoothDeviceRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct BluetoothDeviceRequest {
    // message fields
    // @@protoc_insertion_point(field:BluetoothDeviceRequest.address)
    pub address: u64,
    // @@protoc_insertion_point(field:BluetoothDeviceRequest.request_type)
    pub request_type: ::protobuf::EnumOrUnknown<BluetoothDeviceRequestType>,
    // @@protoc_insertion_point(field:BluetoothDeviceRequest.has_address_type)
    pub has_address_type: bool,
    // @@protoc_insertion_point(field:BluetoothDeviceRequest.address_type)
    pub address_type: u32,
    // special fields
    // @@protoc_insertion_point(special_field:BluetoothDeviceRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a BluetoothDeviceRequest {
    fn default() -> &'a BluetoothDeviceRequest {
        <BluetoothDeviceRequest as ::protobuf::Message>::default_instance()
    }
}

impl BluetoothDeviceRequest {
    pub fn new() -> BluetoothDeviceRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "address",
            |m: &BluetoothDeviceRequest| { &m.address },
            |m: &mut BluetoothDeviceRequest| { &mut m.address },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "request_type",
            |m: &BluetoothDeviceRequest| { &m.request_type },
            |m: &mut BluetoothDeviceRequest| { &mut m.request_type },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "has_address_type",
            |m: &BluetoothDeviceRequest| { &m.has_address_type },
            |m: &mut BluetoothDeviceRequest| { &mut m.has_address_type },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "address_type",
            |m: &BluetoothDeviceRequest| { &m.address_type },
            |m: &mut BluetoothDeviceRequest| { &mut m.address_type },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<BluetoothDeviceRequest>(
            "BluetoothDeviceRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for BluetoothDeviceRequest {
    const NAME: &'static str = "BluetoothDeviceRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.address = is.read_uint64()?;
                },
                16 => {
                    self.request_type = is.read_enum_or_unknown()?;
                },
                24 => {
                    self.has_address_type = is.read_bool()?;
                },
                32 => {
                    self.address_type = is.read_uint32()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.address != 0 {
            my_size += ::protobuf::rt::uint64_size(1, self.address);
        }
        if self.request_type != ::protobuf::EnumOrUnknown::new(BluetoothDeviceRequestType::BLUETOOTH_DEVICE_REQUEST_TYPE_CONNECT) {
            my_size += ::protobuf::rt::int32_size(2, self.request_type.value());
        }
        if self.has_address_type != false {
            my_size += 1 + 1;
        }
        if self.address_type != 0 {
            my_size += ::protobuf::rt::uint32_size(4, self.address_type);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.address != 0 {
            os.write_uint64(1, self.address)?;
        }
        if self.request_type != ::protobuf::EnumOrUnknown::new(BluetoothDeviceRequestType::BLUETOOTH_DEVICE_REQUEST_TYPE_CONNECT) {
            os.write_enum(2, ::protobuf::EnumOrUnknown::value(&self.request_type))?;
        }
        if self.has_address_type != false {
            os.write_bool(3, self.has_address_type)?;
        }
        if self.address_type != 0 {
            os.write_uint32(4, self.address_type)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> BluetoothDeviceRequest {
        BluetoothDeviceRequest::new()
    }

    fn clear(&mut self) {
        self.address = 0;
        self.request_type = ::protobuf::EnumOrUnknown::new(BluetoothDeviceRequestType::BLUETOOTH_DEVICE_REQUEST_TYPE_CONNECT);
        self.has_address_type = false;
        self.address_type = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static BluetoothDeviceRequest {
        static instance: BluetoothDeviceRequest = BluetoothDeviceRequest {
            address: 0,
            request_type: ::protobuf::EnumOrUnknown::from_i32(0),
            has_address_type: false,
            address_type: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for BluetoothDeviceRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("BluetoothDeviceRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for BluetoothDeviceRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for BluetoothDeviceRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:BluetoothDeviceConnectionResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct BluetoothDeviceConnectionResponse {
    // message fields
    // @@protoc_insertion_point(field:BluetoothDeviceConnectionResponse.address)
    pub address: u64,
    // @@protoc_insertion_point(field:BluetoothDeviceConnectionResponse.connected)
    pub connected: bool,
    // @@protoc_insertion_point(field:BluetoothDeviceConnectionResponse.mtu)
    pub mtu: u32,
    // @@protoc_insertion_point(field:BluetoothDeviceConnectionResponse.error)
    pub error: i32,
    // special fields
    // @@protoc_insertion_point(special_field:BluetoothDeviceConnectionResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a BluetoothDeviceConnectionResponse {
    fn default() -> &'a BluetoothDeviceConnectionResponse {
        <BluetoothDeviceConnectionResponse as ::protobuf::Message>::default_instance()
    }
}

impl BluetoothDeviceConnectionResponse {
    pub fn new() -> BluetoothDeviceConnectionResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "address",
            |m: &BluetoothDeviceConnectionResponse| { &m.address },
            |m: &mut BluetoothDeviceConnectionResponse| { &mut m.address },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "connected",
            |m: &BluetoothDeviceConnectionResponse| { &m.connected },
            |m: &mut BluetoothDeviceConnectionResponse| { &mut m.connected },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "mtu",
            |m: &BluetoothDeviceConnectionResponse| { &m.mtu },
            |m: &mut BluetoothDeviceConnectionResponse| { &mut m.mtu },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "error",
            |m: &BluetoothDeviceConnectionResponse| { &m.error },
            |m: &mut BluetoothDeviceConnectionResponse| { &mut m.error },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<BluetoothDeviceConnectionResponse>(
            "BluetoothDeviceConnectionResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for BluetoothDeviceConnectionResponse {
    const NAME: &'static str = "BluetoothDeviceConnectionResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.address = is.read_uint64()?;
                },
                16 => {
                    self.connected = is.read_bool()?;
                },
                24 => {
                    self.mtu = is.read_uint32()?;
                },
                32 => {
                    self.error = is.read_int32()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.address != 0 {
            my_size += ::protobuf::rt::uint64_size(1, self.address);
        }
        if self.connected != false {
            my_size += 1 + 1;
        }
        if self.mtu != 0 {
            my_size += ::protobuf::rt::uint32_size(3, self.mtu);
        }
        if self.error != 0 {
            my_size += ::protobuf::rt::int32_size(4, self.error);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.address != 0 {
            os.write_uint64(1, self.address)?;
        }
        if self.connected != false {
            os.write_bool(2, self.connected)?;
        }
        if self.mtu != 0 {
            os.write_uint32(3, self.mtu)?;
        }
        if self.error != 0 {
            os.write_int32(4, self.error)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> BluetoothDeviceConnectionResponse {
        BluetoothDeviceConnectionResponse::new()
    }

    fn clear(&mut self) {
        self.address = 0;
        self.connected = false;
        self.mtu = 0;
        self.error = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static BluetoothDeviceConnectionResponse {
        static instance: BluetoothDeviceConnectionResponse = BluetoothDeviceConnectionResponse {
            address: 0,
            connected: false,
            mtu: 0,
            error: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for BluetoothDeviceConnectionResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("BluetoothDeviceConnectionResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for BluetoothDeviceConnectionResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for BluetoothDeviceConnectionResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:BluetoothGATTGetServicesRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct BluetoothGATTGetServicesRequest {
    // message fields
    // @@protoc_insertion_point(field:BluetoothGATTGetServicesRequest.address)
    pub address: u64,
    // special fields
    // @@protoc_insertion_point(special_field:BluetoothGATTGetServicesRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a BluetoothGATTGetServicesRequest {
    fn default() -> &'a BluetoothGATTGetServicesRequest {
        <BluetoothGATTGetServicesRequest as ::protobuf::Message>::default_instance()
    }
}

impl BluetoothGATTGetServicesRequest {
    pub fn new() -> BluetoothGATTGetServicesRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "address",
            |m: &BluetoothGATTGetServicesRequest| { &m.address },
            |m: &mut BluetoothGATTGetServicesRequest| { &mut m.address },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<BluetoothGATTGetServicesRequest>(
            "BluetoothGATTGetServicesRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for BluetoothGATTGetServicesRequest {
    const NAME: &'static str = "BluetoothGATTGetServicesRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.address = is.read_uint64()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.address != 0 {
            my_size += ::protobuf::rt::uint64_size(1, self.address);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.address != 0 {
            os.write_uint64(1, self.address)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> BluetoothGATTGetServicesRequest {
        BluetoothGATTGetServicesRequest::new()
    }

    fn clear(&mut self) {
        self.address = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static BluetoothGATTGetServicesRequest {
        static instance: BluetoothGATTGetServicesRequest = BluetoothGATTGetServicesRequest {
            address: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for BluetoothGATTGetServicesRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("BluetoothGATTGetServicesRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for BluetoothGATTGetServicesRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for BluetoothGATTGetServicesRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:BluetoothGATTDescriptor)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct BluetoothGATTDescriptor {
    // message fields
    // @@protoc_insertion_point(field:BluetoothGATTDescriptor.uuid)
    pub uuid: ::std::vec::Vec<u64>,
    // @@protoc_insertion_point(field:BluetoothGATTDescriptor.handle)
    pub handle: u32,
    // special fields
    // @@protoc_insertion_point(special_field:BluetoothGATTDescriptor.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a BluetoothGATTDescriptor {
    fn default() -> &'a BluetoothGATTDescriptor {
        <BluetoothGATTDescriptor as ::protobuf::Message>::default_instance()
    }
}

impl BluetoothGATTDescriptor {
    pub fn new() -> BluetoothGATTDescriptor {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "uuid",
            |m: &BluetoothGATTDescriptor| { &m.uuid },
            |m: &mut BluetoothGATTDescriptor| { &mut m.uuid },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "handle",
            |m: &BluetoothGATTDescriptor| { &m.handle },
            |m: &mut BluetoothGATTDescriptor| { &mut m.handle },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<BluetoothGATTDescriptor>(
            "BluetoothGATTDescriptor",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for BluetoothGATTDescriptor {
    const NAME: &'static str = "BluetoothGATTDescriptor";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    is.read_repeated_packed_uint64_into(&mut self.uuid)?;
                },
                8 => {
                    self.uuid.push(is.read_uint64()?);
                },
                16 => {
                    self.handle = is.read_uint32()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::vec_packed_uint64_size(1, &self.uuid);
        if self.handle != 0 {
            my_size += ::protobuf::rt::uint32_size(2, self.handle);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        os.write_repeated_packed_uint64(1, &self.uuid)?;
        if self.handle != 0 {
            os.write_uint32(2, self.handle)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> BluetoothGATTDescriptor {
        BluetoothGATTDescriptor::new()
    }

    fn clear(&mut self) {
        self.uuid.clear();
        self.handle = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static BluetoothGATTDescriptor {
        static instance: BluetoothGATTDescriptor = BluetoothGATTDescriptor {
            uuid: ::std::vec::Vec::new(),
            handle: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for BluetoothGATTDescriptor {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("BluetoothGATTDescriptor").unwrap()).clone()
    }
}

impl ::std::fmt::Display for BluetoothGATTDescriptor {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for BluetoothGATTDescriptor {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:BluetoothGATTCharacteristic)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct BluetoothGATTCharacteristic {
    // message fields
    // @@protoc_insertion_point(field:BluetoothGATTCharacteristic.uuid)
    pub uuid: ::std::vec::Vec<u64>,
    // @@protoc_insertion_point(field:BluetoothGATTCharacteristic.handle)
    pub handle: u32,
    // @@protoc_insertion_point(field:BluetoothGATTCharacteristic.properties)
    pub properties: u32,
    // @@protoc_insertion_point(field:BluetoothGATTCharacteristic.descriptors)
    pub descriptors: ::std::vec::Vec<BluetoothGATTDescriptor>,
    // special fields
    // @@protoc_insertion_point(special_field:BluetoothGATTCharacteristic.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a BluetoothGATTCharacteristic {
    fn default() -> &'a BluetoothGATTCharacteristic {
        <BluetoothGATTCharacteristic as ::protobuf::Message>::default_instance()
    }
}

impl BluetoothGATTCharacteristic {
    pub fn new() -> BluetoothGATTCharacteristic {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "uuid",
            |m: &BluetoothGATTCharacteristic| { &m.uuid },
            |m: &mut BluetoothGATTCharacteristic| { &mut m.uuid },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "handle",
            |m: &BluetoothGATTCharacteristic| { &m.handle },
            |m: &mut BluetoothGATTCharacteristic| { &mut m.handle },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "properties",
            |m: &BluetoothGATTCharacteristic| { &m.properties },
            |m: &mut BluetoothGATTCharacteristic| { &mut m.properties },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "descriptors",
            |m: &BluetoothGATTCharacteristic| { &m.descriptors },
            |m: &mut BluetoothGATTCharacteristic| { &mut m.descriptors },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<BluetoothGATTCharacteristic>(
            "BluetoothGATTCharacteristic",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for BluetoothGATTCharacteristic {
    const NAME: &'static str = "BluetoothGATTCharacteristic";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    is.read_repeated_packed_uint64_into(&mut self.uuid)?;
                },
                8 => {
                    self.uuid.push(is.read_uint64()?);
                },
                16 => {
                    self.handle = is.read_uint32()?;
                },
                24 => {
                    self.properties = is.read_uint32()?;
                },
                34 => {
                    self.descriptors.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::vec_packed_uint64_size(1, &self.uuid);
        if self.handle != 0 {
            my_size += ::protobuf::rt::uint32_size(2, self.handle);
        }
        if self.properties != 0 {
            my_size += ::protobuf::rt::uint32_size(3, self.properties);
        }
        for value in &self.descriptors {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        os.write_repeated_packed_uint64(1, &self.uuid)?;
        if self.handle != 0 {
            os.write_uint32(2, self.handle)?;
        }
        if self.properties != 0 {
            os.write_uint32(3, self.properties)?;
        }
        for v in &self.descriptors {
            ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> BluetoothGATTCharacteristic {
        BluetoothGATTCharacteristic::new()
    }

    fn clear(&mut self) {
        self.uuid.clear();
        self.handle = 0;
        self.properties = 0;
        self.descriptors.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static BluetoothGATTCharacteristic {
        static instance: BluetoothGATTCharacteristic = BluetoothGATTCharacteristic {
            uuid: ::std::vec::Vec::new(),
            handle: 0,
            properties: 0,
            descriptors: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for BluetoothGATTCharacteristic {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("BluetoothGATTCharacteristic").unwrap()).clone()
    }
}

impl ::std::fmt::Display for BluetoothGATTCharacteristic {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for BluetoothGATTCharacteristic {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:BluetoothGATTService)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct BluetoothGATTService {
    // message fields
    // @@protoc_insertion_point(field:BluetoothGATTService.uuid)
    pub uuid: ::std::vec::Vec<u64>,
    // @@protoc_insertion_point(field:BluetoothGATTService.handle)
    pub handle: u32,
    // @@protoc_insertion_point(field:BluetoothGATTService.characteristics)
    pub characteristics: ::std::vec::Vec<BluetoothGATTCharacteristic>,
    // special fields
    // @@protoc_insertion_point(special_field:BluetoothGATTService.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a BluetoothGATTService {
    fn default() -> &'a BluetoothGATTService {
        <BluetoothGATTService as ::protobuf::Message>::default_instance()
    }
}

impl BluetoothGATTService {
    pub fn new() -> BluetoothGATTService {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "uuid",
            |m: &BluetoothGATTService| { &m.uuid },
            |m: &mut BluetoothGATTService| { &mut m.uuid },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "handle",
            |m: &BluetoothGATTService| { &m.handle },
            |m: &mut BluetoothGATTService| { &mut m.handle },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "characteristics",
            |m: &BluetoothGATTService| { &m.characteristics },
            |m: &mut BluetoothGATTService| { &mut m.characteristics },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<BluetoothGATTService>(
            "BluetoothGATTService",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for BluetoothGATTService {
    const NAME: &'static str = "BluetoothGATTService";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    is.read_repeated_packed_uint64_into(&mut self.uuid)?;
                },
                8 => {
                    self.uuid.push(is.read_uint64()?);
                },
                16 => {
                    self.handle = is.read_uint32()?;
                },
                26 => {
                    self.characteristics.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::vec_packed_uint64_size(1, &self.uuid);
        if self.handle != 0 {
            my_size += ::protobuf::rt::uint32_size(2, self.handle);
        }
        for value in &self.characteristics {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        os.write_repeated_packed_uint64(1, &self.uuid)?;
        if self.handle != 0 {
            os.write_uint32(2, self.handle)?;
        }
        for v in &self.characteristics {
            ::protobuf::rt::write_message_field_with_cached_size(3, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> BluetoothGATTService {
        BluetoothGATTService::new()
    }

    fn clear(&mut self) {
        self.uuid.clear();
        self.handle = 0;
        self.characteristics.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static BluetoothGATTService {
        static instance: BluetoothGATTService = BluetoothGATTService {
            uuid: ::std::vec::Vec::new(),
            handle: 0,
            characteristics: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for BluetoothGATTService {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("BluetoothGATTService").unwrap()).clone()
    }
}

impl ::std::fmt::Display for BluetoothGATTService {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for BluetoothGATTService {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:BluetoothGATTGetServicesResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct BluetoothGATTGetServicesResponse {
    // message fields
    // @@protoc_insertion_point(field:BluetoothGATTGetServicesResponse.address)
    pub address: u64,
    // @@protoc_insertion_point(field:BluetoothGATTGetServicesResponse.services)
    pub services: ::std::vec::Vec<BluetoothGATTService>,
    // special fields
    // @@protoc_insertion_point(special_field:BluetoothGATTGetServicesResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a BluetoothGATTGetServicesResponse {
    fn default() -> &'a BluetoothGATTGetServicesResponse {
        <BluetoothGATTGetServicesResponse as ::protobuf::Message>::default_instance()
    }
}

impl BluetoothGATTGetServicesResponse {
    pub fn new() -> BluetoothGATTGetServicesResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "address",
            |m: &BluetoothGATTGetServicesResponse| { &m.address },
            |m: &mut BluetoothGATTGetServicesResponse| { &mut m.address },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "services",
            |m: &BluetoothGATTGetServicesResponse| { &m.services },
            |m: &mut BluetoothGATTGetServicesResponse| { &mut m.services },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<BluetoothGATTGetServicesResponse>(
            "BluetoothGATTGetServicesResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for BluetoothGATTGetServicesResponse {
    const NAME: &'static str = "BluetoothGATTGetServicesResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.address = is.read_uint64()?;
                },
                18 => {
                    self.services.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.address != 0 {
            my_size += ::protobuf::rt::uint64_size(1, self.address);
        }
        for value in &self.services {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.address != 0 {
            os.write_uint64(1, self.address)?;
        }
        for v in &self.services {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> BluetoothGATTGetServicesResponse {
        BluetoothGATTGetServicesResponse::new()
    }

    fn clear(&mut self) {
        self.address = 0;
        self.services.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static BluetoothGATTGetServicesResponse {
        static instance: BluetoothGATTGetServicesResponse = BluetoothGATTGetServicesResponse {
            address: 0,
            services: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for BluetoothGATTGetServicesResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("BluetoothGATTGetServicesResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for BluetoothGATTGetServicesResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for BluetoothGATTGetServicesResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:BluetoothGATTGetServicesDoneResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct BluetoothGATTGetServicesDoneResponse {
    // message fields
    // @@protoc_insertion_point(field:BluetoothGATTGetServicesDoneResponse.address)
    pub address: u64,
    // special fields
    // @@protoc_insertion_point(special_field:BluetoothGATTGetServicesDoneResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a BluetoothGATTGetServicesDoneResponse {
    fn default() -> &'a BluetoothGATTGetServicesDoneResponse {
        <BluetoothGATTGetServicesDoneResponse as ::protobuf::Message>::default_instance()
    }
}

impl BluetoothGATTGetServicesDoneResponse {
    pub fn new() -> BluetoothGATTGetServicesDoneResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "address",
            |m: &BluetoothGATTGetServicesDoneResponse| { &m.address },
            |m: &mut BluetoothGATTGetServicesDoneResponse| { &mut m.address },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<BluetoothGATTGetServicesDoneResponse>(
            "BluetoothGATTGetServicesDoneResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for BluetoothGATTGetServicesDoneResponse {
    const NAME: &'static str = "BluetoothGATTGetServicesDoneResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.address = is.read_uint64()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.address != 0 {
            my_size += ::protobuf::rt::uint64_size(1, self.address);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.address != 0 {
            os.write_uint64(1, self.address)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> BluetoothGATTGetServicesDoneResponse {
        BluetoothGATTGetServicesDoneResponse::new()
    }

    fn clear(&mut self) {
        self.address = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static BluetoothGATTGetServicesDoneResponse {
        static instance: BluetoothGATTGetServicesDoneResponse = BluetoothGATTGetServicesDoneResponse {
            address: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for BluetoothGATTGetServicesDoneResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("BluetoothGATTGetServicesDoneResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for BluetoothGATTGetServicesDoneResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for BluetoothGATTGetServicesDoneResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:BluetoothGATTReadRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct BluetoothGATTReadRequest {
    // message fields
    // @@protoc_insertion_point(field:BluetoothGATTReadRequest.address)
    pub address: u64,
    // @@protoc_insertion_point(field:BluetoothGATTReadRequest.handle)
    pub handle: u32,
    // special fields
    // @@protoc_insertion_point(special_field:BluetoothGATTReadRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a BluetoothGATTReadRequest {
    fn default() -> &'a BluetoothGATTReadRequest {
        <BluetoothGATTReadRequest as ::protobuf::Message>::default_instance()
    }
}

impl BluetoothGATTReadRequest {
    pub fn new() -> BluetoothGATTReadRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "address",
            |m: &BluetoothGATTReadRequest| { &m.address },
            |m: &mut BluetoothGATTReadRequest| { &mut m.address },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "handle",
            |m: &BluetoothGATTReadRequest| { &m.handle },
            |m: &mut BluetoothGATTReadRequest| { &mut m.handle },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<BluetoothGATTReadRequest>(
            "BluetoothGATTReadRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for BluetoothGATTReadRequest {
    const NAME: &'static str = "BluetoothGATTReadRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.address = is.read_uint64()?;
                },
                16 => {
                    self.handle = is.read_uint32()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.address != 0 {
            my_size += ::protobuf::rt::uint64_size(1, self.address);
        }
        if self.handle != 0 {
            my_size += ::protobuf::rt::uint32_size(2, self.handle);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.address != 0 {
            os.write_uint64(1, self.address)?;
        }
        if self.handle != 0 {
            os.write_uint32(2, self.handle)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> BluetoothGATTReadRequest {
        BluetoothGATTReadRequest::new()
    }

    fn clear(&mut self) {
        self.address = 0;
        self.handle = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static BluetoothGATTReadRequest {
        static instance: BluetoothGATTReadRequest = BluetoothGATTReadRequest {
            address: 0,
            handle: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for BluetoothGATTReadRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("BluetoothGATTReadRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for BluetoothGATTReadRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for BluetoothGATTReadRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:BluetoothGATTReadResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct BluetoothGATTReadResponse {
    // message fields
    // @@protoc_insertion_point(field:BluetoothGATTReadResponse.address)
    pub address: u64,
    // @@protoc_insertion_point(field:BluetoothGATTReadResponse.handle)
    pub handle: u32,
    // @@protoc_insertion_point(field:BluetoothGATTReadResponse.data)
    pub data: ::std::vec::Vec<u8>,
    // special fields
    // @@protoc_insertion_point(special_field:BluetoothGATTReadResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a BluetoothGATTReadResponse {
    fn default() -> &'a BluetoothGATTReadResponse {
        <BluetoothGATTReadResponse as ::protobuf::Message>::default_instance()
    }
}

impl BluetoothGATTReadResponse {
    pub fn new() -> BluetoothGATTReadResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "address",
            |m: &BluetoothGATTReadResponse| { &m.address },
            |m: &mut BluetoothGATTReadResponse| { &mut m.address },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "handle",
            |m: &BluetoothGATTReadResponse| { &m.handle },
            |m: &mut BluetoothGATTReadResponse| { &mut m.handle },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "data",
            |m: &BluetoothGATTReadResponse| { &m.data },
            |m: &mut BluetoothGATTReadResponse| { &mut m.data },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<BluetoothGATTReadResponse>(
            "BluetoothGATTReadResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for BluetoothGATTReadResponse {
    const NAME: &'static str = "BluetoothGATTReadResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.address = is.read_uint64()?;
                },
                16 => {
                    self.handle = is.read_uint32()?;
                },
                26 => {
                    self.data = is.read_bytes()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.address != 0 {
            my_size += ::protobuf::rt::uint64_size(1, self.address);
        }
        if self.handle != 0 {
            my_size += ::protobuf::rt::uint32_size(2, self.handle);
        }
        if !self.data.is_empty() {
            my_size += ::protobuf::rt::bytes_size(3, &self.data);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.address != 0 {
            os.write_uint64(1, self.address)?;
        }
        if self.handle != 0 {
            os.write_uint32(2, self.handle)?;
        }
        if !self.data.is_empty() {
            os.write_bytes(3, &self.data)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> BluetoothGATTReadResponse {
        BluetoothGATTReadResponse::new()
    }

    fn clear(&mut self) {
        self.address = 0;
        self.handle = 0;
        self.data.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static BluetoothGATTReadResponse {
        static instance: BluetoothGATTReadResponse = BluetoothGATTReadResponse {
            address: 0,
            handle: 0,
            data: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for BluetoothGATTReadResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("BluetoothGATTReadResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for BluetoothGATTReadResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for BluetoothGATTReadResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:BluetoothGATTWriteRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct BluetoothGATTWriteRequest {
    // message fields
    // @@protoc_insertion_point(field:BluetoothGATTWriteRequest.address)
    pub address: u64,
    // @@protoc_insertion_point(field:BluetoothGATTWriteRequest.handle)
    pub handle: u32,
    // @@protoc_insertion_point(field:BluetoothGATTWriteRequest.response)
    pub response: bool,
    // @@protoc_insertion_point(field:BluetoothGATTWriteRequest.data)
    pub data: ::std::vec::Vec<u8>,
    // special fields
    // @@protoc_insertion_point(special_field:BluetoothGATTWriteRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a BluetoothGATTWriteRequest {
    fn default() -> &'a BluetoothGATTWriteRequest {
        <BluetoothGATTWriteRequest as ::protobuf::Message>::default_instance()
    }
}

impl BluetoothGATTWriteRequest {
    pub fn new() -> BluetoothGATTWriteRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "address",
            |m: &BluetoothGATTWriteRequest| { &m.address },
            |m: &mut BluetoothGATTWriteRequest| { &mut m.address },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "handle",
            |m: &BluetoothGATTWriteRequest| { &m.handle },
            |m: &mut BluetoothGATTWriteRequest| { &mut m.handle },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "response",
            |m: &BluetoothGATTWriteRequest| { &m.response },
            |m: &mut BluetoothGATTWriteRequest| { &mut m.response },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "data",
            |m: &BluetoothGATTWriteRequest| { &m.data },
            |m: &mut BluetoothGATTWriteRequest| { &mut m.data },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<BluetoothGATTWriteRequest>(
            "BluetoothGATTWriteRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for BluetoothGATTWriteRequest {
    const NAME: &'static str = "BluetoothGATTWriteRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.address = is.read_uint64()?;
                },
                16 => {
                    self.handle = is.read_uint32()?;
                },
                24 => {
                    self.response = is.read_bool()?;
                },
                34 => {
                    self.data = is.read_bytes()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.address != 0 {
            my_size += ::protobuf::rt::uint64_size(1, self.address);
        }
        if self.handle != 0 {
            my_size += ::protobuf::rt::uint32_size(2, self.handle);
        }
        if self.response != false {
            my_size += 1 + 1;
        }
        if !self.data.is_empty() {
            my_size += ::protobuf::rt::bytes_size(4, &self.data);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.address != 0 {
            os.write_uint64(1, self.address)?;
        }
        if self.handle != 0 {
            os.write_uint32(2, self.handle)?;
        }
        if self.response != false {
            os.write_bool(3, self.response)?;
        }
        if !self.data.is_empty() {
            os.write_bytes(4, &self.data)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> BluetoothGATTWriteRequest {
        BluetoothGATTWriteRequest::new()
    }

    fn clear(&mut self) {
        self.address = 0;
        self.handle = 0;
        self.response = false;
        self.data.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static BluetoothGATTWriteRequest {
        static instance: BluetoothGATTWriteRequest = BluetoothGATTWriteRequest {
            address: 0,
            handle: 0,
            response: false,
            data: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for BluetoothGATTWriteRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("BluetoothGATTWriteRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for BluetoothGATTWriteRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for BluetoothGATTWriteRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:BluetoothGATTReadDescriptorRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct BluetoothGATTReadDescriptorRequest {
    // message fields
    // @@protoc_insertion_point(field:BluetoothGATTReadDescriptorRequest.address)
    pub address: u64,
    // @@protoc_insertion_point(field:BluetoothGATTReadDescriptorRequest.handle)
    pub handle: u32,
    // special fields
    // @@protoc_insertion_point(special_field:BluetoothGATTReadDescriptorRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a BluetoothGATTReadDescriptorRequest {
    fn default() -> &'a BluetoothGATTReadDescriptorRequest {
        <BluetoothGATTReadDescriptorRequest as ::protobuf::Message>::default_instance()
    }
}

impl BluetoothGATTReadDescriptorRequest {
    pub fn new() -> BluetoothGATTReadDescriptorRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "address",
            |m: &BluetoothGATTReadDescriptorRequest| { &m.address },
            |m: &mut BluetoothGATTReadDescriptorRequest| { &mut m.address },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "handle",
            |m: &BluetoothGATTReadDescriptorRequest| { &m.handle },
            |m: &mut BluetoothGATTReadDescriptorRequest| { &mut m.handle },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<BluetoothGATTReadDescriptorRequest>(
            "BluetoothGATTReadDescriptorRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for BluetoothGATTReadDescriptorRequest {
    const NAME: &'static str = "BluetoothGATTReadDescriptorRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.address = is.read_uint64()?;
                },
                16 => {
                    self.handle = is.read_uint32()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.address != 0 {
            my_size += ::protobuf::rt::uint64_size(1, self.address);
        }
        if self.handle != 0 {
            my_size += ::protobuf::rt::uint32_size(2, self.handle);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.address != 0 {
            os.write_uint64(1, self.address)?;
        }
        if self.handle != 0 {
            os.write_uint32(2, self.handle)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> BluetoothGATTReadDescriptorRequest {
        BluetoothGATTReadDescriptorRequest::new()
    }

    fn clear(&mut self) {
        self.address = 0;
        self.handle = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static BluetoothGATTReadDescriptorRequest {
        static instance: BluetoothGATTReadDescriptorRequest = BluetoothGATTReadDescriptorRequest {
            address: 0,
            handle: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for BluetoothGATTReadDescriptorRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("BluetoothGATTReadDescriptorRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for BluetoothGATTReadDescriptorRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for BluetoothGATTReadDescriptorRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:BluetoothGATTWriteDescriptorRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct BluetoothGATTWriteDescriptorRequest {
    // message fields
    // @@protoc_insertion_point(field:BluetoothGATTWriteDescriptorRequest.address)
    pub address: u64,
    // @@protoc_insertion_point(field:BluetoothGATTWriteDescriptorRequest.handle)
    pub handle: u32,
    // @@protoc_insertion_point(field:BluetoothGATTWriteDescriptorRequest.data)
    pub data: ::std::vec::Vec<u8>,
    // special fields
    // @@protoc_insertion_point(special_field:BluetoothGATTWriteDescriptorRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a BluetoothGATTWriteDescriptorRequest {
    fn default() -> &'a BluetoothGATTWriteDescriptorRequest {
        <BluetoothGATTWriteDescriptorRequest as ::protobuf::Message>::default_instance()
    }
}

impl BluetoothGATTWriteDescriptorRequest {
    pub fn new() -> BluetoothGATTWriteDescriptorRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "address",
            |m: &BluetoothGATTWriteDescriptorRequest| { &m.address },
            |m: &mut BluetoothGATTWriteDescriptorRequest| { &mut m.address },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "handle",
            |m: &BluetoothGATTWriteDescriptorRequest| { &m.handle },
            |m: &mut BluetoothGATTWriteDescriptorRequest| { &mut m.handle },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "data",
            |m: &BluetoothGATTWriteDescriptorRequest| { &m.data },
            |m: &mut BluetoothGATTWriteDescriptorRequest| { &mut m.data },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<BluetoothGATTWriteDescriptorRequest>(
            "BluetoothGATTWriteDescriptorRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for BluetoothGATTWriteDescriptorRequest {
    const NAME: &'static str = "BluetoothGATTWriteDescriptorRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.address = is.read_uint64()?;
                },
                16 => {
                    self.handle = is.read_uint32()?;
                },
                26 => {
                    self.data = is.read_bytes()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.address != 0 {
            my_size += ::protobuf::rt::uint64_size(1, self.address);
        }
        if self.handle != 0 {
            my_size += ::protobuf::rt::uint32_size(2, self.handle);
        }
        if !self.data.is_empty() {
            my_size += ::protobuf::rt::bytes_size(3, &self.data);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.address != 0 {
            os.write_uint64(1, self.address)?;
        }
        if self.handle != 0 {
            os.write_uint32(2, self.handle)?;
        }
        if !self.data.is_empty() {
            os.write_bytes(3, &self.data)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> BluetoothGATTWriteDescriptorRequest {
        BluetoothGATTWriteDescriptorRequest::new()
    }

    fn clear(&mut self) {
        self.address = 0;
        self.handle = 0;
        self.data.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static BluetoothGATTWriteDescriptorRequest {
        static instance: BluetoothGATTWriteDescriptorRequest = BluetoothGATTWriteDescriptorRequest {
            address: 0,
            handle: 0,
            data: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for BluetoothGATTWriteDescriptorRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("BluetoothGATTWriteDescriptorRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for BluetoothGATTWriteDescriptorRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for BluetoothGATTWriteDescriptorRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:BluetoothGATTNotifyRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct BluetoothGATTNotifyRequest {
    // message fields
    // @@protoc_insertion_point(field:BluetoothGATTNotifyRequest.address)
    pub address: u64,
    // @@protoc_insertion_point(field:BluetoothGATTNotifyRequest.handle)
    pub handle: u32,
    // @@protoc_insertion_point(field:BluetoothGATTNotifyRequest.enable)
    pub enable: bool,
    // special fields
    // @@protoc_insertion_point(special_field:BluetoothGATTNotifyRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a BluetoothGATTNotifyRequest {
    fn default() -> &'a BluetoothGATTNotifyRequest {
        <BluetoothGATTNotifyRequest as ::protobuf::Message>::default_instance()
    }
}

impl BluetoothGATTNotifyRequest {
    pub fn new() -> BluetoothGATTNotifyRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "address",
            |m: &BluetoothGATTNotifyRequest| { &m.address },
            |m: &mut BluetoothGATTNotifyRequest| { &mut m.address },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "handle",
            |m: &BluetoothGATTNotifyRequest| { &m.handle },
            |m: &mut BluetoothGATTNotifyRequest| { &mut m.handle },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "enable",
            |m: &BluetoothGATTNotifyRequest| { &m.enable },
            |m: &mut BluetoothGATTNotifyRequest| { &mut m.enable },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<BluetoothGATTNotifyRequest>(
            "BluetoothGATTNotifyRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for BluetoothGATTNotifyRequest {
    const NAME: &'static str = "BluetoothGATTNotifyRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.address = is.read_uint64()?;
                },
                16 => {
                    self.handle = is.read_uint32()?;
                },
                24 => {
                    self.enable = is.read_bool()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.address != 0 {
            my_size += ::protobuf::rt::uint64_size(1, self.address);
        }
        if self.handle != 0 {
            my_size += ::protobuf::rt::uint32_size(2, self.handle);
        }
        if self.enable != false {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.address != 0 {
            os.write_uint64(1, self.address)?;
        }
        if self.handle != 0 {
            os.write_uint32(2, self.handle)?;
        }
        if self.enable != false {
            os.write_bool(3, self.enable)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> BluetoothGATTNotifyRequest {
        BluetoothGATTNotifyRequest::new()
    }

    fn clear(&mut self) {
        self.address = 0;
        self.handle = 0;
        self.enable = false;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static BluetoothGATTNotifyRequest {
        static instance: BluetoothGATTNotifyRequest = BluetoothGATTNotifyRequest {
            address: 0,
            handle: 0,
            enable: false,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for BluetoothGATTNotifyRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("BluetoothGATTNotifyRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for BluetoothGATTNotifyRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for BluetoothGATTNotifyRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:BluetoothGATTNotifyDataResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct BluetoothGATTNotifyDataResponse {
    // message fields
    // @@protoc_insertion_point(field:BluetoothGATTNotifyDataResponse.address)
    pub address: u64,
    // @@protoc_insertion_point(field:BluetoothGATTNotifyDataResponse.handle)
    pub handle: u32,
    // @@protoc_insertion_point(field:BluetoothGATTNotifyDataResponse.data)
    pub data: ::std::vec::Vec<u8>,
    // special fields
    // @@protoc_insertion_point(special_field:BluetoothGATTNotifyDataResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a BluetoothGATTNotifyDataResponse {
    fn default() -> &'a BluetoothGATTNotifyDataResponse {
        <BluetoothGATTNotifyDataResponse as ::protobuf::Message>::default_instance()
    }
}

impl BluetoothGATTNotifyDataResponse {
    pub fn new() -> BluetoothGATTNotifyDataResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "address",
            |m: &BluetoothGATTNotifyDataResponse| { &m.address },
            |m: &mut BluetoothGATTNotifyDataResponse| { &mut m.address },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "handle",
            |m: &BluetoothGATTNotifyDataResponse| { &m.handle },
            |m: &mut BluetoothGATTNotifyDataResponse| { &mut m.handle },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "data",
            |m: &BluetoothGATTNotifyDataResponse| { &m.data },
            |m: &mut BluetoothGATTNotifyDataResponse| { &mut m.data },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<BluetoothGATTNotifyDataResponse>(
            "BluetoothGATTNotifyDataResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for BluetoothGATTNotifyDataResponse {
    const NAME: &'static str = "BluetoothGATTNotifyDataResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.address = is.read_uint64()?;
                },
                16 => {
                    self.handle = is.read_uint32()?;
                },
                26 => {
                    self.data = is.read_bytes()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.address != 0 {
            my_size += ::protobuf::rt::uint64_size(1, self.address);
        }
        if self.handle != 0 {
            my_size += ::protobuf::rt::uint32_size(2, self.handle);
        }
        if !self.data.is_empty() {
            my_size += ::protobuf::rt::bytes_size(3, &self.data);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.address != 0 {
            os.write_uint64(1, self.address)?;
        }
        if self.handle != 0 {
            os.write_uint32(2, self.handle)?;
        }
        if !self.data.is_empty() {
            os.write_bytes(3, &self.data)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> BluetoothGATTNotifyDataResponse {
        BluetoothGATTNotifyDataResponse::new()
    }

    fn clear(&mut self) {
        self.address = 0;
        self.handle = 0;
        self.data.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static BluetoothGATTNotifyDataResponse {
        static instance: BluetoothGATTNotifyDataResponse = BluetoothGATTNotifyDataResponse {
            address: 0,
            handle: 0,
            data: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for BluetoothGATTNotifyDataResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("BluetoothGATTNotifyDataResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for BluetoothGATTNotifyDataResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for BluetoothGATTNotifyDataResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:SubscribeBluetoothConnectionsFreeRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct SubscribeBluetoothConnectionsFreeRequest {
    // special fields
    // @@protoc_insertion_point(special_field:SubscribeBluetoothConnectionsFreeRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a SubscribeBluetoothConnectionsFreeRequest {
    fn default() -> &'a SubscribeBluetoothConnectionsFreeRequest {
        <SubscribeBluetoothConnectionsFreeRequest as ::protobuf::Message>::default_instance()
    }
}

impl SubscribeBluetoothConnectionsFreeRequest {
    pub fn new() -> SubscribeBluetoothConnectionsFreeRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(0);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<SubscribeBluetoothConnectionsFreeRequest>(
            "SubscribeBluetoothConnectionsFreeRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for SubscribeBluetoothConnectionsFreeRequest {
    const NAME: &'static str = "SubscribeBluetoothConnectionsFreeRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> SubscribeBluetoothConnectionsFreeRequest {
        SubscribeBluetoothConnectionsFreeRequest::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static SubscribeBluetoothConnectionsFreeRequest {
        static instance: SubscribeBluetoothConnectionsFreeRequest = SubscribeBluetoothConnectionsFreeRequest {
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for SubscribeBluetoothConnectionsFreeRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("SubscribeBluetoothConnectionsFreeRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for SubscribeBluetoothConnectionsFreeRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SubscribeBluetoothConnectionsFreeRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:BluetoothConnectionsFreeResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct BluetoothConnectionsFreeResponse {
    // message fields
    // @@protoc_insertion_point(field:BluetoothConnectionsFreeResponse.free)
    pub free: u32,
    // @@protoc_insertion_point(field:BluetoothConnectionsFreeResponse.limit)
    pub limit: u32,
    // @@protoc_insertion_point(field:BluetoothConnectionsFreeResponse.allocated)
    pub allocated: ::std::vec::Vec<u64>,
    // special fields
    // @@protoc_insertion_point(special_field:BluetoothConnectionsFreeResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a BluetoothConnectionsFreeResponse {
    fn default() -> &'a BluetoothConnectionsFreeResponse {
        <BluetoothConnectionsFreeResponse as ::protobuf::Message>::default_instance()
    }
}

impl BluetoothConnectionsFreeResponse {
    pub fn new() -> BluetoothConnectionsFreeResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "free",
            |m: &BluetoothConnectionsFreeResponse| { &m.free },
            |m: &mut BluetoothConnectionsFreeResponse| { &mut m.free },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "limit",
            |m: &BluetoothConnectionsFreeResponse| { &m.limit },
            |m: &mut BluetoothConnectionsFreeResponse| { &mut m.limit },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "allocated",
            |m: &BluetoothConnectionsFreeResponse| { &m.allocated },
            |m: &mut BluetoothConnectionsFreeResponse| { &mut m.allocated },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<BluetoothConnectionsFreeResponse>(
            "BluetoothConnectionsFreeResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for BluetoothConnectionsFreeResponse {
    const NAME: &'static str = "BluetoothConnectionsFreeResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.free = is.read_uint32()?;
                },
                16 => {
                    self.limit = is.read_uint32()?;
                },
                26 => {
                    is.read_repeated_packed_uint64_into(&mut self.allocated)?;
                },
                24 => {
                    self.allocated.push(is.read_uint64()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.free != 0 {
            my_size += ::protobuf::rt::uint32_size(1, self.free);
        }
        if self.limit != 0 {
            my_size += ::protobuf::rt::uint32_size(2, self.limit);
        }
        my_size += ::protobuf::rt::vec_packed_uint64_size(3, &self.allocated);
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.free != 0 {
            os.write_uint32(1, self.free)?;
        }
        if self.limit != 0 {
            os.write_uint32(2, self.limit)?;
        }
        os.write_repeated_packed_uint64(3, &self.allocated)?;
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> BluetoothConnectionsFreeResponse {
        BluetoothConnectionsFreeResponse::new()
    }

    fn clear(&mut self) {
        self.free = 0;
        self.limit = 0;
        self.allocated.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static BluetoothConnectionsFreeResponse {
        static instance: BluetoothConnectionsFreeResponse = BluetoothConnectionsFreeResponse {
            free: 0,
            limit: 0,
            allocated: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for BluetoothConnectionsFreeResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("BluetoothConnectionsFreeResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for BluetoothConnectionsFreeResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for BluetoothConnectionsFreeResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:BluetoothGATTErrorResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct BluetoothGATTErrorResponse {
    // message fields
    // @@protoc_insertion_point(field:BluetoothGATTErrorResponse.address)
    pub address: u64,
    // @@protoc_insertion_point(field:BluetoothGATTErrorResponse.handle)
    pub handle: u32,
    // @@protoc_insertion_point(field:BluetoothGATTErrorResponse.error)
    pub error: i32,
    // special fields
    // @@protoc_insertion_point(special_field:BluetoothGATTErrorResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a BluetoothGATTErrorResponse {
    fn default() -> &'a BluetoothGATTErrorResponse {
        <BluetoothGATTErrorResponse as ::protobuf::Message>::default_instance()
    }
}

impl BluetoothGATTErrorResponse {
    pub fn new() -> BluetoothGATTErrorResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "address",
            |m: &BluetoothGATTErrorResponse| { &m.address },
            |m: &mut BluetoothGATTErrorResponse| { &mut m.address },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "handle",
            |m: &BluetoothGATTErrorResponse| { &m.handle },
            |m: &mut BluetoothGATTErrorResponse| { &mut m.handle },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "error",
            |m: &BluetoothGATTErrorResponse| { &m.error },
            |m: &mut BluetoothGATTErrorResponse| { &mut m.error },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<BluetoothGATTErrorResponse>(
            "BluetoothGATTErrorResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for BluetoothGATTErrorResponse {
    const NAME: &'static str = "BluetoothGATTErrorResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.address = is.read_uint64()?;
                },
                16 => {
                    self.handle = is.read_uint32()?;
                },
                24 => {
                    self.error = is.read_int32()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.address != 0 {
            my_size += ::protobuf::rt::uint64_size(1, self.address);
        }
        if self.handle != 0 {
            my_size += ::protobuf::rt::uint32_size(2, self.handle);
        }
        if self.error != 0 {
            my_size += ::protobuf::rt::int32_size(3, self.error);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.address != 0 {
            os.write_uint64(1, self.address)?;
        }
        if self.handle != 0 {
            os.write_uint32(2, self.handle)?;
        }
        if self.error != 0 {
            os.write_int32(3, self.error)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> BluetoothGATTErrorResponse {
        BluetoothGATTErrorResponse::new()
    }

    fn clear(&mut self) {
        self.address = 0;
        self.handle = 0;
        self.error = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static BluetoothGATTErrorResponse {
        static instance: BluetoothGATTErrorResponse = BluetoothGATTErrorResponse {
            address: 0,
            handle: 0,
            error: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for BluetoothGATTErrorResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("BluetoothGATTErrorResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for BluetoothGATTErrorResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for BluetoothGATTErrorResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:BluetoothGATTWriteResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct BluetoothGATTWriteResponse {
    // message fields
    // @@protoc_insertion_point(field:BluetoothGATTWriteResponse.address)
    pub address: u64,
    // @@protoc_insertion_point(field:BluetoothGATTWriteResponse.handle)
    pub handle: u32,
    // special fields
    // @@protoc_insertion_point(special_field:BluetoothGATTWriteResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a BluetoothGATTWriteResponse {
    fn default() -> &'a BluetoothGATTWriteResponse {
        <BluetoothGATTWriteResponse as ::protobuf::Message>::default_instance()
    }
}

impl BluetoothGATTWriteResponse {
    pub fn new() -> BluetoothGATTWriteResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "address",
            |m: &BluetoothGATTWriteResponse| { &m.address },
            |m: &mut BluetoothGATTWriteResponse| { &mut m.address },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "handle",
            |m: &BluetoothGATTWriteResponse| { &m.handle },
            |m: &mut BluetoothGATTWriteResponse| { &mut m.handle },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<BluetoothGATTWriteResponse>(
            "BluetoothGATTWriteResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for BluetoothGATTWriteResponse {
    const NAME: &'static str = "BluetoothGATTWriteResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.address = is.read_uint64()?;
                },
                16 => {
                    self.handle = is.read_uint32()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.address != 0 {
            my_size += ::protobuf::rt::uint64_size(1, self.address);
        }
        if self.handle != 0 {
            my_size += ::protobuf::rt::uint32_size(2, self.handle);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.address != 0 {
            os.write_uint64(1, self.address)?;
        }
        if self.handle != 0 {
            os.write_uint32(2, self.handle)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> BluetoothGATTWriteResponse {
        BluetoothGATTWriteResponse::new()
    }

    fn clear(&mut self) {
        self.address = 0;
        self.handle = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static BluetoothGATTWriteResponse {
        static instance: BluetoothGATTWriteResponse = BluetoothGATTWriteResponse {
            address: 0,
            handle: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for BluetoothGATTWriteResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("BluetoothGATTWriteResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for BluetoothGATTWriteResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for BluetoothGATTWriteResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:BluetoothGATTNotifyResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct BluetoothGATTNotifyResponse {
    // message fields
    // @@protoc_insertion_point(field:BluetoothGATTNotifyResponse.address)
    pub address: u64,
    // @@protoc_insertion_point(field:BluetoothGATTNotifyResponse.handle)
    pub handle: u32,
    // special fields
    // @@protoc_insertion_point(special_field:BluetoothGATTNotifyResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a BluetoothGATTNotifyResponse {
    fn default() -> &'a BluetoothGATTNotifyResponse {
        <BluetoothGATTNotifyResponse as ::protobuf::Message>::default_instance()
    }
}

impl BluetoothGATTNotifyResponse {
    pub fn new() -> BluetoothGATTNotifyResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "address",
            |m: &BluetoothGATTNotifyResponse| { &m.address },
            |m: &mut BluetoothGATTNotifyResponse| { &mut m.address },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "handle",
            |m: &BluetoothGATTNotifyResponse| { &m.handle },
            |m: &mut BluetoothGATTNotifyResponse| { &mut m.handle },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<BluetoothGATTNotifyResponse>(
            "BluetoothGATTNotifyResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for BluetoothGATTNotifyResponse {
    const NAME: &'static str = "BluetoothGATTNotifyResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.address = is.read_uint64()?;
                },
                16 => {
                    self.handle = is.read_uint32()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.address != 0 {
            my_size += ::protobuf::rt::uint64_size(1, self.address);
        }
        if self.handle != 0 {
            my_size += ::protobuf::rt::uint32_size(2, self.handle);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.address != 0 {
            os.write_uint64(1, self.address)?;
        }
        if self.handle != 0 {
            os.write_uint32(2, self.handle)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> BluetoothGATTNotifyResponse {
        BluetoothGATTNotifyResponse::new()
    }

    fn clear(&mut self) {
        self.address = 0;
        self.handle = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static BluetoothGATTNotifyResponse {
        static instance: BluetoothGATTNotifyResponse = BluetoothGATTNotifyResponse {
            address: 0,
            handle: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for BluetoothGATTNotifyResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("BluetoothGATTNotifyResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for BluetoothGATTNotifyResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for BluetoothGATTNotifyResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:BluetoothDevicePairingResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct BluetoothDevicePairingResponse {
    // message fields
    // @@protoc_insertion_point(field:BluetoothDevicePairingResponse.address)
    pub address: u64,
    // @@protoc_insertion_point(field:BluetoothDevicePairingResponse.paired)
    pub paired: bool,
    // @@protoc_insertion_point(field:BluetoothDevicePairingResponse.error)
    pub error: i32,
    // special fields
    // @@protoc_insertion_point(special_field:BluetoothDevicePairingResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a BluetoothDevicePairingResponse {
    fn default() -> &'a BluetoothDevicePairingResponse {
        <BluetoothDevicePairingResponse as ::protobuf::Message>::default_instance()
    }
}

impl BluetoothDevicePairingResponse {
    pub fn new() -> BluetoothDevicePairingResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "address",
            |m: &BluetoothDevicePairingResponse| { &m.address },
            |m: &mut BluetoothDevicePairingResponse| { &mut m.address },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "paired",
            |m: &BluetoothDevicePairingResponse| { &m.paired },
            |m: &mut BluetoothDevicePairingResponse| { &mut m.paired },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "error",
            |m: &BluetoothDevicePairingResponse| { &m.error },
            |m: &mut BluetoothDevicePairingResponse| { &mut m.error },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<BluetoothDevicePairingResponse>(
            "BluetoothDevicePairingResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for BluetoothDevicePairingResponse {
    const NAME: &'static str = "BluetoothDevicePairingResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.address = is.read_uint64()?;
                },
                16 => {
                    self.paired = is.read_bool()?;
                },
                24 => {
                    self.error = is.read_int32()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.address != 0 {
            my_size += ::protobuf::rt::uint64_size(1, self.address);
        }
        if self.paired != false {
            my_size += 1 + 1;
        }
        if self.error != 0 {
            my_size += ::protobuf::rt::int32_size(3, self.error);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.address != 0 {
            os.write_uint64(1, self.address)?;
        }
        if self.paired != false {
            os.write_bool(2, self.paired)?;
        }
        if self.error != 0 {
            os.write_int32(3, self.error)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> BluetoothDevicePairingResponse {
        BluetoothDevicePairingResponse::new()
    }

    fn clear(&mut self) {
        self.address = 0;
        self.paired = false;
        self.error = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static BluetoothDevicePairingResponse {
        static instance: BluetoothDevicePairingResponse = BluetoothDevicePairingResponse {
            address: 0,
            paired: false,
            error: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for BluetoothDevicePairingResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("BluetoothDevicePairingResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for BluetoothDevicePairingResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for BluetoothDevicePairingResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:BluetoothDeviceUnpairingResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct BluetoothDeviceUnpairingResponse {
    // message fields
    // @@protoc_insertion_point(field:BluetoothDeviceUnpairingResponse.address)
    pub address: u64,
    // @@protoc_insertion_point(field:BluetoothDeviceUnpairingResponse.success)
    pub success: bool,
    // @@protoc_insertion_point(field:BluetoothDeviceUnpairingResponse.error)
    pub error: i32,
    // special fields
    // @@protoc_insertion_point(special_field:BluetoothDeviceUnpairingResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a BluetoothDeviceUnpairingResponse {
    fn default() -> &'a BluetoothDeviceUnpairingResponse {
        <BluetoothDeviceUnpairingResponse as ::protobuf::Message>::default_instance()
    }
}

impl BluetoothDeviceUnpairingResponse {
    pub fn new() -> BluetoothDeviceUnpairingResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "address",
            |m: &BluetoothDeviceUnpairingResponse| { &m.address },
            |m: &mut BluetoothDeviceUnpairingResponse| { &mut m.address },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "success",
            |m: &BluetoothDeviceUnpairingResponse| { &m.success },
            |m: &mut BluetoothDeviceUnpairingResponse| { &mut m.success },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "error",
            |m: &BluetoothDeviceUnpairingResponse| { &m.error },
            |m: &mut BluetoothDeviceUnpairingResponse| { &mut m.error },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<BluetoothDeviceUnpairingResponse>(
            "BluetoothDeviceUnpairingResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for BluetoothDeviceUnpairingResponse {
    const NAME: &'static str = "BluetoothDeviceUnpairingResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.address = is.read_uint64()?;
                },
                16 => {
                    self.success = is.read_bool()?;
                },
                24 => {
                    self.error = is.read_int32()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.address != 0 {
            my_size += ::protobuf::rt::uint64_size(1, self.address);
        }
        if self.success != false {
            my_size += 1 + 1;
        }
        if self.error != 0 {
            my_size += ::protobuf::rt::int32_size(3, self.error);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.address != 0 {
            os.write_uint64(1, self.address)?;
        }
        if self.success != false {
            os.write_bool(2, self.success)?;
        }
        if self.error != 0 {
            os.write_int32(3, self.error)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> BluetoothDeviceUnpairingResponse {
        BluetoothDeviceUnpairingResponse::new()
    }

    fn clear(&mut self) {
        self.address = 0;
        self.success = false;
        self.error = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static BluetoothDeviceUnpairingResponse {
        static instance: BluetoothDeviceUnpairingResponse = BluetoothDeviceUnpairingResponse {
            address: 0,
            success: false,
            error: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for BluetoothDeviceUnpairingResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("BluetoothDeviceUnpairingResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for BluetoothDeviceUnpairingResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for BluetoothDeviceUnpairingResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:UnsubscribeBluetoothLEAdvertisementsRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct UnsubscribeBluetoothLEAdvertisementsRequest {
    // special fields
    // @@protoc_insertion_point(special_field:UnsubscribeBluetoothLEAdvertisementsRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a UnsubscribeBluetoothLEAdvertisementsRequest {
    fn default() -> &'a UnsubscribeBluetoothLEAdvertisementsRequest {
        <UnsubscribeBluetoothLEAdvertisementsRequest as ::protobuf::Message>::default_instance()
    }
}

impl UnsubscribeBluetoothLEAdvertisementsRequest {
    pub fn new() -> UnsubscribeBluetoothLEAdvertisementsRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(0);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<UnsubscribeBluetoothLEAdvertisementsRequest>(
            "UnsubscribeBluetoothLEAdvertisementsRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for UnsubscribeBluetoothLEAdvertisementsRequest {
    const NAME: &'static str = "UnsubscribeBluetoothLEAdvertisementsRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> UnsubscribeBluetoothLEAdvertisementsRequest {
        UnsubscribeBluetoothLEAdvertisementsRequest::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static UnsubscribeBluetoothLEAdvertisementsRequest {
        static instance: UnsubscribeBluetoothLEAdvertisementsRequest = UnsubscribeBluetoothLEAdvertisementsRequest {
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for UnsubscribeBluetoothLEAdvertisementsRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("UnsubscribeBluetoothLEAdvertisementsRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for UnsubscribeBluetoothLEAdvertisementsRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for UnsubscribeBluetoothLEAdvertisementsRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:BluetoothDeviceClearCacheResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct BluetoothDeviceClearCacheResponse {
    // message fields
    // @@protoc_insertion_point(field:BluetoothDeviceClearCacheResponse.address)
    pub address: u64,
    // @@protoc_insertion_point(field:BluetoothDeviceClearCacheResponse.success)
    pub success: bool,
    // @@protoc_insertion_point(field:BluetoothDeviceClearCacheResponse.error)
    pub error: i32,
    // special fields
    // @@protoc_insertion_point(special_field:BluetoothDeviceClearCacheResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a BluetoothDeviceClearCacheResponse {
    fn default() -> &'a BluetoothDeviceClearCacheResponse {
        <BluetoothDeviceClearCacheResponse as ::protobuf::Message>::default_instance()
    }
}

impl BluetoothDeviceClearCacheResponse {
    pub fn new() -> BluetoothDeviceClearCacheResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "address",
            |m: &BluetoothDeviceClearCacheResponse| { &m.address },
            |m: &mut BluetoothDeviceClearCacheResponse| { &mut m.address },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "success",
            |m: &BluetoothDeviceClearCacheResponse| { &m.success },
            |m: &mut BluetoothDeviceClearCacheResponse| { &mut m.success },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "error",
            |m: &BluetoothDeviceClearCacheResponse| { &m.error },
            |m: &mut BluetoothDeviceClearCacheResponse| { &mut m.error },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<BluetoothDeviceClearCacheResponse>(
            "BluetoothDeviceClearCacheResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for BluetoothDeviceClearCacheResponse {
    const NAME: &'static str = "BluetoothDeviceClearCacheResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.address = is.read_uint64()?;
                },
                16 => {
                    self.success = is.read_bool()?;
                },
                24 => {
                    self.error = is.read_int32()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.address != 0 {
            my_size += ::protobuf::rt::uint64_size(1, self.address);
        }
        if self.success != false {
            my_size += 1 + 1;
        }
        if self.error != 0 {
            my_size += ::protobuf::rt::int32_size(3, self.error);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.address != 0 {
            os.write_uint64(1, self.address)?;
        }
        if self.success != false {
            os.write_bool(2, self.success)?;
        }
        if self.error != 0 {
            os.write_int32(3, self.error)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> BluetoothDeviceClearCacheResponse {
        BluetoothDeviceClearCacheResponse::new()
    }

    fn clear(&mut self) {
        self.address = 0;
        self.success = false;
        self.error = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static BluetoothDeviceClearCacheResponse {
        static instance: BluetoothDeviceClearCacheResponse = BluetoothDeviceClearCacheResponse {
            address: 0,
            success: false,
            error: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for BluetoothDeviceClearCacheResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("BluetoothDeviceClearCacheResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for BluetoothDeviceClearCacheResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for BluetoothDeviceClearCacheResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:BluetoothScannerStateResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct BluetoothScannerStateResponse {
    // message fields
    // @@protoc_insertion_point(field:BluetoothScannerStateResponse.state)
    pub state: ::protobuf::EnumOrUnknown<BluetoothScannerState>,
    // @@protoc_insertion_point(field:BluetoothScannerStateResponse.mode)
    pub mode: ::protobuf::EnumOrUnknown<BluetoothScannerMode>,
    // special fields
    // @@protoc_insertion_point(special_field:BluetoothScannerStateResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a BluetoothScannerStateResponse {
    fn default() -> &'a BluetoothScannerStateResponse {
        <BluetoothScannerStateResponse as ::protobuf::Message>::default_instance()
    }
}

impl BluetoothScannerStateResponse {
    pub fn new() -> BluetoothScannerStateResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "state",
            |m: &BluetoothScannerStateResponse| { &m.state },
            |m: &mut BluetoothScannerStateResponse| { &mut m.state },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "mode",
            |m: &BluetoothScannerStateResponse| { &m.mode },
            |m: &mut BluetoothScannerStateResponse| { &mut m.mode },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<BluetoothScannerStateResponse>(
            "BluetoothScannerStateResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for BluetoothScannerStateResponse {
    const NAME: &'static str = "BluetoothScannerStateResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.state = is.read_enum_or_unknown()?;
                },
                16 => {
                    self.mode = is.read_enum_or_unknown()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.state != ::protobuf::EnumOrUnknown::new(BluetoothScannerState::BLUETOOTH_SCANNER_STATE_IDLE) {
            my_size += ::protobuf::rt::int32_size(1, self.state.value());
        }
        if self.mode != ::protobuf::EnumOrUnknown::new(BluetoothScannerMode::BLUETOOTH_SCANNER_MODE_PASSIVE) {
            my_size += ::protobuf::rt::int32_size(2, self.mode.value());
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.state != ::protobuf::EnumOrUnknown::new(BluetoothScannerState::BLUETOOTH_SCANNER_STATE_IDLE) {
            os.write_enum(1, ::protobuf::EnumOrUnknown::value(&self.state))?;
        }
        if self.mode != ::protobuf::EnumOrUnknown::new(BluetoothScannerMode::BLUETOOTH_SCANNER_MODE_PASSIVE) {
            os.write_enum(2, ::protobuf::EnumOrUnknown::value(&self.mode))?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> BluetoothScannerStateResponse {
        BluetoothScannerStateResponse::new()
    }

    fn clear(&mut self) {
        self.state = ::protobuf::EnumOrUnknown::new(BluetoothScannerState::BLUETOOTH_SCANNER_STATE_IDLE);
        self.mode = ::protobuf::EnumOrUnknown::new(BluetoothScannerMode::BLUETOOTH_SCANNER_MODE_PASSIVE);
        self.special_fields.clear();
    }

    fn default_instance() -> &'static BluetoothScannerStateResponse {
        static instance: BluetoothScannerStateResponse = BluetoothScannerStateResponse {
            state: ::protobuf::EnumOrUnknown::from_i32(0),
            mode: ::protobuf::EnumOrUnknown::from_i32(0),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for BluetoothScannerStateResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("BluetoothScannerStateResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for BluetoothScannerStateResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for BluetoothScannerStateResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:BluetoothScannerSetModeRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct BluetoothScannerSetModeRequest {
    // message fields
    // @@protoc_insertion_point(field:BluetoothScannerSetModeRequest.mode)
    pub mode: ::protobuf::EnumOrUnknown<BluetoothScannerMode>,
    // special fields
    // @@protoc_insertion_point(special_field:BluetoothScannerSetModeRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a BluetoothScannerSetModeRequest {
    fn default() -> &'a BluetoothScannerSetModeRequest {
        <BluetoothScannerSetModeRequest as ::protobuf::Message>::default_instance()
    }
}

impl BluetoothScannerSetModeRequest {
    pub fn new() -> BluetoothScannerSetModeRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "mode",
            |m: &BluetoothScannerSetModeRequest| { &m.mode },
            |m: &mut BluetoothScannerSetModeRequest| { &mut m.mode },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<BluetoothScannerSetModeRequest>(
            "BluetoothScannerSetModeRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for BluetoothScannerSetModeRequest {
    const NAME: &'static str = "BluetoothScannerSetModeRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.mode = is.read_enum_or_unknown()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.mode != ::protobuf::EnumOrUnknown::new(BluetoothScannerMode::BLUETOOTH_SCANNER_MODE_PASSIVE) {
            my_size += ::protobuf::rt::int32_size(1, self.mode.value());
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.mode != ::protobuf::EnumOrUnknown::new(BluetoothScannerMode::BLUETOOTH_SCANNER_MODE_PASSIVE) {
            os.write_enum(1, ::protobuf::EnumOrUnknown::value(&self.mode))?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> BluetoothScannerSetModeRequest {
        BluetoothScannerSetModeRequest::new()
    }

    fn clear(&mut self) {
        self.mode = ::protobuf::EnumOrUnknown::new(BluetoothScannerMode::BLUETOOTH_SCANNER_MODE_PASSIVE);
        self.special_fields.clear();
    }

    fn default_instance() -> &'static BluetoothScannerSetModeRequest {
        static instance: BluetoothScannerSetModeRequest = BluetoothScannerSetModeRequest {
            mode: ::protobuf::EnumOrUnknown::from_i32(0),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for BluetoothScannerSetModeRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("BluetoothScannerSetModeRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for BluetoothScannerSetModeRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for BluetoothScannerSetModeRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:SubscribeVoiceAssistantRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct SubscribeVoiceAssistantRequest {
    // message fields
    // @@protoc_insertion_point(field:SubscribeVoiceAssistantRequest.subscribe)
    pub subscribe: bool,
    // @@protoc_insertion_point(field:SubscribeVoiceAssistantRequest.flags)
    pub flags: u32,
    // special fields
    // @@protoc_insertion_point(special_field:SubscribeVoiceAssistantRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a SubscribeVoiceAssistantRequest {
    fn default() -> &'a SubscribeVoiceAssistantRequest {
        <SubscribeVoiceAssistantRequest as ::protobuf::Message>::default_instance()
    }
}

impl SubscribeVoiceAssistantRequest {
    pub fn new() -> SubscribeVoiceAssistantRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "subscribe",
            |m: &SubscribeVoiceAssistantRequest| { &m.subscribe },
            |m: &mut SubscribeVoiceAssistantRequest| { &mut m.subscribe },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "flags",
            |m: &SubscribeVoiceAssistantRequest| { &m.flags },
            |m: &mut SubscribeVoiceAssistantRequest| { &mut m.flags },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<SubscribeVoiceAssistantRequest>(
            "SubscribeVoiceAssistantRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for SubscribeVoiceAssistantRequest {
    const NAME: &'static str = "SubscribeVoiceAssistantRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.subscribe = is.read_bool()?;
                },
                16 => {
                    self.flags = is.read_uint32()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.subscribe != false {
            my_size += 1 + 1;
        }
        if self.flags != 0 {
            my_size += ::protobuf::rt::uint32_size(2, self.flags);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.subscribe != false {
            os.write_bool(1, self.subscribe)?;
        }
        if self.flags != 0 {
            os.write_uint32(2, self.flags)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> SubscribeVoiceAssistantRequest {
        SubscribeVoiceAssistantRequest::new()
    }

    fn clear(&mut self) {
        self.subscribe = false;
        self.flags = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static SubscribeVoiceAssistantRequest {
        static instance: SubscribeVoiceAssistantRequest = SubscribeVoiceAssistantRequest {
            subscribe: false,
            flags: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for SubscribeVoiceAssistantRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("SubscribeVoiceAssistantRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for SubscribeVoiceAssistantRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for SubscribeVoiceAssistantRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:VoiceAssistantAudioSettings)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct VoiceAssistantAudioSettings {
    // message fields
    // @@protoc_insertion_point(field:VoiceAssistantAudioSettings.noise_suppression_level)
    pub noise_suppression_level: u32,
    // @@protoc_insertion_point(field:VoiceAssistantAudioSettings.auto_gain)
    pub auto_gain: u32,
    // @@protoc_insertion_point(field:VoiceAssistantAudioSettings.volume_multiplier)
    pub volume_multiplier: f32,
    // special fields
    // @@protoc_insertion_point(special_field:VoiceAssistantAudioSettings.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a VoiceAssistantAudioSettings {
    fn default() -> &'a VoiceAssistantAudioSettings {
        <VoiceAssistantAudioSettings as ::protobuf::Message>::default_instance()
    }
}

impl VoiceAssistantAudioSettings {
    pub fn new() -> VoiceAssistantAudioSettings {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "noise_suppression_level",
            |m: &VoiceAssistantAudioSettings| { &m.noise_suppression_level },
            |m: &mut VoiceAssistantAudioSettings| { &mut m.noise_suppression_level },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "auto_gain",
            |m: &VoiceAssistantAudioSettings| { &m.auto_gain },
            |m: &mut VoiceAssistantAudioSettings| { &mut m.auto_gain },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "volume_multiplier",
            |m: &VoiceAssistantAudioSettings| { &m.volume_multiplier },
            |m: &mut VoiceAssistantAudioSettings| { &mut m.volume_multiplier },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<VoiceAssistantAudioSettings>(
            "VoiceAssistantAudioSettings",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for VoiceAssistantAudioSettings {
    const NAME: &'static str = "VoiceAssistantAudioSettings";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.noise_suppression_level = is.read_uint32()?;
                },
                16 => {
                    self.auto_gain = is.read_uint32()?;
                },
                29 => {
                    self.volume_multiplier = is.read_float()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.noise_suppression_level != 0 {
            my_size += ::protobuf::rt::uint32_size(1, self.noise_suppression_level);
        }
        if self.auto_gain != 0 {
            my_size += ::protobuf::rt::uint32_size(2, self.auto_gain);
        }
        if self.volume_multiplier != 0. {
            my_size += 1 + 4;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.noise_suppression_level != 0 {
            os.write_uint32(1, self.noise_suppression_level)?;
        }
        if self.auto_gain != 0 {
            os.write_uint32(2, self.auto_gain)?;
        }
        if self.volume_multiplier != 0. {
            os.write_float(3, self.volume_multiplier)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> VoiceAssistantAudioSettings {
        VoiceAssistantAudioSettings::new()
    }

    fn clear(&mut self) {
        self.noise_suppression_level = 0;
        self.auto_gain = 0;
        self.volume_multiplier = 0.;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static VoiceAssistantAudioSettings {
        static instance: VoiceAssistantAudioSettings = VoiceAssistantAudioSettings {
            noise_suppression_level: 0,
            auto_gain: 0,
            volume_multiplier: 0.,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for VoiceAssistantAudioSettings {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("VoiceAssistantAudioSettings").unwrap()).clone()
    }
}

impl ::std::fmt::Display for VoiceAssistantAudioSettings {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for VoiceAssistantAudioSettings {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:VoiceAssistantRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct VoiceAssistantRequest {
    // message fields
    // @@protoc_insertion_point(field:VoiceAssistantRequest.start)
    pub start: bool,
    // @@protoc_insertion_point(field:VoiceAssistantRequest.conversation_id)
    pub conversation_id: ::std::string::String,
    // @@protoc_insertion_point(field:VoiceAssistantRequest.flags)
    pub flags: u32,
    // @@protoc_insertion_point(field:VoiceAssistantRequest.audio_settings)
    pub audio_settings: ::protobuf::MessageField<VoiceAssistantAudioSettings>,
    // @@protoc_insertion_point(field:VoiceAssistantRequest.wake_word_phrase)
    pub wake_word_phrase: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:VoiceAssistantRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a VoiceAssistantRequest {
    fn default() -> &'a VoiceAssistantRequest {
        <VoiceAssistantRequest as ::protobuf::Message>::default_instance()
    }
}

impl VoiceAssistantRequest {
    pub fn new() -> VoiceAssistantRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(5);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "start",
            |m: &VoiceAssistantRequest| { &m.start },
            |m: &mut VoiceAssistantRequest| { &mut m.start },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "conversation_id",
            |m: &VoiceAssistantRequest| { &m.conversation_id },
            |m: &mut VoiceAssistantRequest| { &mut m.conversation_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "flags",
            |m: &VoiceAssistantRequest| { &m.flags },
            |m: &mut VoiceAssistantRequest| { &mut m.flags },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_message_field_accessor::<_, VoiceAssistantAudioSettings>(
            "audio_settings",
            |m: &VoiceAssistantRequest| { &m.audio_settings },
            |m: &mut VoiceAssistantRequest| { &mut m.audio_settings },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "wake_word_phrase",
            |m: &VoiceAssistantRequest| { &m.wake_word_phrase },
            |m: &mut VoiceAssistantRequest| { &mut m.wake_word_phrase },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<VoiceAssistantRequest>(
            "VoiceAssistantRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for VoiceAssistantRequest {
    const NAME: &'static str = "VoiceAssistantRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.start = is.read_bool()?;
                },
                18 => {
                    self.conversation_id = is.read_string()?;
                },
                24 => {
                    self.flags = is.read_uint32()?;
                },
                34 => {
                    ::protobuf::rt::read_singular_message_into_field(is, &mut self.audio_settings)?;
                },
                42 => {
                    self.wake_word_phrase = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.start != false {
            my_size += 1 + 1;
        }
        if !self.conversation_id.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.conversation_id);
        }
        if self.flags != 0 {
            my_size += ::protobuf::rt::uint32_size(3, self.flags);
        }
        if let Some(v) = self.audio_settings.as_ref() {
            let len = v.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        }
        if !self.wake_word_phrase.is_empty() {
            my_size += ::protobuf::rt::string_size(5, &self.wake_word_phrase);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.start != false {
            os.write_bool(1, self.start)?;
        }
        if !self.conversation_id.is_empty() {
            os.write_string(2, &self.conversation_id)?;
        }
        if self.flags != 0 {
            os.write_uint32(3, self.flags)?;
        }
        if let Some(v) = self.audio_settings.as_ref() {
            ::protobuf::rt::write_message_field_with_cached_size(4, v, os)?;
        }
        if !self.wake_word_phrase.is_empty() {
            os.write_string(5, &self.wake_word_phrase)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> VoiceAssistantRequest {
        VoiceAssistantRequest::new()
    }

    fn clear(&mut self) {
        self.start = false;
        self.conversation_id.clear();
        self.flags = 0;
        self.audio_settings.clear();
        self.wake_word_phrase.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static VoiceAssistantRequest {
        static instance: VoiceAssistantRequest = VoiceAssistantRequest {
            start: false,
            conversation_id: ::std::string::String::new(),
            flags: 0,
            audio_settings: ::protobuf::MessageField::none(),
            wake_word_phrase: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for VoiceAssistantRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("VoiceAssistantRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for VoiceAssistantRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for VoiceAssistantRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:VoiceAssistantResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct VoiceAssistantResponse {
    // message fields
    // @@protoc_insertion_point(field:VoiceAssistantResponse.port)
    pub port: u32,
    // @@protoc_insertion_point(field:VoiceAssistantResponse.error)
    pub error: bool,
    // special fields
    // @@protoc_insertion_point(special_field:VoiceAssistantResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a VoiceAssistantResponse {
    fn default() -> &'a VoiceAssistantResponse {
        <VoiceAssistantResponse as ::protobuf::Message>::default_instance()
    }
}

impl VoiceAssistantResponse {
    pub fn new() -> VoiceAssistantResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "port",
            |m: &VoiceAssistantResponse| { &m.port },
            |m: &mut VoiceAssistantResponse| { &mut m.port },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "error",
            |m: &VoiceAssistantResponse| { &m.error },
            |m: &mut VoiceAssistantResponse| { &mut m.error },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<VoiceAssistantResponse>(
            "VoiceAssistantResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for VoiceAssistantResponse {
    const NAME: &'static str = "VoiceAssistantResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.port = is.read_uint32()?;
                },
                16 => {
                    self.error = is.read_bool()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.port != 0 {
            my_size += ::protobuf::rt::uint32_size(1, self.port);
        }
        if self.error != false {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.port != 0 {
            os.write_uint32(1, self.port)?;
        }
        if self.error != false {
            os.write_bool(2, self.error)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> VoiceAssistantResponse {
        VoiceAssistantResponse::new()
    }

    fn clear(&mut self) {
        self.port = 0;
        self.error = false;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static VoiceAssistantResponse {
        static instance: VoiceAssistantResponse = VoiceAssistantResponse {
            port: 0,
            error: false,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for VoiceAssistantResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("VoiceAssistantResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for VoiceAssistantResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for VoiceAssistantResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:VoiceAssistantEventData)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct VoiceAssistantEventData {
    // message fields
    // @@protoc_insertion_point(field:VoiceAssistantEventData.name)
    pub name: ::std::string::String,
    // @@protoc_insertion_point(field:VoiceAssistantEventData.value)
    pub value: ::std::string::String,
    // special fields
    // @@protoc_insertion_point(special_field:VoiceAssistantEventData.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a VoiceAssistantEventData {
    fn default() -> &'a VoiceAssistantEventData {
        <VoiceAssistantEventData as ::protobuf::Message>::default_instance()
    }
}

impl VoiceAssistantEventData {
    pub fn new() -> VoiceAssistantEventData {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "name",
            |m: &VoiceAssistantEventData| { &m.name },
            |m: &mut VoiceAssistantEventData| { &mut m.name },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "value",
            |m: &VoiceAssistantEventData| { &m.value },
            |m: &mut VoiceAssistantEventData| { &mut m.value },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<VoiceAssistantEventData>(
            "VoiceAssistantEventData",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for VoiceAssistantEventData {
    const NAME: &'static str = "VoiceAssistantEventData";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.name = is.read_string()?;
                },
                18 => {
                    self.value = is.read_string()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.name);
        }
        if !self.value.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.value);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.name.is_empty() {
            os.write_string(1, &self.name)?;
        }
        if !self.value.is_empty() {
            os.write_string(2, &self.value)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> VoiceAssistantEventData {
        VoiceAssistantEventData::new()
    }

    fn clear(&mut self) {
        self.name.clear();
        self.value.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static VoiceAssistantEventData {
        static instance: VoiceAssistantEventData = VoiceAssistantEventData {
            name: ::std::string::String::new(),
            value: ::std::string::String::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for VoiceAssistantEventData {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("VoiceAssistantEventData").unwrap()).clone()
    }
}

impl ::std::fmt::Display for VoiceAssistantEventData {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for VoiceAssistantEventData {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:VoiceAssistantEventResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct VoiceAssistantEventResponse {
    // message fields
    // @@protoc_insertion_point(field:VoiceAssistantEventResponse.event_type)
    pub event_type: ::protobuf::EnumOrUnknown<VoiceAssistantEvent>,
    // @@protoc_insertion_point(field:VoiceAssistantEventResponse.data)
    pub data: ::std::vec::Vec<VoiceAssistantEventData>,
    // special fields
    // @@protoc_insertion_point(special_field:VoiceAssistantEventResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a VoiceAssistantEventResponse {
    fn default() -> &'a VoiceAssistantEventResponse {
        <VoiceAssistantEventResponse as ::protobuf::Message>::default_instance()
    }
}

impl VoiceAssistantEventResponse {
    pub fn new() -> VoiceAssistantEventResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "event_type",
            |m: &VoiceAssistantEventResponse| { &m.event_type },
            |m: &mut VoiceAssistantEventResponse| { &mut m.event_type },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "data",
            |m: &VoiceAssistantEventResponse| { &m.data },
            |m: &mut VoiceAssistantEventResponse| { &mut m.data },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<VoiceAssistantEventResponse>(
            "VoiceAssistantEventResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for VoiceAssistantEventResponse {
    const NAME: &'static str = "VoiceAssistantEventResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.event_type = is.read_enum_or_unknown()?;
                },
                18 => {
                    self.data.push(is.read_message()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.event_type != ::protobuf::EnumOrUnknown::new(VoiceAssistantEvent::VOICE_ASSISTANT_ERROR) {
            my_size += ::protobuf::rt::int32_size(1, self.event_type.value());
        }
        for value in &self.data {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.event_type != ::protobuf::EnumOrUnknown::new(VoiceAssistantEvent::VOICE_ASSISTANT_ERROR) {
            os.write_enum(1, ::protobuf::EnumOrUnknown::value(&self.event_type))?;
        }
        for v in &self.data {
            ::protobuf::rt::write_message_field_with_cached_size(2, v, os)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> VoiceAssistantEventResponse {
        VoiceAssistantEventResponse::new()
    }

    fn clear(&mut self) {
        self.event_type = ::protobuf::EnumOrUnknown::new(VoiceAssistantEvent::VOICE_ASSISTANT_ERROR);
        self.data.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static VoiceAssistantEventResponse {
        static instance: VoiceAssistantEventResponse = VoiceAssistantEventResponse {
            event_type: ::protobuf::EnumOrUnknown::from_i32(0),
            data: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for VoiceAssistantEventResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("VoiceAssistantEventResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for VoiceAssistantEventResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for VoiceAssistantEventResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:VoiceAssistantAudio)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct VoiceAssistantAudio {
    // message fields
    // @@protoc_insertion_point(field:VoiceAssistantAudio.data)
    pub data: ::std::vec::Vec<u8>,
    // @@protoc_insertion_point(field:VoiceAssistantAudio.end)
    pub end: bool,
    // special fields
    // @@protoc_insertion_point(special_field:VoiceAssistantAudio.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a VoiceAssistantAudio {
    fn default() -> &'a VoiceAssistantAudio {
        <VoiceAssistantAudio as ::protobuf::Message>::default_instance()
    }
}

impl VoiceAssistantAudio {
    pub fn new() -> VoiceAssistantAudio {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(2);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "data",
            |m: &VoiceAssistantAudio| { &m.data },
            |m: &mut VoiceAssistantAudio| { &mut m.data },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "end",
            |m: &VoiceAssistantAudio| { &m.end },
            |m: &mut VoiceAssistantAudio| { &mut m.end },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<VoiceAssistantAudio>(
            "VoiceAssistantAudio",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for VoiceAssistantAudio {
    const NAME: &'static str = "VoiceAssistantAudio";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.data = is.read_bytes()?;
                },
                16 => {
                    self.end = is.read_bool()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.data.is_empty() {
            my_size += ::protobuf::rt::bytes_size(1, &self.data);
        }
        if self.end != false {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.data.is_empty() {
            os.write_bytes(1, &self.data)?;
        }
        if self.end != false {
            os.write_bool(2, self.end)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> VoiceAssistantAudio {
        VoiceAssistantAudio::new()
    }

    fn clear(&mut self) {
        self.data.clear();
        self.end = false;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static VoiceAssistantAudio {
        static instance: VoiceAssistantAudio = VoiceAssistantAudio {
            data: ::std::vec::Vec::new(),
            end: false,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for VoiceAssistantAudio {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("VoiceAssistantAudio").unwrap()).clone()
    }
}

impl ::std::fmt::Display for VoiceAssistantAudio {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for VoiceAssistantAudio {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:VoiceAssistantTimerEventResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct VoiceAssistantTimerEventResponse {
    // message fields
    // @@protoc_insertion_point(field:VoiceAssistantTimerEventResponse.event_type)
    pub event_type: ::protobuf::EnumOrUnknown<VoiceAssistantTimerEvent>,
    // @@protoc_insertion_point(field:VoiceAssistantTimerEventResponse.timer_id)
    pub timer_id: ::std::string::String,
    // @@protoc_insertion_point(field:VoiceAssistantTimerEventResponse.name)
    pub name: ::std::string::String,
    // @@protoc_insertion_point(field:VoiceAssistantTimerEventResponse.total_seconds)
    pub total_seconds: u32,
    // @@protoc_insertion_point(field:VoiceAssistantTimerEventResponse.seconds_left)
    pub seconds_left: u32,
    // @@protoc_insertion_point(field:VoiceAssistantTimerEventResponse.is_active)
    pub is_active: bool,
    // special fields
    // @@protoc_insertion_point(special_field:VoiceAssistantTimerEventResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a VoiceAssistantTimerEventResponse {
    fn default() -> &'a VoiceAssistantTimerEventResponse {
        <VoiceAssistantTimerEventResponse as ::protobuf::Message>::default_instance()
    }
}

impl VoiceAssistantTimerEventResponse {
    pub fn new() -> VoiceAssistantTimerEventResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(6);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "event_type",
            |m: &VoiceAssistantTimerEventResponse| { &m.event_type },
            |m: &mut VoiceAssistantTimerEventResponse| { &mut m.event_type },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "timer_id",
            |m: &VoiceAssistantTimerEventResponse| { &m.timer_id },
            |m: &mut VoiceAssistantTimerEventResponse| { &mut m.timer_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "name",
            |m: &VoiceAssistantTimerEventResponse| { &m.name },
            |m: &mut VoiceAssistantTimerEventResponse| { &mut m.name },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "total_seconds",
            |m: &VoiceAssistantTimerEventResponse| { &m.total_seconds },
            |m: &mut VoiceAssistantTimerEventResponse| { &mut m.total_seconds },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "seconds_left",
            |m: &VoiceAssistantTimerEventResponse| { &m.seconds_left },
            |m: &mut VoiceAssistantTimerEventResponse| { &mut m.seconds_left },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "is_active",
            |m: &VoiceAssistantTimerEventResponse| { &m.is_active },
            |m: &mut VoiceAssistantTimerEventResponse| { &mut m.is_active },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<VoiceAssistantTimerEventResponse>(
            "VoiceAssistantTimerEventResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for VoiceAssistantTimerEventResponse {
    const NAME: &'static str = "VoiceAssistantTimerEventResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.event_type = is.read_enum_or_unknown()?;
                },
                18 => {
                    self.timer_id = is.read_string()?;
                },
                26 => {
                    self.name = is.read_string()?;
                },
                32 => {
                    self.total_seconds = is.read_uint32()?;
                },
                40 => {
                    self.seconds_left = is.read_uint32()?;
                },
                48 => {
                    self.is_active = is.read_bool()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.event_type != ::protobuf::EnumOrUnknown::new(VoiceAssistantTimerEvent::VOICE_ASSISTANT_TIMER_STARTED) {
            my_size += ::protobuf::rt::int32_size(1, self.event_type.value());
        }
        if !self.timer_id.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.timer_id);
        }
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.name);
        }
        if self.total_seconds != 0 {
            my_size += ::protobuf::rt::uint32_size(4, self.total_seconds);
        }
        if self.seconds_left != 0 {
            my_size += ::protobuf::rt::uint32_size(5, self.seconds_left);
        }
        if self.is_active != false {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.event_type != ::protobuf::EnumOrUnknown::new(VoiceAssistantTimerEvent::VOICE_ASSISTANT_TIMER_STARTED) {
            os.write_enum(1, ::protobuf::EnumOrUnknown::value(&self.event_type))?;
        }
        if !self.timer_id.is_empty() {
            os.write_string(2, &self.timer_id)?;
        }
        if !self.name.is_empty() {
            os.write_string(3, &self.name)?;
        }
        if self.total_seconds != 0 {
            os.write_uint32(4, self.total_seconds)?;
        }
        if self.seconds_left != 0 {
            os.write_uint32(5, self.seconds_left)?;
        }
        if self.is_active != false {
            os.write_bool(6, self.is_active)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> VoiceAssistantTimerEventResponse {
        VoiceAssistantTimerEventResponse::new()
    }

    fn clear(&mut self) {
        self.event_type = ::protobuf::EnumOrUnknown::new(VoiceAssistantTimerEvent::VOICE_ASSISTANT_TIMER_STARTED);
        self.timer_id.clear();
        self.name.clear();
        self.total_seconds = 0;
        self.seconds_left = 0;
        self.is_active = false;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static VoiceAssistantTimerEventResponse {
        static instance: VoiceAssistantTimerEventResponse = VoiceAssistantTimerEventResponse {
            event_type: ::protobuf::EnumOrUnknown::from_i32(0),
            timer_id: ::std::string::String::new(),
            name: ::std::string::String::new(),
            total_seconds: 0,
            seconds_left: 0,
            is_active: false,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for VoiceAssistantTimerEventResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("VoiceAssistantTimerEventResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for VoiceAssistantTimerEventResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for VoiceAssistantTimerEventResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:VoiceAssistantAnnounceRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct VoiceAssistantAnnounceRequest {
    // message fields
    // @@protoc_insertion_point(field:VoiceAssistantAnnounceRequest.media_id)
    pub media_id: ::std::string::String,
    // @@protoc_insertion_point(field:VoiceAssistantAnnounceRequest.text)
    pub text: ::std::string::String,
    // @@protoc_insertion_point(field:VoiceAssistantAnnounceRequest.preannounce_media_id)
    pub preannounce_media_id: ::std::string::String,
    // @@protoc_insertion_point(field:VoiceAssistantAnnounceRequest.start_conversation)
    pub start_conversation: bool,
    // special fields
    // @@protoc_insertion_point(special_field:VoiceAssistantAnnounceRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a VoiceAssistantAnnounceRequest {
    fn default() -> &'a VoiceAssistantAnnounceRequest {
        <VoiceAssistantAnnounceRequest as ::protobuf::Message>::default_instance()
    }
}

impl VoiceAssistantAnnounceRequest {
    pub fn new() -> VoiceAssistantAnnounceRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "media_id",
            |m: &VoiceAssistantAnnounceRequest| { &m.media_id },
            |m: &mut VoiceAssistantAnnounceRequest| { &mut m.media_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "text",
            |m: &VoiceAssistantAnnounceRequest| { &m.text },
            |m: &mut VoiceAssistantAnnounceRequest| { &mut m.text },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "preannounce_media_id",
            |m: &VoiceAssistantAnnounceRequest| { &m.preannounce_media_id },
            |m: &mut VoiceAssistantAnnounceRequest| { &mut m.preannounce_media_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "start_conversation",
            |m: &VoiceAssistantAnnounceRequest| { &m.start_conversation },
            |m: &mut VoiceAssistantAnnounceRequest| { &mut m.start_conversation },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<VoiceAssistantAnnounceRequest>(
            "VoiceAssistantAnnounceRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for VoiceAssistantAnnounceRequest {
    const NAME: &'static str = "VoiceAssistantAnnounceRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.media_id = is.read_string()?;
                },
                18 => {
                    self.text = is.read_string()?;
                },
                26 => {
                    self.preannounce_media_id = is.read_string()?;
                },
                32 => {
                    self.start_conversation = is.read_bool()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.media_id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.media_id);
        }
        if !self.text.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.text);
        }
        if !self.preannounce_media_id.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.preannounce_media_id);
        }
        if self.start_conversation != false {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.media_id.is_empty() {
            os.write_string(1, &self.media_id)?;
        }
        if !self.text.is_empty() {
            os.write_string(2, &self.text)?;
        }
        if !self.preannounce_media_id.is_empty() {
            os.write_string(3, &self.preannounce_media_id)?;
        }
        if self.start_conversation != false {
            os.write_bool(4, self.start_conversation)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> VoiceAssistantAnnounceRequest {
        VoiceAssistantAnnounceRequest::new()
    }

    fn clear(&mut self) {
        self.media_id.clear();
        self.text.clear();
        self.preannounce_media_id.clear();
        self.start_conversation = false;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static VoiceAssistantAnnounceRequest {
        static instance: VoiceAssistantAnnounceRequest = VoiceAssistantAnnounceRequest {
            media_id: ::std::string::String::new(),
            text: ::std::string::String::new(),
            preannounce_media_id: ::std::string::String::new(),
            start_conversation: false,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for VoiceAssistantAnnounceRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("VoiceAssistantAnnounceRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for VoiceAssistantAnnounceRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for VoiceAssistantAnnounceRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:VoiceAssistantAnnounceFinished)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct VoiceAssistantAnnounceFinished {
    // message fields
    // @@protoc_insertion_point(field:VoiceAssistantAnnounceFinished.success)
    pub success: bool,
    // special fields
    // @@protoc_insertion_point(special_field:VoiceAssistantAnnounceFinished.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a VoiceAssistantAnnounceFinished {
    fn default() -> &'a VoiceAssistantAnnounceFinished {
        <VoiceAssistantAnnounceFinished as ::protobuf::Message>::default_instance()
    }
}

impl VoiceAssistantAnnounceFinished {
    pub fn new() -> VoiceAssistantAnnounceFinished {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "success",
            |m: &VoiceAssistantAnnounceFinished| { &m.success },
            |m: &mut VoiceAssistantAnnounceFinished| { &mut m.success },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<VoiceAssistantAnnounceFinished>(
            "VoiceAssistantAnnounceFinished",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for VoiceAssistantAnnounceFinished {
    const NAME: &'static str = "VoiceAssistantAnnounceFinished";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                8 => {
                    self.success = is.read_bool()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.success != false {
            my_size += 1 + 1;
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.success != false {
            os.write_bool(1, self.success)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> VoiceAssistantAnnounceFinished {
        VoiceAssistantAnnounceFinished::new()
    }

    fn clear(&mut self) {
        self.success = false;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static VoiceAssistantAnnounceFinished {
        static instance: VoiceAssistantAnnounceFinished = VoiceAssistantAnnounceFinished {
            success: false,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for VoiceAssistantAnnounceFinished {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("VoiceAssistantAnnounceFinished").unwrap()).clone()
    }
}

impl ::std::fmt::Display for VoiceAssistantAnnounceFinished {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for VoiceAssistantAnnounceFinished {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:VoiceAssistantWakeWord)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct VoiceAssistantWakeWord {
    // message fields
    // @@protoc_insertion_point(field:VoiceAssistantWakeWord.id)
    pub id: ::std::string::String,
    // @@protoc_insertion_point(field:VoiceAssistantWakeWord.wake_word)
    pub wake_word: ::std::string::String,
    // @@protoc_insertion_point(field:VoiceAssistantWakeWord.trained_languages)
    pub trained_languages: ::std::vec::Vec<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:VoiceAssistantWakeWord.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a VoiceAssistantWakeWord {
    fn default() -> &'a VoiceAssistantWakeWord {
        <VoiceAssistantWakeWord as ::protobuf::Message>::default_instance()
    }
}

impl VoiceAssistantWakeWord {
    pub fn new() -> VoiceAssistantWakeWord {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "id",
            |m: &VoiceAssistantWakeWord| { &m.id },
            |m: &mut VoiceAssistantWakeWord| { &mut m.id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "wake_word",
            |m: &VoiceAssistantWakeWord| { &m.wake_word },
            |m: &mut VoiceAssistantWakeWord| { &mut m.wake_word },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "trained_languages",
            |m: &VoiceAssistantWakeWord| { &m.trained_languages },
            |m: &mut VoiceAssistantWakeWord| { &mut m.trained_languages },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<VoiceAssistantWakeWord>(
            "VoiceAssistantWakeWord",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for VoiceAssistantWakeWord {
    const NAME: &'static str = "VoiceAssistantWakeWord";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.id = is.read_string()?;
                },
                18 => {
                    self.wake_word = is.read_string()?;
                },
                26 => {
                    self.trained_languages.push(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.id);
        }
        if !self.wake_word.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.wake_word);
        }
        for value in &self.trained_languages {
            my_size += ::protobuf::rt::string_size(3, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.id.is_empty() {
            os.write_string(1, &self.id)?;
        }
        if !self.wake_word.is_empty() {
            os.write_string(2, &self.wake_word)?;
        }
        for v in &self.trained_languages {
            os.write_string(3, &v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> VoiceAssistantWakeWord {
        VoiceAssistantWakeWord::new()
    }

    fn clear(&mut self) {
        self.id.clear();
        self.wake_word.clear();
        self.trained_languages.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static VoiceAssistantWakeWord {
        static instance: VoiceAssistantWakeWord = VoiceAssistantWakeWord {
            id: ::std::string::String::new(),
            wake_word: ::std::string::String::new(),
            trained_languages: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for VoiceAssistantWakeWord {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("VoiceAssistantWakeWord").unwrap()).clone()
    }
}

impl ::std::fmt::Display for VoiceAssistantWakeWord {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for VoiceAssistantWakeWord {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:VoiceAssistantConfigurationRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct VoiceAssistantConfigurationRequest {
    // special fields
    // @@protoc_insertion_point(special_field:VoiceAssistantConfigurationRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a VoiceAssistantConfigurationRequest {
    fn default() -> &'a VoiceAssistantConfigurationRequest {
        <VoiceAssistantConfigurationRequest as ::protobuf::Message>::default_instance()
    }
}

impl VoiceAssistantConfigurationRequest {
    pub fn new() -> VoiceAssistantConfigurationRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(0);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<VoiceAssistantConfigurationRequest>(
            "VoiceAssistantConfigurationRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for VoiceAssistantConfigurationRequest {
    const NAME: &'static str = "VoiceAssistantConfigurationRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> VoiceAssistantConfigurationRequest {
        VoiceAssistantConfigurationRequest::new()
    }

    fn clear(&mut self) {
        self.special_fields.clear();
    }

    fn default_instance() -> &'static VoiceAssistantConfigurationRequest {
        static instance: VoiceAssistantConfigurationRequest = VoiceAssistantConfigurationRequest {
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for VoiceAssistantConfigurationRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("VoiceAssistantConfigurationRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for VoiceAssistantConfigurationRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for VoiceAssistantConfigurationRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:VoiceAssistantConfigurationResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct VoiceAssistantConfigurationResponse {
    // message fields
    // @@protoc_insertion_point(field:VoiceAssistantConfigurationResponse.available_wake_words)
    pub available_wake_words: ::std::vec::Vec<VoiceAssistantWakeWord>,
    // @@protoc_insertion_point(field:VoiceAssistantConfigurationResponse.active_wake_words)
    pub active_wake_words: ::std::vec::Vec<::std::string::String>,
    // @@protoc_insertion_point(field:VoiceAssistantConfigurationResponse.max_active_wake_words)
    pub max_active_wake_words: u32,
    // special fields
    // @@protoc_insertion_point(special_field:VoiceAssistantConfigurationResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a VoiceAssistantConfigurationResponse {
    fn default() -> &'a VoiceAssistantConfigurationResponse {
        <VoiceAssistantConfigurationResponse as ::protobuf::Message>::default_instance()
    }
}

impl VoiceAssistantConfigurationResponse {
    pub fn new() -> VoiceAssistantConfigurationResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "available_wake_words",
            |m: &VoiceAssistantConfigurationResponse| { &m.available_wake_words },
            |m: &mut VoiceAssistantConfigurationResponse| { &mut m.available_wake_words },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "active_wake_words",
            |m: &VoiceAssistantConfigurationResponse| { &m.active_wake_words },
            |m: &mut VoiceAssistantConfigurationResponse| { &mut m.active_wake_words },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "max_active_wake_words",
            |m: &VoiceAssistantConfigurationResponse| { &m.max_active_wake_words },
            |m: &mut VoiceAssistantConfigurationResponse| { &mut m.max_active_wake_words },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<VoiceAssistantConfigurationResponse>(
            "VoiceAssistantConfigurationResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for VoiceAssistantConfigurationResponse {
    const NAME: &'static str = "VoiceAssistantConfigurationResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.available_wake_words.push(is.read_message()?);
                },
                18 => {
                    self.active_wake_words.push(is.read_string()?);
                },
                24 => {
                    self.max_active_wake_words = is.read_uint32()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.available_wake_words {
            let len = value.compute_size();
            my_size += 1 + ::protobuf::rt::compute_raw_varint64_size(len) + len;
        };
        for value in &self.active_wake_words {
            my_size += ::protobuf::rt::string_size(2, &value);
        };
        if self.max_active_wake_words != 0 {
            my_size += ::protobuf::rt::uint32_size(3, self.max_active_wake_words);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.available_wake_words {
            ::protobuf::rt::write_message_field_with_cached_size(1, v, os)?;
        };
        for v in &self.active_wake_words {
            os.write_string(2, &v)?;
        };
        if self.max_active_wake_words != 0 {
            os.write_uint32(3, self.max_active_wake_words)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> VoiceAssistantConfigurationResponse {
        VoiceAssistantConfigurationResponse::new()
    }

    fn clear(&mut self) {
        self.available_wake_words.clear();
        self.active_wake_words.clear();
        self.max_active_wake_words = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static VoiceAssistantConfigurationResponse {
        static instance: VoiceAssistantConfigurationResponse = VoiceAssistantConfigurationResponse {
            available_wake_words: ::std::vec::Vec::new(),
            active_wake_words: ::std::vec::Vec::new(),
            max_active_wake_words: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for VoiceAssistantConfigurationResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("VoiceAssistantConfigurationResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for VoiceAssistantConfigurationResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for VoiceAssistantConfigurationResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:VoiceAssistantSetConfiguration)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct VoiceAssistantSetConfiguration {
    // message fields
    // @@protoc_insertion_point(field:VoiceAssistantSetConfiguration.active_wake_words)
    pub active_wake_words: ::std::vec::Vec<::std::string::String>,
    // special fields
    // @@protoc_insertion_point(special_field:VoiceAssistantSetConfiguration.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a VoiceAssistantSetConfiguration {
    fn default() -> &'a VoiceAssistantSetConfiguration {
        <VoiceAssistantSetConfiguration as ::protobuf::Message>::default_instance()
    }
}

impl VoiceAssistantSetConfiguration {
    pub fn new() -> VoiceAssistantSetConfiguration {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(1);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "active_wake_words",
            |m: &VoiceAssistantSetConfiguration| { &m.active_wake_words },
            |m: &mut VoiceAssistantSetConfiguration| { &mut m.active_wake_words },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<VoiceAssistantSetConfiguration>(
            "VoiceAssistantSetConfiguration",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for VoiceAssistantSetConfiguration {
    const NAME: &'static str = "VoiceAssistantSetConfiguration";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.active_wake_words.push(is.read_string()?);
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        for value in &self.active_wake_words {
            my_size += ::protobuf::rt::string_size(1, &value);
        };
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        for v in &self.active_wake_words {
            os.write_string(1, &v)?;
        };
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> VoiceAssistantSetConfiguration {
        VoiceAssistantSetConfiguration::new()
    }

    fn clear(&mut self) {
        self.active_wake_words.clear();
        self.special_fields.clear();
    }

    fn default_instance() -> &'static VoiceAssistantSetConfiguration {
        static instance: VoiceAssistantSetConfiguration = VoiceAssistantSetConfiguration {
            active_wake_words: ::std::vec::Vec::new(),
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for VoiceAssistantSetConfiguration {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("VoiceAssistantSetConfiguration").unwrap()).clone()
    }
}

impl ::std::fmt::Display for VoiceAssistantSetConfiguration {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for VoiceAssistantSetConfiguration {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:ListEntitiesAlarmControlPanelResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ListEntitiesAlarmControlPanelResponse {
    // message fields
    // @@protoc_insertion_point(field:ListEntitiesAlarmControlPanelResponse.object_id)
    pub object_id: ::std::string::String,
    // @@protoc_insertion_point(field:ListEntitiesAlarmControlPanelResponse.key)
    pub key: u32,
    // @@protoc_insertion_point(field:ListEntitiesAlarmControlPanelResponse.name)
    pub name: ::std::string::String,
    // @@protoc_insertion_point(field:ListEntitiesAlarmControlPanelResponse.unique_id)
    pub unique_id: ::std::string::String,
    // @@protoc_insertion_point(field:ListEntitiesAlarmControlPanelResponse.icon)
    pub icon: ::std::string::String,
    // @@protoc_insertion_point(field:ListEntitiesAlarmControlPanelResponse.disabled_by_default)
    pub disabled_by_default: bool,
    // @@protoc_insertion_point(field:ListEntitiesAlarmControlPanelResponse.entity_category)
    pub entity_category: ::protobuf::EnumOrUnknown<EntityCategory>,
    // @@protoc_insertion_point(field:ListEntitiesAlarmControlPanelResponse.supported_features)
    pub supported_features: u32,
    // @@protoc_insertion_point(field:ListEntitiesAlarmControlPanelResponse.requires_code)
    pub requires_code: bool,
    // @@protoc_insertion_point(field:ListEntitiesAlarmControlPanelResponse.requires_code_to_arm)
    pub requires_code_to_arm: bool,
    // @@protoc_insertion_point(field:ListEntitiesAlarmControlPanelResponse.device_id)
    pub device_id: u32,
    // special fields
    // @@protoc_insertion_point(special_field:ListEntitiesAlarmControlPanelResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ListEntitiesAlarmControlPanelResponse {
    fn default() -> &'a ListEntitiesAlarmControlPanelResponse {
        <ListEntitiesAlarmControlPanelResponse as ::protobuf::Message>::default_instance()
    }
}

impl ListEntitiesAlarmControlPanelResponse {
    pub fn new() -> ListEntitiesAlarmControlPanelResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(11);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "object_id",
            |m: &ListEntitiesAlarmControlPanelResponse| { &m.object_id },
            |m: &mut ListEntitiesAlarmControlPanelResponse| { &mut m.object_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "key",
            |m: &ListEntitiesAlarmControlPanelResponse| { &m.key },
            |m: &mut ListEntitiesAlarmControlPanelResponse| { &mut m.key },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "name",
            |m: &ListEntitiesAlarmControlPanelResponse| { &m.name },
            |m: &mut ListEntitiesAlarmControlPanelResponse| { &mut m.name },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "unique_id",
            |m: &ListEntitiesAlarmControlPanelResponse| { &m.unique_id },
            |m: &mut ListEntitiesAlarmControlPanelResponse| { &mut m.unique_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "icon",
            |m: &ListEntitiesAlarmControlPanelResponse| { &m.icon },
            |m: &mut ListEntitiesAlarmControlPanelResponse| { &mut m.icon },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "disabled_by_default",
            |m: &ListEntitiesAlarmControlPanelResponse| { &m.disabled_by_default },
            |m: &mut ListEntitiesAlarmControlPanelResponse| { &mut m.disabled_by_default },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "entity_category",
            |m: &ListEntitiesAlarmControlPanelResponse| { &m.entity_category },
            |m: &mut ListEntitiesAlarmControlPanelResponse| { &mut m.entity_category },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "supported_features",
            |m: &ListEntitiesAlarmControlPanelResponse| { &m.supported_features },
            |m: &mut ListEntitiesAlarmControlPanelResponse| { &mut m.supported_features },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "requires_code",
            |m: &ListEntitiesAlarmControlPanelResponse| { &m.requires_code },
            |m: &mut ListEntitiesAlarmControlPanelResponse| { &mut m.requires_code },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "requires_code_to_arm",
            |m: &ListEntitiesAlarmControlPanelResponse| { &m.requires_code_to_arm },
            |m: &mut ListEntitiesAlarmControlPanelResponse| { &mut m.requires_code_to_arm },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "device_id",
            |m: &ListEntitiesAlarmControlPanelResponse| { &m.device_id },
            |m: &mut ListEntitiesAlarmControlPanelResponse| { &mut m.device_id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ListEntitiesAlarmControlPanelResponse>(
            "ListEntitiesAlarmControlPanelResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ListEntitiesAlarmControlPanelResponse {
    const NAME: &'static str = "ListEntitiesAlarmControlPanelResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.object_id = is.read_string()?;
                },
                21 => {
                    self.key = is.read_fixed32()?;
                },
                26 => {
                    self.name = is.read_string()?;
                },
                34 => {
                    self.unique_id = is.read_string()?;
                },
                42 => {
                    self.icon = is.read_string()?;
                },
                48 => {
                    self.disabled_by_default = is.read_bool()?;
                },
                56 => {
                    self.entity_category = is.read_enum_or_unknown()?;
                },
                64 => {
                    self.supported_features = is.read_uint32()?;
                },
                72 => {
                    self.requires_code = is.read_bool()?;
                },
                80 => {
                    self.requires_code_to_arm = is.read_bool()?;
                },
                88 => {
                    self.device_id = is.read_uint32()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.object_id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.object_id);
        }
        if self.key != 0 {
            my_size += 1 + 4;
        }
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.name);
        }
        if !self.unique_id.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.unique_id);
        }
        if !self.icon.is_empty() {
            my_size += ::protobuf::rt::string_size(5, &self.icon);
        }
        if self.disabled_by_default != false {
            my_size += 1 + 1;
        }
        if self.entity_category != ::protobuf::EnumOrUnknown::new(EntityCategory::ENTITY_CATEGORY_NONE) {
            my_size += ::protobuf::rt::int32_size(7, self.entity_category.value());
        }
        if self.supported_features != 0 {
            my_size += ::protobuf::rt::uint32_size(8, self.supported_features);
        }
        if self.requires_code != false {
            my_size += 1 + 1;
        }
        if self.requires_code_to_arm != false {
            my_size += 1 + 1;
        }
        if self.device_id != 0 {
            my_size += ::protobuf::rt::uint32_size(11, self.device_id);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.object_id.is_empty() {
            os.write_string(1, &self.object_id)?;
        }
        if self.key != 0 {
            os.write_fixed32(2, self.key)?;
        }
        if !self.name.is_empty() {
            os.write_string(3, &self.name)?;
        }
        if !self.unique_id.is_empty() {
            os.write_string(4, &self.unique_id)?;
        }
        if !self.icon.is_empty() {
            os.write_string(5, &self.icon)?;
        }
        if self.disabled_by_default != false {
            os.write_bool(6, self.disabled_by_default)?;
        }
        if self.entity_category != ::protobuf::EnumOrUnknown::new(EntityCategory::ENTITY_CATEGORY_NONE) {
            os.write_enum(7, ::protobuf::EnumOrUnknown::value(&self.entity_category))?;
        }
        if self.supported_features != 0 {
            os.write_uint32(8, self.supported_features)?;
        }
        if self.requires_code != false {
            os.write_bool(9, self.requires_code)?;
        }
        if self.requires_code_to_arm != false {
            os.write_bool(10, self.requires_code_to_arm)?;
        }
        if self.device_id != 0 {
            os.write_uint32(11, self.device_id)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ListEntitiesAlarmControlPanelResponse {
        ListEntitiesAlarmControlPanelResponse::new()
    }

    fn clear(&mut self) {
        self.object_id.clear();
        self.key = 0;
        self.name.clear();
        self.unique_id.clear();
        self.icon.clear();
        self.disabled_by_default = false;
        self.entity_category = ::protobuf::EnumOrUnknown::new(EntityCategory::ENTITY_CATEGORY_NONE);
        self.supported_features = 0;
        self.requires_code = false;
        self.requires_code_to_arm = false;
        self.device_id = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ListEntitiesAlarmControlPanelResponse {
        static instance: ListEntitiesAlarmControlPanelResponse = ListEntitiesAlarmControlPanelResponse {
            object_id: ::std::string::String::new(),
            key: 0,
            name: ::std::string::String::new(),
            unique_id: ::std::string::String::new(),
            icon: ::std::string::String::new(),
            disabled_by_default: false,
            entity_category: ::protobuf::EnumOrUnknown::from_i32(0),
            supported_features: 0,
            requires_code: false,
            requires_code_to_arm: false,
            device_id: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ListEntitiesAlarmControlPanelResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ListEntitiesAlarmControlPanelResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ListEntitiesAlarmControlPanelResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ListEntitiesAlarmControlPanelResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:AlarmControlPanelStateResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct AlarmControlPanelStateResponse {
    // message fields
    // @@protoc_insertion_point(field:AlarmControlPanelStateResponse.key)
    pub key: u32,
    // @@protoc_insertion_point(field:AlarmControlPanelStateResponse.state)
    pub state: ::protobuf::EnumOrUnknown<AlarmControlPanelState>,
    // @@protoc_insertion_point(field:AlarmControlPanelStateResponse.device_id)
    pub device_id: u32,
    // special fields
    // @@protoc_insertion_point(special_field:AlarmControlPanelStateResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a AlarmControlPanelStateResponse {
    fn default() -> &'a AlarmControlPanelStateResponse {
        <AlarmControlPanelStateResponse as ::protobuf::Message>::default_instance()
    }
}

impl AlarmControlPanelStateResponse {
    pub fn new() -> AlarmControlPanelStateResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "key",
            |m: &AlarmControlPanelStateResponse| { &m.key },
            |m: &mut AlarmControlPanelStateResponse| { &mut m.key },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "state",
            |m: &AlarmControlPanelStateResponse| { &m.state },
            |m: &mut AlarmControlPanelStateResponse| { &mut m.state },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "device_id",
            |m: &AlarmControlPanelStateResponse| { &m.device_id },
            |m: &mut AlarmControlPanelStateResponse| { &mut m.device_id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<AlarmControlPanelStateResponse>(
            "AlarmControlPanelStateResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for AlarmControlPanelStateResponse {
    const NAME: &'static str = "AlarmControlPanelStateResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                13 => {
                    self.key = is.read_fixed32()?;
                },
                16 => {
                    self.state = is.read_enum_or_unknown()?;
                },
                24 => {
                    self.device_id = is.read_uint32()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.key != 0 {
            my_size += 1 + 4;
        }
        if self.state != ::protobuf::EnumOrUnknown::new(AlarmControlPanelState::ALARM_STATE_DISARMED) {
            my_size += ::protobuf::rt::int32_size(2, self.state.value());
        }
        if self.device_id != 0 {
            my_size += ::protobuf::rt::uint32_size(3, self.device_id);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.key != 0 {
            os.write_fixed32(1, self.key)?;
        }
        if self.state != ::protobuf::EnumOrUnknown::new(AlarmControlPanelState::ALARM_STATE_DISARMED) {
            os.write_enum(2, ::protobuf::EnumOrUnknown::value(&self.state))?;
        }
        if self.device_id != 0 {
            os.write_uint32(3, self.device_id)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> AlarmControlPanelStateResponse {
        AlarmControlPanelStateResponse::new()
    }

    fn clear(&mut self) {
        self.key = 0;
        self.state = ::protobuf::EnumOrUnknown::new(AlarmControlPanelState::ALARM_STATE_DISARMED);
        self.device_id = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static AlarmControlPanelStateResponse {
        static instance: AlarmControlPanelStateResponse = AlarmControlPanelStateResponse {
            key: 0,
            state: ::protobuf::EnumOrUnknown::from_i32(0),
            device_id: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for AlarmControlPanelStateResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("AlarmControlPanelStateResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for AlarmControlPanelStateResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AlarmControlPanelStateResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:AlarmControlPanelCommandRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct AlarmControlPanelCommandRequest {
    // message fields
    // @@protoc_insertion_point(field:AlarmControlPanelCommandRequest.key)
    pub key: u32,
    // @@protoc_insertion_point(field:AlarmControlPanelCommandRequest.command)
    pub command: ::protobuf::EnumOrUnknown<AlarmControlPanelStateCommand>,
    // @@protoc_insertion_point(field:AlarmControlPanelCommandRequest.code)
    pub code: ::std::string::String,
    // @@protoc_insertion_point(field:AlarmControlPanelCommandRequest.device_id)
    pub device_id: u32,
    // special fields
    // @@protoc_insertion_point(special_field:AlarmControlPanelCommandRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a AlarmControlPanelCommandRequest {
    fn default() -> &'a AlarmControlPanelCommandRequest {
        <AlarmControlPanelCommandRequest as ::protobuf::Message>::default_instance()
    }
}

impl AlarmControlPanelCommandRequest {
    pub fn new() -> AlarmControlPanelCommandRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "key",
            |m: &AlarmControlPanelCommandRequest| { &m.key },
            |m: &mut AlarmControlPanelCommandRequest| { &mut m.key },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "command",
            |m: &AlarmControlPanelCommandRequest| { &m.command },
            |m: &mut AlarmControlPanelCommandRequest| { &mut m.command },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "code",
            |m: &AlarmControlPanelCommandRequest| { &m.code },
            |m: &mut AlarmControlPanelCommandRequest| { &mut m.code },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "device_id",
            |m: &AlarmControlPanelCommandRequest| { &m.device_id },
            |m: &mut AlarmControlPanelCommandRequest| { &mut m.device_id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<AlarmControlPanelCommandRequest>(
            "AlarmControlPanelCommandRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for AlarmControlPanelCommandRequest {
    const NAME: &'static str = "AlarmControlPanelCommandRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                13 => {
                    self.key = is.read_fixed32()?;
                },
                16 => {
                    self.command = is.read_enum_or_unknown()?;
                },
                26 => {
                    self.code = is.read_string()?;
                },
                32 => {
                    self.device_id = is.read_uint32()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.key != 0 {
            my_size += 1 + 4;
        }
        if self.command != ::protobuf::EnumOrUnknown::new(AlarmControlPanelStateCommand::ALARM_CONTROL_PANEL_DISARM) {
            my_size += ::protobuf::rt::int32_size(2, self.command.value());
        }
        if !self.code.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.code);
        }
        if self.device_id != 0 {
            my_size += ::protobuf::rt::uint32_size(4, self.device_id);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.key != 0 {
            os.write_fixed32(1, self.key)?;
        }
        if self.command != ::protobuf::EnumOrUnknown::new(AlarmControlPanelStateCommand::ALARM_CONTROL_PANEL_DISARM) {
            os.write_enum(2, ::protobuf::EnumOrUnknown::value(&self.command))?;
        }
        if !self.code.is_empty() {
            os.write_string(3, &self.code)?;
        }
        if self.device_id != 0 {
            os.write_uint32(4, self.device_id)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> AlarmControlPanelCommandRequest {
        AlarmControlPanelCommandRequest::new()
    }

    fn clear(&mut self) {
        self.key = 0;
        self.command = ::protobuf::EnumOrUnknown::new(AlarmControlPanelStateCommand::ALARM_CONTROL_PANEL_DISARM);
        self.code.clear();
        self.device_id = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static AlarmControlPanelCommandRequest {
        static instance: AlarmControlPanelCommandRequest = AlarmControlPanelCommandRequest {
            key: 0,
            command: ::protobuf::EnumOrUnknown::from_i32(0),
            code: ::std::string::String::new(),
            device_id: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for AlarmControlPanelCommandRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("AlarmControlPanelCommandRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for AlarmControlPanelCommandRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for AlarmControlPanelCommandRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:ListEntitiesTextResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ListEntitiesTextResponse {
    // message fields
    // @@protoc_insertion_point(field:ListEntitiesTextResponse.object_id)
    pub object_id: ::std::string::String,
    // @@protoc_insertion_point(field:ListEntitiesTextResponse.key)
    pub key: u32,
    // @@protoc_insertion_point(field:ListEntitiesTextResponse.name)
    pub name: ::std::string::String,
    // @@protoc_insertion_point(field:ListEntitiesTextResponse.unique_id)
    pub unique_id: ::std::string::String,
    // @@protoc_insertion_point(field:ListEntitiesTextResponse.icon)
    pub icon: ::std::string::String,
    // @@protoc_insertion_point(field:ListEntitiesTextResponse.disabled_by_default)
    pub disabled_by_default: bool,
    // @@protoc_insertion_point(field:ListEntitiesTextResponse.entity_category)
    pub entity_category: ::protobuf::EnumOrUnknown<EntityCategory>,
    // @@protoc_insertion_point(field:ListEntitiesTextResponse.min_length)
    pub min_length: u32,
    // @@protoc_insertion_point(field:ListEntitiesTextResponse.max_length)
    pub max_length: u32,
    // @@protoc_insertion_point(field:ListEntitiesTextResponse.pattern)
    pub pattern: ::std::string::String,
    // @@protoc_insertion_point(field:ListEntitiesTextResponse.mode)
    pub mode: ::protobuf::EnumOrUnknown<TextMode>,
    // @@protoc_insertion_point(field:ListEntitiesTextResponse.device_id)
    pub device_id: u32,
    // special fields
    // @@protoc_insertion_point(special_field:ListEntitiesTextResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ListEntitiesTextResponse {
    fn default() -> &'a ListEntitiesTextResponse {
        <ListEntitiesTextResponse as ::protobuf::Message>::default_instance()
    }
}

impl ListEntitiesTextResponse {
    pub fn new() -> ListEntitiesTextResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(12);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "object_id",
            |m: &ListEntitiesTextResponse| { &m.object_id },
            |m: &mut ListEntitiesTextResponse| { &mut m.object_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "key",
            |m: &ListEntitiesTextResponse| { &m.key },
            |m: &mut ListEntitiesTextResponse| { &mut m.key },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "name",
            |m: &ListEntitiesTextResponse| { &m.name },
            |m: &mut ListEntitiesTextResponse| { &mut m.name },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "unique_id",
            |m: &ListEntitiesTextResponse| { &m.unique_id },
            |m: &mut ListEntitiesTextResponse| { &mut m.unique_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "icon",
            |m: &ListEntitiesTextResponse| { &m.icon },
            |m: &mut ListEntitiesTextResponse| { &mut m.icon },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "disabled_by_default",
            |m: &ListEntitiesTextResponse| { &m.disabled_by_default },
            |m: &mut ListEntitiesTextResponse| { &mut m.disabled_by_default },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "entity_category",
            |m: &ListEntitiesTextResponse| { &m.entity_category },
            |m: &mut ListEntitiesTextResponse| { &mut m.entity_category },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "min_length",
            |m: &ListEntitiesTextResponse| { &m.min_length },
            |m: &mut ListEntitiesTextResponse| { &mut m.min_length },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "max_length",
            |m: &ListEntitiesTextResponse| { &m.max_length },
            |m: &mut ListEntitiesTextResponse| { &mut m.max_length },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "pattern",
            |m: &ListEntitiesTextResponse| { &m.pattern },
            |m: &mut ListEntitiesTextResponse| { &mut m.pattern },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "mode",
            |m: &ListEntitiesTextResponse| { &m.mode },
            |m: &mut ListEntitiesTextResponse| { &mut m.mode },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "device_id",
            |m: &ListEntitiesTextResponse| { &m.device_id },
            |m: &mut ListEntitiesTextResponse| { &mut m.device_id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ListEntitiesTextResponse>(
            "ListEntitiesTextResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ListEntitiesTextResponse {
    const NAME: &'static str = "ListEntitiesTextResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.object_id = is.read_string()?;
                },
                21 => {
                    self.key = is.read_fixed32()?;
                },
                26 => {
                    self.name = is.read_string()?;
                },
                34 => {
                    self.unique_id = is.read_string()?;
                },
                42 => {
                    self.icon = is.read_string()?;
                },
                48 => {
                    self.disabled_by_default = is.read_bool()?;
                },
                56 => {
                    self.entity_category = is.read_enum_or_unknown()?;
                },
                64 => {
                    self.min_length = is.read_uint32()?;
                },
                72 => {
                    self.max_length = is.read_uint32()?;
                },
                82 => {
                    self.pattern = is.read_string()?;
                },
                88 => {
                    self.mode = is.read_enum_or_unknown()?;
                },
                96 => {
                    self.device_id = is.read_uint32()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.object_id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.object_id);
        }
        if self.key != 0 {
            my_size += 1 + 4;
        }
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.name);
        }
        if !self.unique_id.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.unique_id);
        }
        if !self.icon.is_empty() {
            my_size += ::protobuf::rt::string_size(5, &self.icon);
        }
        if self.disabled_by_default != false {
            my_size += 1 + 1;
        }
        if self.entity_category != ::protobuf::EnumOrUnknown::new(EntityCategory::ENTITY_CATEGORY_NONE) {
            my_size += ::protobuf::rt::int32_size(7, self.entity_category.value());
        }
        if self.min_length != 0 {
            my_size += ::protobuf::rt::uint32_size(8, self.min_length);
        }
        if self.max_length != 0 {
            my_size += ::protobuf::rt::uint32_size(9, self.max_length);
        }
        if !self.pattern.is_empty() {
            my_size += ::protobuf::rt::string_size(10, &self.pattern);
        }
        if self.mode != ::protobuf::EnumOrUnknown::new(TextMode::TEXT_MODE_TEXT) {
            my_size += ::protobuf::rt::int32_size(11, self.mode.value());
        }
        if self.device_id != 0 {
            my_size += ::protobuf::rt::uint32_size(12, self.device_id);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.object_id.is_empty() {
            os.write_string(1, &self.object_id)?;
        }
        if self.key != 0 {
            os.write_fixed32(2, self.key)?;
        }
        if !self.name.is_empty() {
            os.write_string(3, &self.name)?;
        }
        if !self.unique_id.is_empty() {
            os.write_string(4, &self.unique_id)?;
        }
        if !self.icon.is_empty() {
            os.write_string(5, &self.icon)?;
        }
        if self.disabled_by_default != false {
            os.write_bool(6, self.disabled_by_default)?;
        }
        if self.entity_category != ::protobuf::EnumOrUnknown::new(EntityCategory::ENTITY_CATEGORY_NONE) {
            os.write_enum(7, ::protobuf::EnumOrUnknown::value(&self.entity_category))?;
        }
        if self.min_length != 0 {
            os.write_uint32(8, self.min_length)?;
        }
        if self.max_length != 0 {
            os.write_uint32(9, self.max_length)?;
        }
        if !self.pattern.is_empty() {
            os.write_string(10, &self.pattern)?;
        }
        if self.mode != ::protobuf::EnumOrUnknown::new(TextMode::TEXT_MODE_TEXT) {
            os.write_enum(11, ::protobuf::EnumOrUnknown::value(&self.mode))?;
        }
        if self.device_id != 0 {
            os.write_uint32(12, self.device_id)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ListEntitiesTextResponse {
        ListEntitiesTextResponse::new()
    }

    fn clear(&mut self) {
        self.object_id.clear();
        self.key = 0;
        self.name.clear();
        self.unique_id.clear();
        self.icon.clear();
        self.disabled_by_default = false;
        self.entity_category = ::protobuf::EnumOrUnknown::new(EntityCategory::ENTITY_CATEGORY_NONE);
        self.min_length = 0;
        self.max_length = 0;
        self.pattern.clear();
        self.mode = ::protobuf::EnumOrUnknown::new(TextMode::TEXT_MODE_TEXT);
        self.device_id = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ListEntitiesTextResponse {
        static instance: ListEntitiesTextResponse = ListEntitiesTextResponse {
            object_id: ::std::string::String::new(),
            key: 0,
            name: ::std::string::String::new(),
            unique_id: ::std::string::String::new(),
            icon: ::std::string::String::new(),
            disabled_by_default: false,
            entity_category: ::protobuf::EnumOrUnknown::from_i32(0),
            min_length: 0,
            max_length: 0,
            pattern: ::std::string::String::new(),
            mode: ::protobuf::EnumOrUnknown::from_i32(0),
            device_id: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ListEntitiesTextResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ListEntitiesTextResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ListEntitiesTextResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ListEntitiesTextResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:TextStateResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct TextStateResponse {
    // message fields
    // @@protoc_insertion_point(field:TextStateResponse.key)
    pub key: u32,
    // @@protoc_insertion_point(field:TextStateResponse.state)
    pub state: ::std::string::String,
    // @@protoc_insertion_point(field:TextStateResponse.missing_state)
    pub missing_state: bool,
    // @@protoc_insertion_point(field:TextStateResponse.device_id)
    pub device_id: u32,
    // special fields
    // @@protoc_insertion_point(special_field:TextStateResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a TextStateResponse {
    fn default() -> &'a TextStateResponse {
        <TextStateResponse as ::protobuf::Message>::default_instance()
    }
}

impl TextStateResponse {
    pub fn new() -> TextStateResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "key",
            |m: &TextStateResponse| { &m.key },
            |m: &mut TextStateResponse| { &mut m.key },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "state",
            |m: &TextStateResponse| { &m.state },
            |m: &mut TextStateResponse| { &mut m.state },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "missing_state",
            |m: &TextStateResponse| { &m.missing_state },
            |m: &mut TextStateResponse| { &mut m.missing_state },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "device_id",
            |m: &TextStateResponse| { &m.device_id },
            |m: &mut TextStateResponse| { &mut m.device_id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<TextStateResponse>(
            "TextStateResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for TextStateResponse {
    const NAME: &'static str = "TextStateResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                13 => {
                    self.key = is.read_fixed32()?;
                },
                18 => {
                    self.state = is.read_string()?;
                },
                24 => {
                    self.missing_state = is.read_bool()?;
                },
                32 => {
                    self.device_id = is.read_uint32()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.key != 0 {
            my_size += 1 + 4;
        }
        if !self.state.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.state);
        }
        if self.missing_state != false {
            my_size += 1 + 1;
        }
        if self.device_id != 0 {
            my_size += ::protobuf::rt::uint32_size(4, self.device_id);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.key != 0 {
            os.write_fixed32(1, self.key)?;
        }
        if !self.state.is_empty() {
            os.write_string(2, &self.state)?;
        }
        if self.missing_state != false {
            os.write_bool(3, self.missing_state)?;
        }
        if self.device_id != 0 {
            os.write_uint32(4, self.device_id)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> TextStateResponse {
        TextStateResponse::new()
    }

    fn clear(&mut self) {
        self.key = 0;
        self.state.clear();
        self.missing_state = false;
        self.device_id = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static TextStateResponse {
        static instance: TextStateResponse = TextStateResponse {
            key: 0,
            state: ::std::string::String::new(),
            missing_state: false,
            device_id: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for TextStateResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("TextStateResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for TextStateResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TextStateResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:TextCommandRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct TextCommandRequest {
    // message fields
    // @@protoc_insertion_point(field:TextCommandRequest.key)
    pub key: u32,
    // @@protoc_insertion_point(field:TextCommandRequest.state)
    pub state: ::std::string::String,
    // @@protoc_insertion_point(field:TextCommandRequest.device_id)
    pub device_id: u32,
    // special fields
    // @@protoc_insertion_point(special_field:TextCommandRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a TextCommandRequest {
    fn default() -> &'a TextCommandRequest {
        <TextCommandRequest as ::protobuf::Message>::default_instance()
    }
}

impl TextCommandRequest {
    pub fn new() -> TextCommandRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "key",
            |m: &TextCommandRequest| { &m.key },
            |m: &mut TextCommandRequest| { &mut m.key },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "state",
            |m: &TextCommandRequest| { &m.state },
            |m: &mut TextCommandRequest| { &mut m.state },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "device_id",
            |m: &TextCommandRequest| { &m.device_id },
            |m: &mut TextCommandRequest| { &mut m.device_id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<TextCommandRequest>(
            "TextCommandRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for TextCommandRequest {
    const NAME: &'static str = "TextCommandRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                13 => {
                    self.key = is.read_fixed32()?;
                },
                18 => {
                    self.state = is.read_string()?;
                },
                24 => {
                    self.device_id = is.read_uint32()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.key != 0 {
            my_size += 1 + 4;
        }
        if !self.state.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.state);
        }
        if self.device_id != 0 {
            my_size += ::protobuf::rt::uint32_size(3, self.device_id);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.key != 0 {
            os.write_fixed32(1, self.key)?;
        }
        if !self.state.is_empty() {
            os.write_string(2, &self.state)?;
        }
        if self.device_id != 0 {
            os.write_uint32(3, self.device_id)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> TextCommandRequest {
        TextCommandRequest::new()
    }

    fn clear(&mut self) {
        self.key = 0;
        self.state.clear();
        self.device_id = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static TextCommandRequest {
        static instance: TextCommandRequest = TextCommandRequest {
            key: 0,
            state: ::std::string::String::new(),
            device_id: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for TextCommandRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("TextCommandRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for TextCommandRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TextCommandRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:ListEntitiesDateResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ListEntitiesDateResponse {
    // message fields
    // @@protoc_insertion_point(field:ListEntitiesDateResponse.object_id)
    pub object_id: ::std::string::String,
    // @@protoc_insertion_point(field:ListEntitiesDateResponse.key)
    pub key: u32,
    // @@protoc_insertion_point(field:ListEntitiesDateResponse.name)
    pub name: ::std::string::String,
    // @@protoc_insertion_point(field:ListEntitiesDateResponse.unique_id)
    pub unique_id: ::std::string::String,
    // @@protoc_insertion_point(field:ListEntitiesDateResponse.icon)
    pub icon: ::std::string::String,
    // @@protoc_insertion_point(field:ListEntitiesDateResponse.disabled_by_default)
    pub disabled_by_default: bool,
    // @@protoc_insertion_point(field:ListEntitiesDateResponse.entity_category)
    pub entity_category: ::protobuf::EnumOrUnknown<EntityCategory>,
    // @@protoc_insertion_point(field:ListEntitiesDateResponse.device_id)
    pub device_id: u32,
    // special fields
    // @@protoc_insertion_point(special_field:ListEntitiesDateResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ListEntitiesDateResponse {
    fn default() -> &'a ListEntitiesDateResponse {
        <ListEntitiesDateResponse as ::protobuf::Message>::default_instance()
    }
}

impl ListEntitiesDateResponse {
    pub fn new() -> ListEntitiesDateResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(8);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "object_id",
            |m: &ListEntitiesDateResponse| { &m.object_id },
            |m: &mut ListEntitiesDateResponse| { &mut m.object_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "key",
            |m: &ListEntitiesDateResponse| { &m.key },
            |m: &mut ListEntitiesDateResponse| { &mut m.key },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "name",
            |m: &ListEntitiesDateResponse| { &m.name },
            |m: &mut ListEntitiesDateResponse| { &mut m.name },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "unique_id",
            |m: &ListEntitiesDateResponse| { &m.unique_id },
            |m: &mut ListEntitiesDateResponse| { &mut m.unique_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "icon",
            |m: &ListEntitiesDateResponse| { &m.icon },
            |m: &mut ListEntitiesDateResponse| { &mut m.icon },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "disabled_by_default",
            |m: &ListEntitiesDateResponse| { &m.disabled_by_default },
            |m: &mut ListEntitiesDateResponse| { &mut m.disabled_by_default },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "entity_category",
            |m: &ListEntitiesDateResponse| { &m.entity_category },
            |m: &mut ListEntitiesDateResponse| { &mut m.entity_category },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "device_id",
            |m: &ListEntitiesDateResponse| { &m.device_id },
            |m: &mut ListEntitiesDateResponse| { &mut m.device_id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ListEntitiesDateResponse>(
            "ListEntitiesDateResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ListEntitiesDateResponse {
    const NAME: &'static str = "ListEntitiesDateResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.object_id = is.read_string()?;
                },
                21 => {
                    self.key = is.read_fixed32()?;
                },
                26 => {
                    self.name = is.read_string()?;
                },
                34 => {
                    self.unique_id = is.read_string()?;
                },
                42 => {
                    self.icon = is.read_string()?;
                },
                48 => {
                    self.disabled_by_default = is.read_bool()?;
                },
                56 => {
                    self.entity_category = is.read_enum_or_unknown()?;
                },
                64 => {
                    self.device_id = is.read_uint32()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.object_id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.object_id);
        }
        if self.key != 0 {
            my_size += 1 + 4;
        }
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.name);
        }
        if !self.unique_id.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.unique_id);
        }
        if !self.icon.is_empty() {
            my_size += ::protobuf::rt::string_size(5, &self.icon);
        }
        if self.disabled_by_default != false {
            my_size += 1 + 1;
        }
        if self.entity_category != ::protobuf::EnumOrUnknown::new(EntityCategory::ENTITY_CATEGORY_NONE) {
            my_size += ::protobuf::rt::int32_size(7, self.entity_category.value());
        }
        if self.device_id != 0 {
            my_size += ::protobuf::rt::uint32_size(8, self.device_id);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.object_id.is_empty() {
            os.write_string(1, &self.object_id)?;
        }
        if self.key != 0 {
            os.write_fixed32(2, self.key)?;
        }
        if !self.name.is_empty() {
            os.write_string(3, &self.name)?;
        }
        if !self.unique_id.is_empty() {
            os.write_string(4, &self.unique_id)?;
        }
        if !self.icon.is_empty() {
            os.write_string(5, &self.icon)?;
        }
        if self.disabled_by_default != false {
            os.write_bool(6, self.disabled_by_default)?;
        }
        if self.entity_category != ::protobuf::EnumOrUnknown::new(EntityCategory::ENTITY_CATEGORY_NONE) {
            os.write_enum(7, ::protobuf::EnumOrUnknown::value(&self.entity_category))?;
        }
        if self.device_id != 0 {
            os.write_uint32(8, self.device_id)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ListEntitiesDateResponse {
        ListEntitiesDateResponse::new()
    }

    fn clear(&mut self) {
        self.object_id.clear();
        self.key = 0;
        self.name.clear();
        self.unique_id.clear();
        self.icon.clear();
        self.disabled_by_default = false;
        self.entity_category = ::protobuf::EnumOrUnknown::new(EntityCategory::ENTITY_CATEGORY_NONE);
        self.device_id = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ListEntitiesDateResponse {
        static instance: ListEntitiesDateResponse = ListEntitiesDateResponse {
            object_id: ::std::string::String::new(),
            key: 0,
            name: ::std::string::String::new(),
            unique_id: ::std::string::String::new(),
            icon: ::std::string::String::new(),
            disabled_by_default: false,
            entity_category: ::protobuf::EnumOrUnknown::from_i32(0),
            device_id: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ListEntitiesDateResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ListEntitiesDateResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ListEntitiesDateResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ListEntitiesDateResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:DateStateResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct DateStateResponse {
    // message fields
    // @@protoc_insertion_point(field:DateStateResponse.key)
    pub key: u32,
    // @@protoc_insertion_point(field:DateStateResponse.missing_state)
    pub missing_state: bool,
    // @@protoc_insertion_point(field:DateStateResponse.year)
    pub year: u32,
    // @@protoc_insertion_point(field:DateStateResponse.month)
    pub month: u32,
    // @@protoc_insertion_point(field:DateStateResponse.day)
    pub day: u32,
    // @@protoc_insertion_point(field:DateStateResponse.device_id)
    pub device_id: u32,
    // special fields
    // @@protoc_insertion_point(special_field:DateStateResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a DateStateResponse {
    fn default() -> &'a DateStateResponse {
        <DateStateResponse as ::protobuf::Message>::default_instance()
    }
}

impl DateStateResponse {
    pub fn new() -> DateStateResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(6);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "key",
            |m: &DateStateResponse| { &m.key },
            |m: &mut DateStateResponse| { &mut m.key },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "missing_state",
            |m: &DateStateResponse| { &m.missing_state },
            |m: &mut DateStateResponse| { &mut m.missing_state },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "year",
            |m: &DateStateResponse| { &m.year },
            |m: &mut DateStateResponse| { &mut m.year },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "month",
            |m: &DateStateResponse| { &m.month },
            |m: &mut DateStateResponse| { &mut m.month },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "day",
            |m: &DateStateResponse| { &m.day },
            |m: &mut DateStateResponse| { &mut m.day },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "device_id",
            |m: &DateStateResponse| { &m.device_id },
            |m: &mut DateStateResponse| { &mut m.device_id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<DateStateResponse>(
            "DateStateResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for DateStateResponse {
    const NAME: &'static str = "DateStateResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                13 => {
                    self.key = is.read_fixed32()?;
                },
                16 => {
                    self.missing_state = is.read_bool()?;
                },
                24 => {
                    self.year = is.read_uint32()?;
                },
                32 => {
                    self.month = is.read_uint32()?;
                },
                40 => {
                    self.day = is.read_uint32()?;
                },
                48 => {
                    self.device_id = is.read_uint32()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.key != 0 {
            my_size += 1 + 4;
        }
        if self.missing_state != false {
            my_size += 1 + 1;
        }
        if self.year != 0 {
            my_size += ::protobuf::rt::uint32_size(3, self.year);
        }
        if self.month != 0 {
            my_size += ::protobuf::rt::uint32_size(4, self.month);
        }
        if self.day != 0 {
            my_size += ::protobuf::rt::uint32_size(5, self.day);
        }
        if self.device_id != 0 {
            my_size += ::protobuf::rt::uint32_size(6, self.device_id);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.key != 0 {
            os.write_fixed32(1, self.key)?;
        }
        if self.missing_state != false {
            os.write_bool(2, self.missing_state)?;
        }
        if self.year != 0 {
            os.write_uint32(3, self.year)?;
        }
        if self.month != 0 {
            os.write_uint32(4, self.month)?;
        }
        if self.day != 0 {
            os.write_uint32(5, self.day)?;
        }
        if self.device_id != 0 {
            os.write_uint32(6, self.device_id)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> DateStateResponse {
        DateStateResponse::new()
    }

    fn clear(&mut self) {
        self.key = 0;
        self.missing_state = false;
        self.year = 0;
        self.month = 0;
        self.day = 0;
        self.device_id = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static DateStateResponse {
        static instance: DateStateResponse = DateStateResponse {
            key: 0,
            missing_state: false,
            year: 0,
            month: 0,
            day: 0,
            device_id: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for DateStateResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("DateStateResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for DateStateResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DateStateResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:DateCommandRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct DateCommandRequest {
    // message fields
    // @@protoc_insertion_point(field:DateCommandRequest.key)
    pub key: u32,
    // @@protoc_insertion_point(field:DateCommandRequest.year)
    pub year: u32,
    // @@protoc_insertion_point(field:DateCommandRequest.month)
    pub month: u32,
    // @@protoc_insertion_point(field:DateCommandRequest.day)
    pub day: u32,
    // @@protoc_insertion_point(field:DateCommandRequest.device_id)
    pub device_id: u32,
    // special fields
    // @@protoc_insertion_point(special_field:DateCommandRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a DateCommandRequest {
    fn default() -> &'a DateCommandRequest {
        <DateCommandRequest as ::protobuf::Message>::default_instance()
    }
}

impl DateCommandRequest {
    pub fn new() -> DateCommandRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(5);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "key",
            |m: &DateCommandRequest| { &m.key },
            |m: &mut DateCommandRequest| { &mut m.key },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "year",
            |m: &DateCommandRequest| { &m.year },
            |m: &mut DateCommandRequest| { &mut m.year },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "month",
            |m: &DateCommandRequest| { &m.month },
            |m: &mut DateCommandRequest| { &mut m.month },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "day",
            |m: &DateCommandRequest| { &m.day },
            |m: &mut DateCommandRequest| { &mut m.day },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "device_id",
            |m: &DateCommandRequest| { &m.device_id },
            |m: &mut DateCommandRequest| { &mut m.device_id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<DateCommandRequest>(
            "DateCommandRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for DateCommandRequest {
    const NAME: &'static str = "DateCommandRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                13 => {
                    self.key = is.read_fixed32()?;
                },
                16 => {
                    self.year = is.read_uint32()?;
                },
                24 => {
                    self.month = is.read_uint32()?;
                },
                32 => {
                    self.day = is.read_uint32()?;
                },
                40 => {
                    self.device_id = is.read_uint32()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.key != 0 {
            my_size += 1 + 4;
        }
        if self.year != 0 {
            my_size += ::protobuf::rt::uint32_size(2, self.year);
        }
        if self.month != 0 {
            my_size += ::protobuf::rt::uint32_size(3, self.month);
        }
        if self.day != 0 {
            my_size += ::protobuf::rt::uint32_size(4, self.day);
        }
        if self.device_id != 0 {
            my_size += ::protobuf::rt::uint32_size(5, self.device_id);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.key != 0 {
            os.write_fixed32(1, self.key)?;
        }
        if self.year != 0 {
            os.write_uint32(2, self.year)?;
        }
        if self.month != 0 {
            os.write_uint32(3, self.month)?;
        }
        if self.day != 0 {
            os.write_uint32(4, self.day)?;
        }
        if self.device_id != 0 {
            os.write_uint32(5, self.device_id)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> DateCommandRequest {
        DateCommandRequest::new()
    }

    fn clear(&mut self) {
        self.key = 0;
        self.year = 0;
        self.month = 0;
        self.day = 0;
        self.device_id = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static DateCommandRequest {
        static instance: DateCommandRequest = DateCommandRequest {
            key: 0,
            year: 0,
            month: 0,
            day: 0,
            device_id: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for DateCommandRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("DateCommandRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for DateCommandRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DateCommandRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:ListEntitiesTimeResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ListEntitiesTimeResponse {
    // message fields
    // @@protoc_insertion_point(field:ListEntitiesTimeResponse.object_id)
    pub object_id: ::std::string::String,
    // @@protoc_insertion_point(field:ListEntitiesTimeResponse.key)
    pub key: u32,
    // @@protoc_insertion_point(field:ListEntitiesTimeResponse.name)
    pub name: ::std::string::String,
    // @@protoc_insertion_point(field:ListEntitiesTimeResponse.unique_id)
    pub unique_id: ::std::string::String,
    // @@protoc_insertion_point(field:ListEntitiesTimeResponse.icon)
    pub icon: ::std::string::String,
    // @@protoc_insertion_point(field:ListEntitiesTimeResponse.disabled_by_default)
    pub disabled_by_default: bool,
    // @@protoc_insertion_point(field:ListEntitiesTimeResponse.entity_category)
    pub entity_category: ::protobuf::EnumOrUnknown<EntityCategory>,
    // @@protoc_insertion_point(field:ListEntitiesTimeResponse.device_id)
    pub device_id: u32,
    // special fields
    // @@protoc_insertion_point(special_field:ListEntitiesTimeResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ListEntitiesTimeResponse {
    fn default() -> &'a ListEntitiesTimeResponse {
        <ListEntitiesTimeResponse as ::protobuf::Message>::default_instance()
    }
}

impl ListEntitiesTimeResponse {
    pub fn new() -> ListEntitiesTimeResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(8);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "object_id",
            |m: &ListEntitiesTimeResponse| { &m.object_id },
            |m: &mut ListEntitiesTimeResponse| { &mut m.object_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "key",
            |m: &ListEntitiesTimeResponse| { &m.key },
            |m: &mut ListEntitiesTimeResponse| { &mut m.key },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "name",
            |m: &ListEntitiesTimeResponse| { &m.name },
            |m: &mut ListEntitiesTimeResponse| { &mut m.name },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "unique_id",
            |m: &ListEntitiesTimeResponse| { &m.unique_id },
            |m: &mut ListEntitiesTimeResponse| { &mut m.unique_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "icon",
            |m: &ListEntitiesTimeResponse| { &m.icon },
            |m: &mut ListEntitiesTimeResponse| { &mut m.icon },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "disabled_by_default",
            |m: &ListEntitiesTimeResponse| { &m.disabled_by_default },
            |m: &mut ListEntitiesTimeResponse| { &mut m.disabled_by_default },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "entity_category",
            |m: &ListEntitiesTimeResponse| { &m.entity_category },
            |m: &mut ListEntitiesTimeResponse| { &mut m.entity_category },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "device_id",
            |m: &ListEntitiesTimeResponse| { &m.device_id },
            |m: &mut ListEntitiesTimeResponse| { &mut m.device_id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ListEntitiesTimeResponse>(
            "ListEntitiesTimeResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ListEntitiesTimeResponse {
    const NAME: &'static str = "ListEntitiesTimeResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.object_id = is.read_string()?;
                },
                21 => {
                    self.key = is.read_fixed32()?;
                },
                26 => {
                    self.name = is.read_string()?;
                },
                34 => {
                    self.unique_id = is.read_string()?;
                },
                42 => {
                    self.icon = is.read_string()?;
                },
                48 => {
                    self.disabled_by_default = is.read_bool()?;
                },
                56 => {
                    self.entity_category = is.read_enum_or_unknown()?;
                },
                64 => {
                    self.device_id = is.read_uint32()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.object_id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.object_id);
        }
        if self.key != 0 {
            my_size += 1 + 4;
        }
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.name);
        }
        if !self.unique_id.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.unique_id);
        }
        if !self.icon.is_empty() {
            my_size += ::protobuf::rt::string_size(5, &self.icon);
        }
        if self.disabled_by_default != false {
            my_size += 1 + 1;
        }
        if self.entity_category != ::protobuf::EnumOrUnknown::new(EntityCategory::ENTITY_CATEGORY_NONE) {
            my_size += ::protobuf::rt::int32_size(7, self.entity_category.value());
        }
        if self.device_id != 0 {
            my_size += ::protobuf::rt::uint32_size(8, self.device_id);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.object_id.is_empty() {
            os.write_string(1, &self.object_id)?;
        }
        if self.key != 0 {
            os.write_fixed32(2, self.key)?;
        }
        if !self.name.is_empty() {
            os.write_string(3, &self.name)?;
        }
        if !self.unique_id.is_empty() {
            os.write_string(4, &self.unique_id)?;
        }
        if !self.icon.is_empty() {
            os.write_string(5, &self.icon)?;
        }
        if self.disabled_by_default != false {
            os.write_bool(6, self.disabled_by_default)?;
        }
        if self.entity_category != ::protobuf::EnumOrUnknown::new(EntityCategory::ENTITY_CATEGORY_NONE) {
            os.write_enum(7, ::protobuf::EnumOrUnknown::value(&self.entity_category))?;
        }
        if self.device_id != 0 {
            os.write_uint32(8, self.device_id)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ListEntitiesTimeResponse {
        ListEntitiesTimeResponse::new()
    }

    fn clear(&mut self) {
        self.object_id.clear();
        self.key = 0;
        self.name.clear();
        self.unique_id.clear();
        self.icon.clear();
        self.disabled_by_default = false;
        self.entity_category = ::protobuf::EnumOrUnknown::new(EntityCategory::ENTITY_CATEGORY_NONE);
        self.device_id = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ListEntitiesTimeResponse {
        static instance: ListEntitiesTimeResponse = ListEntitiesTimeResponse {
            object_id: ::std::string::String::new(),
            key: 0,
            name: ::std::string::String::new(),
            unique_id: ::std::string::String::new(),
            icon: ::std::string::String::new(),
            disabled_by_default: false,
            entity_category: ::protobuf::EnumOrUnknown::from_i32(0),
            device_id: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ListEntitiesTimeResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ListEntitiesTimeResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ListEntitiesTimeResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ListEntitiesTimeResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:TimeStateResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct TimeStateResponse {
    // message fields
    // @@protoc_insertion_point(field:TimeStateResponse.key)
    pub key: u32,
    // @@protoc_insertion_point(field:TimeStateResponse.missing_state)
    pub missing_state: bool,
    // @@protoc_insertion_point(field:TimeStateResponse.hour)
    pub hour: u32,
    // @@protoc_insertion_point(field:TimeStateResponse.minute)
    pub minute: u32,
    // @@protoc_insertion_point(field:TimeStateResponse.second)
    pub second: u32,
    // @@protoc_insertion_point(field:TimeStateResponse.device_id)
    pub device_id: u32,
    // special fields
    // @@protoc_insertion_point(special_field:TimeStateResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a TimeStateResponse {
    fn default() -> &'a TimeStateResponse {
        <TimeStateResponse as ::protobuf::Message>::default_instance()
    }
}

impl TimeStateResponse {
    pub fn new() -> TimeStateResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(6);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "key",
            |m: &TimeStateResponse| { &m.key },
            |m: &mut TimeStateResponse| { &mut m.key },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "missing_state",
            |m: &TimeStateResponse| { &m.missing_state },
            |m: &mut TimeStateResponse| { &mut m.missing_state },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "hour",
            |m: &TimeStateResponse| { &m.hour },
            |m: &mut TimeStateResponse| { &mut m.hour },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "minute",
            |m: &TimeStateResponse| { &m.minute },
            |m: &mut TimeStateResponse| { &mut m.minute },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "second",
            |m: &TimeStateResponse| { &m.second },
            |m: &mut TimeStateResponse| { &mut m.second },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "device_id",
            |m: &TimeStateResponse| { &m.device_id },
            |m: &mut TimeStateResponse| { &mut m.device_id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<TimeStateResponse>(
            "TimeStateResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for TimeStateResponse {
    const NAME: &'static str = "TimeStateResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                13 => {
                    self.key = is.read_fixed32()?;
                },
                16 => {
                    self.missing_state = is.read_bool()?;
                },
                24 => {
                    self.hour = is.read_uint32()?;
                },
                32 => {
                    self.minute = is.read_uint32()?;
                },
                40 => {
                    self.second = is.read_uint32()?;
                },
                48 => {
                    self.device_id = is.read_uint32()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.key != 0 {
            my_size += 1 + 4;
        }
        if self.missing_state != false {
            my_size += 1 + 1;
        }
        if self.hour != 0 {
            my_size += ::protobuf::rt::uint32_size(3, self.hour);
        }
        if self.minute != 0 {
            my_size += ::protobuf::rt::uint32_size(4, self.minute);
        }
        if self.second != 0 {
            my_size += ::protobuf::rt::uint32_size(5, self.second);
        }
        if self.device_id != 0 {
            my_size += ::protobuf::rt::uint32_size(6, self.device_id);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.key != 0 {
            os.write_fixed32(1, self.key)?;
        }
        if self.missing_state != false {
            os.write_bool(2, self.missing_state)?;
        }
        if self.hour != 0 {
            os.write_uint32(3, self.hour)?;
        }
        if self.minute != 0 {
            os.write_uint32(4, self.minute)?;
        }
        if self.second != 0 {
            os.write_uint32(5, self.second)?;
        }
        if self.device_id != 0 {
            os.write_uint32(6, self.device_id)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> TimeStateResponse {
        TimeStateResponse::new()
    }

    fn clear(&mut self) {
        self.key = 0;
        self.missing_state = false;
        self.hour = 0;
        self.minute = 0;
        self.second = 0;
        self.device_id = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static TimeStateResponse {
        static instance: TimeStateResponse = TimeStateResponse {
            key: 0,
            missing_state: false,
            hour: 0,
            minute: 0,
            second: 0,
            device_id: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for TimeStateResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("TimeStateResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for TimeStateResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TimeStateResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:TimeCommandRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct TimeCommandRequest {
    // message fields
    // @@protoc_insertion_point(field:TimeCommandRequest.key)
    pub key: u32,
    // @@protoc_insertion_point(field:TimeCommandRequest.hour)
    pub hour: u32,
    // @@protoc_insertion_point(field:TimeCommandRequest.minute)
    pub minute: u32,
    // @@protoc_insertion_point(field:TimeCommandRequest.second)
    pub second: u32,
    // @@protoc_insertion_point(field:TimeCommandRequest.device_id)
    pub device_id: u32,
    // special fields
    // @@protoc_insertion_point(special_field:TimeCommandRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a TimeCommandRequest {
    fn default() -> &'a TimeCommandRequest {
        <TimeCommandRequest as ::protobuf::Message>::default_instance()
    }
}

impl TimeCommandRequest {
    pub fn new() -> TimeCommandRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(5);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "key",
            |m: &TimeCommandRequest| { &m.key },
            |m: &mut TimeCommandRequest| { &mut m.key },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "hour",
            |m: &TimeCommandRequest| { &m.hour },
            |m: &mut TimeCommandRequest| { &mut m.hour },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "minute",
            |m: &TimeCommandRequest| { &m.minute },
            |m: &mut TimeCommandRequest| { &mut m.minute },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "second",
            |m: &TimeCommandRequest| { &m.second },
            |m: &mut TimeCommandRequest| { &mut m.second },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "device_id",
            |m: &TimeCommandRequest| { &m.device_id },
            |m: &mut TimeCommandRequest| { &mut m.device_id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<TimeCommandRequest>(
            "TimeCommandRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for TimeCommandRequest {
    const NAME: &'static str = "TimeCommandRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                13 => {
                    self.key = is.read_fixed32()?;
                },
                16 => {
                    self.hour = is.read_uint32()?;
                },
                24 => {
                    self.minute = is.read_uint32()?;
                },
                32 => {
                    self.second = is.read_uint32()?;
                },
                40 => {
                    self.device_id = is.read_uint32()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.key != 0 {
            my_size += 1 + 4;
        }
        if self.hour != 0 {
            my_size += ::protobuf::rt::uint32_size(2, self.hour);
        }
        if self.minute != 0 {
            my_size += ::protobuf::rt::uint32_size(3, self.minute);
        }
        if self.second != 0 {
            my_size += ::protobuf::rt::uint32_size(4, self.second);
        }
        if self.device_id != 0 {
            my_size += ::protobuf::rt::uint32_size(5, self.device_id);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.key != 0 {
            os.write_fixed32(1, self.key)?;
        }
        if self.hour != 0 {
            os.write_uint32(2, self.hour)?;
        }
        if self.minute != 0 {
            os.write_uint32(3, self.minute)?;
        }
        if self.second != 0 {
            os.write_uint32(4, self.second)?;
        }
        if self.device_id != 0 {
            os.write_uint32(5, self.device_id)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> TimeCommandRequest {
        TimeCommandRequest::new()
    }

    fn clear(&mut self) {
        self.key = 0;
        self.hour = 0;
        self.minute = 0;
        self.second = 0;
        self.device_id = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static TimeCommandRequest {
        static instance: TimeCommandRequest = TimeCommandRequest {
            key: 0,
            hour: 0,
            minute: 0,
            second: 0,
            device_id: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for TimeCommandRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("TimeCommandRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for TimeCommandRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for TimeCommandRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:ListEntitiesEventResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ListEntitiesEventResponse {
    // message fields
    // @@protoc_insertion_point(field:ListEntitiesEventResponse.object_id)
    pub object_id: ::std::string::String,
    // @@protoc_insertion_point(field:ListEntitiesEventResponse.key)
    pub key: u32,
    // @@protoc_insertion_point(field:ListEntitiesEventResponse.name)
    pub name: ::std::string::String,
    // @@protoc_insertion_point(field:ListEntitiesEventResponse.unique_id)
    pub unique_id: ::std::string::String,
    // @@protoc_insertion_point(field:ListEntitiesEventResponse.icon)
    pub icon: ::std::string::String,
    // @@protoc_insertion_point(field:ListEntitiesEventResponse.disabled_by_default)
    pub disabled_by_default: bool,
    // @@protoc_insertion_point(field:ListEntitiesEventResponse.entity_category)
    pub entity_category: ::protobuf::EnumOrUnknown<EntityCategory>,
    // @@protoc_insertion_point(field:ListEntitiesEventResponse.device_class)
    pub device_class: ::std::string::String,
    // @@protoc_insertion_point(field:ListEntitiesEventResponse.event_types)
    pub event_types: ::std::vec::Vec<::std::string::String>,
    // @@protoc_insertion_point(field:ListEntitiesEventResponse.device_id)
    pub device_id: u32,
    // special fields
    // @@protoc_insertion_point(special_field:ListEntitiesEventResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ListEntitiesEventResponse {
    fn default() -> &'a ListEntitiesEventResponse {
        <ListEntitiesEventResponse as ::protobuf::Message>::default_instance()
    }
}

impl ListEntitiesEventResponse {
    pub fn new() -> ListEntitiesEventResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(10);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "object_id",
            |m: &ListEntitiesEventResponse| { &m.object_id },
            |m: &mut ListEntitiesEventResponse| { &mut m.object_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "key",
            |m: &ListEntitiesEventResponse| { &m.key },
            |m: &mut ListEntitiesEventResponse| { &mut m.key },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "name",
            |m: &ListEntitiesEventResponse| { &m.name },
            |m: &mut ListEntitiesEventResponse| { &mut m.name },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "unique_id",
            |m: &ListEntitiesEventResponse| { &m.unique_id },
            |m: &mut ListEntitiesEventResponse| { &mut m.unique_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "icon",
            |m: &ListEntitiesEventResponse| { &m.icon },
            |m: &mut ListEntitiesEventResponse| { &mut m.icon },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "disabled_by_default",
            |m: &ListEntitiesEventResponse| { &m.disabled_by_default },
            |m: &mut ListEntitiesEventResponse| { &mut m.disabled_by_default },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "entity_category",
            |m: &ListEntitiesEventResponse| { &m.entity_category },
            |m: &mut ListEntitiesEventResponse| { &mut m.entity_category },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "device_class",
            |m: &ListEntitiesEventResponse| { &m.device_class },
            |m: &mut ListEntitiesEventResponse| { &mut m.device_class },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_vec_simpler_accessor::<_, _>(
            "event_types",
            |m: &ListEntitiesEventResponse| { &m.event_types },
            |m: &mut ListEntitiesEventResponse| { &mut m.event_types },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "device_id",
            |m: &ListEntitiesEventResponse| { &m.device_id },
            |m: &mut ListEntitiesEventResponse| { &mut m.device_id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ListEntitiesEventResponse>(
            "ListEntitiesEventResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ListEntitiesEventResponse {
    const NAME: &'static str = "ListEntitiesEventResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.object_id = is.read_string()?;
                },
                21 => {
                    self.key = is.read_fixed32()?;
                },
                26 => {
                    self.name = is.read_string()?;
                },
                34 => {
                    self.unique_id = is.read_string()?;
                },
                42 => {
                    self.icon = is.read_string()?;
                },
                48 => {
                    self.disabled_by_default = is.read_bool()?;
                },
                56 => {
                    self.entity_category = is.read_enum_or_unknown()?;
                },
                66 => {
                    self.device_class = is.read_string()?;
                },
                74 => {
                    self.event_types.push(is.read_string()?);
                },
                80 => {
                    self.device_id = is.read_uint32()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.object_id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.object_id);
        }
        if self.key != 0 {
            my_size += 1 + 4;
        }
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.name);
        }
        if !self.unique_id.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.unique_id);
        }
        if !self.icon.is_empty() {
            my_size += ::protobuf::rt::string_size(5, &self.icon);
        }
        if self.disabled_by_default != false {
            my_size += 1 + 1;
        }
        if self.entity_category != ::protobuf::EnumOrUnknown::new(EntityCategory::ENTITY_CATEGORY_NONE) {
            my_size += ::protobuf::rt::int32_size(7, self.entity_category.value());
        }
        if !self.device_class.is_empty() {
            my_size += ::protobuf::rt::string_size(8, &self.device_class);
        }
        for value in &self.event_types {
            my_size += ::protobuf::rt::string_size(9, &value);
        };
        if self.device_id != 0 {
            my_size += ::protobuf::rt::uint32_size(10, self.device_id);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.object_id.is_empty() {
            os.write_string(1, &self.object_id)?;
        }
        if self.key != 0 {
            os.write_fixed32(2, self.key)?;
        }
        if !self.name.is_empty() {
            os.write_string(3, &self.name)?;
        }
        if !self.unique_id.is_empty() {
            os.write_string(4, &self.unique_id)?;
        }
        if !self.icon.is_empty() {
            os.write_string(5, &self.icon)?;
        }
        if self.disabled_by_default != false {
            os.write_bool(6, self.disabled_by_default)?;
        }
        if self.entity_category != ::protobuf::EnumOrUnknown::new(EntityCategory::ENTITY_CATEGORY_NONE) {
            os.write_enum(7, ::protobuf::EnumOrUnknown::value(&self.entity_category))?;
        }
        if !self.device_class.is_empty() {
            os.write_string(8, &self.device_class)?;
        }
        for v in &self.event_types {
            os.write_string(9, &v)?;
        };
        if self.device_id != 0 {
            os.write_uint32(10, self.device_id)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ListEntitiesEventResponse {
        ListEntitiesEventResponse::new()
    }

    fn clear(&mut self) {
        self.object_id.clear();
        self.key = 0;
        self.name.clear();
        self.unique_id.clear();
        self.icon.clear();
        self.disabled_by_default = false;
        self.entity_category = ::protobuf::EnumOrUnknown::new(EntityCategory::ENTITY_CATEGORY_NONE);
        self.device_class.clear();
        self.event_types.clear();
        self.device_id = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ListEntitiesEventResponse {
        static instance: ListEntitiesEventResponse = ListEntitiesEventResponse {
            object_id: ::std::string::String::new(),
            key: 0,
            name: ::std::string::String::new(),
            unique_id: ::std::string::String::new(),
            icon: ::std::string::String::new(),
            disabled_by_default: false,
            entity_category: ::protobuf::EnumOrUnknown::from_i32(0),
            device_class: ::std::string::String::new(),
            event_types: ::std::vec::Vec::new(),
            device_id: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ListEntitiesEventResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ListEntitiesEventResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ListEntitiesEventResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ListEntitiesEventResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:EventResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct EventResponse {
    // message fields
    // @@protoc_insertion_point(field:EventResponse.key)
    pub key: u32,
    // @@protoc_insertion_point(field:EventResponse.event_type)
    pub event_type: ::std::string::String,
    // @@protoc_insertion_point(field:EventResponse.device_id)
    pub device_id: u32,
    // special fields
    // @@protoc_insertion_point(special_field:EventResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a EventResponse {
    fn default() -> &'a EventResponse {
        <EventResponse as ::protobuf::Message>::default_instance()
    }
}

impl EventResponse {
    pub fn new() -> EventResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "key",
            |m: &EventResponse| { &m.key },
            |m: &mut EventResponse| { &mut m.key },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "event_type",
            |m: &EventResponse| { &m.event_type },
            |m: &mut EventResponse| { &mut m.event_type },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "device_id",
            |m: &EventResponse| { &m.device_id },
            |m: &mut EventResponse| { &mut m.device_id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<EventResponse>(
            "EventResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for EventResponse {
    const NAME: &'static str = "EventResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                13 => {
                    self.key = is.read_fixed32()?;
                },
                18 => {
                    self.event_type = is.read_string()?;
                },
                24 => {
                    self.device_id = is.read_uint32()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.key != 0 {
            my_size += 1 + 4;
        }
        if !self.event_type.is_empty() {
            my_size += ::protobuf::rt::string_size(2, &self.event_type);
        }
        if self.device_id != 0 {
            my_size += ::protobuf::rt::uint32_size(3, self.device_id);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.key != 0 {
            os.write_fixed32(1, self.key)?;
        }
        if !self.event_type.is_empty() {
            os.write_string(2, &self.event_type)?;
        }
        if self.device_id != 0 {
            os.write_uint32(3, self.device_id)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> EventResponse {
        EventResponse::new()
    }

    fn clear(&mut self) {
        self.key = 0;
        self.event_type.clear();
        self.device_id = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static EventResponse {
        static instance: EventResponse = EventResponse {
            key: 0,
            event_type: ::std::string::String::new(),
            device_id: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for EventResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("EventResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for EventResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for EventResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:ListEntitiesValveResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ListEntitiesValveResponse {
    // message fields
    // @@protoc_insertion_point(field:ListEntitiesValveResponse.object_id)
    pub object_id: ::std::string::String,
    // @@protoc_insertion_point(field:ListEntitiesValveResponse.key)
    pub key: u32,
    // @@protoc_insertion_point(field:ListEntitiesValveResponse.name)
    pub name: ::std::string::String,
    // @@protoc_insertion_point(field:ListEntitiesValveResponse.unique_id)
    pub unique_id: ::std::string::String,
    // @@protoc_insertion_point(field:ListEntitiesValveResponse.icon)
    pub icon: ::std::string::String,
    // @@protoc_insertion_point(field:ListEntitiesValveResponse.disabled_by_default)
    pub disabled_by_default: bool,
    // @@protoc_insertion_point(field:ListEntitiesValveResponse.entity_category)
    pub entity_category: ::protobuf::EnumOrUnknown<EntityCategory>,
    // @@protoc_insertion_point(field:ListEntitiesValveResponse.device_class)
    pub device_class: ::std::string::String,
    // @@protoc_insertion_point(field:ListEntitiesValveResponse.assumed_state)
    pub assumed_state: bool,
    // @@protoc_insertion_point(field:ListEntitiesValveResponse.supports_position)
    pub supports_position: bool,
    // @@protoc_insertion_point(field:ListEntitiesValveResponse.supports_stop)
    pub supports_stop: bool,
    // @@protoc_insertion_point(field:ListEntitiesValveResponse.device_id)
    pub device_id: u32,
    // special fields
    // @@protoc_insertion_point(special_field:ListEntitiesValveResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ListEntitiesValveResponse {
    fn default() -> &'a ListEntitiesValveResponse {
        <ListEntitiesValveResponse as ::protobuf::Message>::default_instance()
    }
}

impl ListEntitiesValveResponse {
    pub fn new() -> ListEntitiesValveResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(12);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "object_id",
            |m: &ListEntitiesValveResponse| { &m.object_id },
            |m: &mut ListEntitiesValveResponse| { &mut m.object_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "key",
            |m: &ListEntitiesValveResponse| { &m.key },
            |m: &mut ListEntitiesValveResponse| { &mut m.key },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "name",
            |m: &ListEntitiesValveResponse| { &m.name },
            |m: &mut ListEntitiesValveResponse| { &mut m.name },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "unique_id",
            |m: &ListEntitiesValveResponse| { &m.unique_id },
            |m: &mut ListEntitiesValveResponse| { &mut m.unique_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "icon",
            |m: &ListEntitiesValveResponse| { &m.icon },
            |m: &mut ListEntitiesValveResponse| { &mut m.icon },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "disabled_by_default",
            |m: &ListEntitiesValveResponse| { &m.disabled_by_default },
            |m: &mut ListEntitiesValveResponse| { &mut m.disabled_by_default },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "entity_category",
            |m: &ListEntitiesValveResponse| { &m.entity_category },
            |m: &mut ListEntitiesValveResponse| { &mut m.entity_category },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "device_class",
            |m: &ListEntitiesValveResponse| { &m.device_class },
            |m: &mut ListEntitiesValveResponse| { &mut m.device_class },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "assumed_state",
            |m: &ListEntitiesValveResponse| { &m.assumed_state },
            |m: &mut ListEntitiesValveResponse| { &mut m.assumed_state },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "supports_position",
            |m: &ListEntitiesValveResponse| { &m.supports_position },
            |m: &mut ListEntitiesValveResponse| { &mut m.supports_position },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "supports_stop",
            |m: &ListEntitiesValveResponse| { &m.supports_stop },
            |m: &mut ListEntitiesValveResponse| { &mut m.supports_stop },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "device_id",
            |m: &ListEntitiesValveResponse| { &m.device_id },
            |m: &mut ListEntitiesValveResponse| { &mut m.device_id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ListEntitiesValveResponse>(
            "ListEntitiesValveResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ListEntitiesValveResponse {
    const NAME: &'static str = "ListEntitiesValveResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.object_id = is.read_string()?;
                },
                21 => {
                    self.key = is.read_fixed32()?;
                },
                26 => {
                    self.name = is.read_string()?;
                },
                34 => {
                    self.unique_id = is.read_string()?;
                },
                42 => {
                    self.icon = is.read_string()?;
                },
                48 => {
                    self.disabled_by_default = is.read_bool()?;
                },
                56 => {
                    self.entity_category = is.read_enum_or_unknown()?;
                },
                66 => {
                    self.device_class = is.read_string()?;
                },
                72 => {
                    self.assumed_state = is.read_bool()?;
                },
                80 => {
                    self.supports_position = is.read_bool()?;
                },
                88 => {
                    self.supports_stop = is.read_bool()?;
                },
                96 => {
                    self.device_id = is.read_uint32()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.object_id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.object_id);
        }
        if self.key != 0 {
            my_size += 1 + 4;
        }
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.name);
        }
        if !self.unique_id.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.unique_id);
        }
        if !self.icon.is_empty() {
            my_size += ::protobuf::rt::string_size(5, &self.icon);
        }
        if self.disabled_by_default != false {
            my_size += 1 + 1;
        }
        if self.entity_category != ::protobuf::EnumOrUnknown::new(EntityCategory::ENTITY_CATEGORY_NONE) {
            my_size += ::protobuf::rt::int32_size(7, self.entity_category.value());
        }
        if !self.device_class.is_empty() {
            my_size += ::protobuf::rt::string_size(8, &self.device_class);
        }
        if self.assumed_state != false {
            my_size += 1 + 1;
        }
        if self.supports_position != false {
            my_size += 1 + 1;
        }
        if self.supports_stop != false {
            my_size += 1 + 1;
        }
        if self.device_id != 0 {
            my_size += ::protobuf::rt::uint32_size(12, self.device_id);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.object_id.is_empty() {
            os.write_string(1, &self.object_id)?;
        }
        if self.key != 0 {
            os.write_fixed32(2, self.key)?;
        }
        if !self.name.is_empty() {
            os.write_string(3, &self.name)?;
        }
        if !self.unique_id.is_empty() {
            os.write_string(4, &self.unique_id)?;
        }
        if !self.icon.is_empty() {
            os.write_string(5, &self.icon)?;
        }
        if self.disabled_by_default != false {
            os.write_bool(6, self.disabled_by_default)?;
        }
        if self.entity_category != ::protobuf::EnumOrUnknown::new(EntityCategory::ENTITY_CATEGORY_NONE) {
            os.write_enum(7, ::protobuf::EnumOrUnknown::value(&self.entity_category))?;
        }
        if !self.device_class.is_empty() {
            os.write_string(8, &self.device_class)?;
        }
        if self.assumed_state != false {
            os.write_bool(9, self.assumed_state)?;
        }
        if self.supports_position != false {
            os.write_bool(10, self.supports_position)?;
        }
        if self.supports_stop != false {
            os.write_bool(11, self.supports_stop)?;
        }
        if self.device_id != 0 {
            os.write_uint32(12, self.device_id)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ListEntitiesValveResponse {
        ListEntitiesValveResponse::new()
    }

    fn clear(&mut self) {
        self.object_id.clear();
        self.key = 0;
        self.name.clear();
        self.unique_id.clear();
        self.icon.clear();
        self.disabled_by_default = false;
        self.entity_category = ::protobuf::EnumOrUnknown::new(EntityCategory::ENTITY_CATEGORY_NONE);
        self.device_class.clear();
        self.assumed_state = false;
        self.supports_position = false;
        self.supports_stop = false;
        self.device_id = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ListEntitiesValveResponse {
        static instance: ListEntitiesValveResponse = ListEntitiesValveResponse {
            object_id: ::std::string::String::new(),
            key: 0,
            name: ::std::string::String::new(),
            unique_id: ::std::string::String::new(),
            icon: ::std::string::String::new(),
            disabled_by_default: false,
            entity_category: ::protobuf::EnumOrUnknown::from_i32(0),
            device_class: ::std::string::String::new(),
            assumed_state: false,
            supports_position: false,
            supports_stop: false,
            device_id: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ListEntitiesValveResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ListEntitiesValveResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ListEntitiesValveResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ListEntitiesValveResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:ValveStateResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ValveStateResponse {
    // message fields
    // @@protoc_insertion_point(field:ValveStateResponse.key)
    pub key: u32,
    // @@protoc_insertion_point(field:ValveStateResponse.position)
    pub position: f32,
    // @@protoc_insertion_point(field:ValveStateResponse.current_operation)
    pub current_operation: ::protobuf::EnumOrUnknown<ValveOperation>,
    // @@protoc_insertion_point(field:ValveStateResponse.device_id)
    pub device_id: u32,
    // special fields
    // @@protoc_insertion_point(special_field:ValveStateResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ValveStateResponse {
    fn default() -> &'a ValveStateResponse {
        <ValveStateResponse as ::protobuf::Message>::default_instance()
    }
}

impl ValveStateResponse {
    pub fn new() -> ValveStateResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "key",
            |m: &ValveStateResponse| { &m.key },
            |m: &mut ValveStateResponse| { &mut m.key },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "position",
            |m: &ValveStateResponse| { &m.position },
            |m: &mut ValveStateResponse| { &mut m.position },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "current_operation",
            |m: &ValveStateResponse| { &m.current_operation },
            |m: &mut ValveStateResponse| { &mut m.current_operation },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "device_id",
            |m: &ValveStateResponse| { &m.device_id },
            |m: &mut ValveStateResponse| { &mut m.device_id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ValveStateResponse>(
            "ValveStateResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ValveStateResponse {
    const NAME: &'static str = "ValveStateResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                13 => {
                    self.key = is.read_fixed32()?;
                },
                21 => {
                    self.position = is.read_float()?;
                },
                24 => {
                    self.current_operation = is.read_enum_or_unknown()?;
                },
                32 => {
                    self.device_id = is.read_uint32()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.key != 0 {
            my_size += 1 + 4;
        }
        if self.position != 0. {
            my_size += 1 + 4;
        }
        if self.current_operation != ::protobuf::EnumOrUnknown::new(ValveOperation::VALVE_OPERATION_IDLE) {
            my_size += ::protobuf::rt::int32_size(3, self.current_operation.value());
        }
        if self.device_id != 0 {
            my_size += ::protobuf::rt::uint32_size(4, self.device_id);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.key != 0 {
            os.write_fixed32(1, self.key)?;
        }
        if self.position != 0. {
            os.write_float(2, self.position)?;
        }
        if self.current_operation != ::protobuf::EnumOrUnknown::new(ValveOperation::VALVE_OPERATION_IDLE) {
            os.write_enum(3, ::protobuf::EnumOrUnknown::value(&self.current_operation))?;
        }
        if self.device_id != 0 {
            os.write_uint32(4, self.device_id)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ValveStateResponse {
        ValveStateResponse::new()
    }

    fn clear(&mut self) {
        self.key = 0;
        self.position = 0.;
        self.current_operation = ::protobuf::EnumOrUnknown::new(ValveOperation::VALVE_OPERATION_IDLE);
        self.device_id = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ValveStateResponse {
        static instance: ValveStateResponse = ValveStateResponse {
            key: 0,
            position: 0.,
            current_operation: ::protobuf::EnumOrUnknown::from_i32(0),
            device_id: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ValveStateResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ValveStateResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ValveStateResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ValveStateResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:ValveCommandRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ValveCommandRequest {
    // message fields
    // @@protoc_insertion_point(field:ValveCommandRequest.key)
    pub key: u32,
    // @@protoc_insertion_point(field:ValveCommandRequest.has_position)
    pub has_position: bool,
    // @@protoc_insertion_point(field:ValveCommandRequest.position)
    pub position: f32,
    // @@protoc_insertion_point(field:ValveCommandRequest.stop)
    pub stop: bool,
    // @@protoc_insertion_point(field:ValveCommandRequest.device_id)
    pub device_id: u32,
    // special fields
    // @@protoc_insertion_point(special_field:ValveCommandRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ValveCommandRequest {
    fn default() -> &'a ValveCommandRequest {
        <ValveCommandRequest as ::protobuf::Message>::default_instance()
    }
}

impl ValveCommandRequest {
    pub fn new() -> ValveCommandRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(5);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "key",
            |m: &ValveCommandRequest| { &m.key },
            |m: &mut ValveCommandRequest| { &mut m.key },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "has_position",
            |m: &ValveCommandRequest| { &m.has_position },
            |m: &mut ValveCommandRequest| { &mut m.has_position },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "position",
            |m: &ValveCommandRequest| { &m.position },
            |m: &mut ValveCommandRequest| { &mut m.position },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "stop",
            |m: &ValveCommandRequest| { &m.stop },
            |m: &mut ValveCommandRequest| { &mut m.stop },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "device_id",
            |m: &ValveCommandRequest| { &m.device_id },
            |m: &mut ValveCommandRequest| { &mut m.device_id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ValveCommandRequest>(
            "ValveCommandRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ValveCommandRequest {
    const NAME: &'static str = "ValveCommandRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                13 => {
                    self.key = is.read_fixed32()?;
                },
                16 => {
                    self.has_position = is.read_bool()?;
                },
                29 => {
                    self.position = is.read_float()?;
                },
                32 => {
                    self.stop = is.read_bool()?;
                },
                40 => {
                    self.device_id = is.read_uint32()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.key != 0 {
            my_size += 1 + 4;
        }
        if self.has_position != false {
            my_size += 1 + 1;
        }
        if self.position != 0. {
            my_size += 1 + 4;
        }
        if self.stop != false {
            my_size += 1 + 1;
        }
        if self.device_id != 0 {
            my_size += ::protobuf::rt::uint32_size(5, self.device_id);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.key != 0 {
            os.write_fixed32(1, self.key)?;
        }
        if self.has_position != false {
            os.write_bool(2, self.has_position)?;
        }
        if self.position != 0. {
            os.write_float(3, self.position)?;
        }
        if self.stop != false {
            os.write_bool(4, self.stop)?;
        }
        if self.device_id != 0 {
            os.write_uint32(5, self.device_id)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ValveCommandRequest {
        ValveCommandRequest::new()
    }

    fn clear(&mut self) {
        self.key = 0;
        self.has_position = false;
        self.position = 0.;
        self.stop = false;
        self.device_id = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ValveCommandRequest {
        static instance: ValveCommandRequest = ValveCommandRequest {
            key: 0,
            has_position: false,
            position: 0.,
            stop: false,
            device_id: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ValveCommandRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ValveCommandRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ValveCommandRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ValveCommandRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:ListEntitiesDateTimeResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ListEntitiesDateTimeResponse {
    // message fields
    // @@protoc_insertion_point(field:ListEntitiesDateTimeResponse.object_id)
    pub object_id: ::std::string::String,
    // @@protoc_insertion_point(field:ListEntitiesDateTimeResponse.key)
    pub key: u32,
    // @@protoc_insertion_point(field:ListEntitiesDateTimeResponse.name)
    pub name: ::std::string::String,
    // @@protoc_insertion_point(field:ListEntitiesDateTimeResponse.unique_id)
    pub unique_id: ::std::string::String,
    // @@protoc_insertion_point(field:ListEntitiesDateTimeResponse.icon)
    pub icon: ::std::string::String,
    // @@protoc_insertion_point(field:ListEntitiesDateTimeResponse.disabled_by_default)
    pub disabled_by_default: bool,
    // @@protoc_insertion_point(field:ListEntitiesDateTimeResponse.entity_category)
    pub entity_category: ::protobuf::EnumOrUnknown<EntityCategory>,
    // @@protoc_insertion_point(field:ListEntitiesDateTimeResponse.device_id)
    pub device_id: u32,
    // special fields
    // @@protoc_insertion_point(special_field:ListEntitiesDateTimeResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ListEntitiesDateTimeResponse {
    fn default() -> &'a ListEntitiesDateTimeResponse {
        <ListEntitiesDateTimeResponse as ::protobuf::Message>::default_instance()
    }
}

impl ListEntitiesDateTimeResponse {
    pub fn new() -> ListEntitiesDateTimeResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(8);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "object_id",
            |m: &ListEntitiesDateTimeResponse| { &m.object_id },
            |m: &mut ListEntitiesDateTimeResponse| { &mut m.object_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "key",
            |m: &ListEntitiesDateTimeResponse| { &m.key },
            |m: &mut ListEntitiesDateTimeResponse| { &mut m.key },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "name",
            |m: &ListEntitiesDateTimeResponse| { &m.name },
            |m: &mut ListEntitiesDateTimeResponse| { &mut m.name },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "unique_id",
            |m: &ListEntitiesDateTimeResponse| { &m.unique_id },
            |m: &mut ListEntitiesDateTimeResponse| { &mut m.unique_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "icon",
            |m: &ListEntitiesDateTimeResponse| { &m.icon },
            |m: &mut ListEntitiesDateTimeResponse| { &mut m.icon },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "disabled_by_default",
            |m: &ListEntitiesDateTimeResponse| { &m.disabled_by_default },
            |m: &mut ListEntitiesDateTimeResponse| { &mut m.disabled_by_default },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "entity_category",
            |m: &ListEntitiesDateTimeResponse| { &m.entity_category },
            |m: &mut ListEntitiesDateTimeResponse| { &mut m.entity_category },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "device_id",
            |m: &ListEntitiesDateTimeResponse| { &m.device_id },
            |m: &mut ListEntitiesDateTimeResponse| { &mut m.device_id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ListEntitiesDateTimeResponse>(
            "ListEntitiesDateTimeResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ListEntitiesDateTimeResponse {
    const NAME: &'static str = "ListEntitiesDateTimeResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.object_id = is.read_string()?;
                },
                21 => {
                    self.key = is.read_fixed32()?;
                },
                26 => {
                    self.name = is.read_string()?;
                },
                34 => {
                    self.unique_id = is.read_string()?;
                },
                42 => {
                    self.icon = is.read_string()?;
                },
                48 => {
                    self.disabled_by_default = is.read_bool()?;
                },
                56 => {
                    self.entity_category = is.read_enum_or_unknown()?;
                },
                64 => {
                    self.device_id = is.read_uint32()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.object_id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.object_id);
        }
        if self.key != 0 {
            my_size += 1 + 4;
        }
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.name);
        }
        if !self.unique_id.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.unique_id);
        }
        if !self.icon.is_empty() {
            my_size += ::protobuf::rt::string_size(5, &self.icon);
        }
        if self.disabled_by_default != false {
            my_size += 1 + 1;
        }
        if self.entity_category != ::protobuf::EnumOrUnknown::new(EntityCategory::ENTITY_CATEGORY_NONE) {
            my_size += ::protobuf::rt::int32_size(7, self.entity_category.value());
        }
        if self.device_id != 0 {
            my_size += ::protobuf::rt::uint32_size(8, self.device_id);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.object_id.is_empty() {
            os.write_string(1, &self.object_id)?;
        }
        if self.key != 0 {
            os.write_fixed32(2, self.key)?;
        }
        if !self.name.is_empty() {
            os.write_string(3, &self.name)?;
        }
        if !self.unique_id.is_empty() {
            os.write_string(4, &self.unique_id)?;
        }
        if !self.icon.is_empty() {
            os.write_string(5, &self.icon)?;
        }
        if self.disabled_by_default != false {
            os.write_bool(6, self.disabled_by_default)?;
        }
        if self.entity_category != ::protobuf::EnumOrUnknown::new(EntityCategory::ENTITY_CATEGORY_NONE) {
            os.write_enum(7, ::protobuf::EnumOrUnknown::value(&self.entity_category))?;
        }
        if self.device_id != 0 {
            os.write_uint32(8, self.device_id)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ListEntitiesDateTimeResponse {
        ListEntitiesDateTimeResponse::new()
    }

    fn clear(&mut self) {
        self.object_id.clear();
        self.key = 0;
        self.name.clear();
        self.unique_id.clear();
        self.icon.clear();
        self.disabled_by_default = false;
        self.entity_category = ::protobuf::EnumOrUnknown::new(EntityCategory::ENTITY_CATEGORY_NONE);
        self.device_id = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ListEntitiesDateTimeResponse {
        static instance: ListEntitiesDateTimeResponse = ListEntitiesDateTimeResponse {
            object_id: ::std::string::String::new(),
            key: 0,
            name: ::std::string::String::new(),
            unique_id: ::std::string::String::new(),
            icon: ::std::string::String::new(),
            disabled_by_default: false,
            entity_category: ::protobuf::EnumOrUnknown::from_i32(0),
            device_id: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ListEntitiesDateTimeResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ListEntitiesDateTimeResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ListEntitiesDateTimeResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ListEntitiesDateTimeResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:DateTimeStateResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct DateTimeStateResponse {
    // message fields
    // @@protoc_insertion_point(field:DateTimeStateResponse.key)
    pub key: u32,
    // @@protoc_insertion_point(field:DateTimeStateResponse.missing_state)
    pub missing_state: bool,
    // @@protoc_insertion_point(field:DateTimeStateResponse.epoch_seconds)
    pub epoch_seconds: u32,
    // @@protoc_insertion_point(field:DateTimeStateResponse.device_id)
    pub device_id: u32,
    // special fields
    // @@protoc_insertion_point(special_field:DateTimeStateResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a DateTimeStateResponse {
    fn default() -> &'a DateTimeStateResponse {
        <DateTimeStateResponse as ::protobuf::Message>::default_instance()
    }
}

impl DateTimeStateResponse {
    pub fn new() -> DateTimeStateResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(4);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "key",
            |m: &DateTimeStateResponse| { &m.key },
            |m: &mut DateTimeStateResponse| { &mut m.key },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "missing_state",
            |m: &DateTimeStateResponse| { &m.missing_state },
            |m: &mut DateTimeStateResponse| { &mut m.missing_state },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "epoch_seconds",
            |m: &DateTimeStateResponse| { &m.epoch_seconds },
            |m: &mut DateTimeStateResponse| { &mut m.epoch_seconds },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "device_id",
            |m: &DateTimeStateResponse| { &m.device_id },
            |m: &mut DateTimeStateResponse| { &mut m.device_id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<DateTimeStateResponse>(
            "DateTimeStateResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for DateTimeStateResponse {
    const NAME: &'static str = "DateTimeStateResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                13 => {
                    self.key = is.read_fixed32()?;
                },
                16 => {
                    self.missing_state = is.read_bool()?;
                },
                29 => {
                    self.epoch_seconds = is.read_fixed32()?;
                },
                32 => {
                    self.device_id = is.read_uint32()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.key != 0 {
            my_size += 1 + 4;
        }
        if self.missing_state != false {
            my_size += 1 + 1;
        }
        if self.epoch_seconds != 0 {
            my_size += 1 + 4;
        }
        if self.device_id != 0 {
            my_size += ::protobuf::rt::uint32_size(4, self.device_id);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.key != 0 {
            os.write_fixed32(1, self.key)?;
        }
        if self.missing_state != false {
            os.write_bool(2, self.missing_state)?;
        }
        if self.epoch_seconds != 0 {
            os.write_fixed32(3, self.epoch_seconds)?;
        }
        if self.device_id != 0 {
            os.write_uint32(4, self.device_id)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> DateTimeStateResponse {
        DateTimeStateResponse::new()
    }

    fn clear(&mut self) {
        self.key = 0;
        self.missing_state = false;
        self.epoch_seconds = 0;
        self.device_id = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static DateTimeStateResponse {
        static instance: DateTimeStateResponse = DateTimeStateResponse {
            key: 0,
            missing_state: false,
            epoch_seconds: 0,
            device_id: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for DateTimeStateResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("DateTimeStateResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for DateTimeStateResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DateTimeStateResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:DateTimeCommandRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct DateTimeCommandRequest {
    // message fields
    // @@protoc_insertion_point(field:DateTimeCommandRequest.key)
    pub key: u32,
    // @@protoc_insertion_point(field:DateTimeCommandRequest.epoch_seconds)
    pub epoch_seconds: u32,
    // @@protoc_insertion_point(field:DateTimeCommandRequest.device_id)
    pub device_id: u32,
    // special fields
    // @@protoc_insertion_point(special_field:DateTimeCommandRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a DateTimeCommandRequest {
    fn default() -> &'a DateTimeCommandRequest {
        <DateTimeCommandRequest as ::protobuf::Message>::default_instance()
    }
}

impl DateTimeCommandRequest {
    pub fn new() -> DateTimeCommandRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "key",
            |m: &DateTimeCommandRequest| { &m.key },
            |m: &mut DateTimeCommandRequest| { &mut m.key },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "epoch_seconds",
            |m: &DateTimeCommandRequest| { &m.epoch_seconds },
            |m: &mut DateTimeCommandRequest| { &mut m.epoch_seconds },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "device_id",
            |m: &DateTimeCommandRequest| { &m.device_id },
            |m: &mut DateTimeCommandRequest| { &mut m.device_id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<DateTimeCommandRequest>(
            "DateTimeCommandRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for DateTimeCommandRequest {
    const NAME: &'static str = "DateTimeCommandRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                13 => {
                    self.key = is.read_fixed32()?;
                },
                21 => {
                    self.epoch_seconds = is.read_fixed32()?;
                },
                24 => {
                    self.device_id = is.read_uint32()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.key != 0 {
            my_size += 1 + 4;
        }
        if self.epoch_seconds != 0 {
            my_size += 1 + 4;
        }
        if self.device_id != 0 {
            my_size += ::protobuf::rt::uint32_size(3, self.device_id);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.key != 0 {
            os.write_fixed32(1, self.key)?;
        }
        if self.epoch_seconds != 0 {
            os.write_fixed32(2, self.epoch_seconds)?;
        }
        if self.device_id != 0 {
            os.write_uint32(3, self.device_id)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> DateTimeCommandRequest {
        DateTimeCommandRequest::new()
    }

    fn clear(&mut self) {
        self.key = 0;
        self.epoch_seconds = 0;
        self.device_id = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static DateTimeCommandRequest {
        static instance: DateTimeCommandRequest = DateTimeCommandRequest {
            key: 0,
            epoch_seconds: 0,
            device_id: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for DateTimeCommandRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("DateTimeCommandRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for DateTimeCommandRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for DateTimeCommandRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:ListEntitiesUpdateResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct ListEntitiesUpdateResponse {
    // message fields
    // @@protoc_insertion_point(field:ListEntitiesUpdateResponse.object_id)
    pub object_id: ::std::string::String,
    // @@protoc_insertion_point(field:ListEntitiesUpdateResponse.key)
    pub key: u32,
    // @@protoc_insertion_point(field:ListEntitiesUpdateResponse.name)
    pub name: ::std::string::String,
    // @@protoc_insertion_point(field:ListEntitiesUpdateResponse.unique_id)
    pub unique_id: ::std::string::String,
    // @@protoc_insertion_point(field:ListEntitiesUpdateResponse.icon)
    pub icon: ::std::string::String,
    // @@protoc_insertion_point(field:ListEntitiesUpdateResponse.disabled_by_default)
    pub disabled_by_default: bool,
    // @@protoc_insertion_point(field:ListEntitiesUpdateResponse.entity_category)
    pub entity_category: ::protobuf::EnumOrUnknown<EntityCategory>,
    // @@protoc_insertion_point(field:ListEntitiesUpdateResponse.device_class)
    pub device_class: ::std::string::String,
    // @@protoc_insertion_point(field:ListEntitiesUpdateResponse.device_id)
    pub device_id: u32,
    // special fields
    // @@protoc_insertion_point(special_field:ListEntitiesUpdateResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a ListEntitiesUpdateResponse {
    fn default() -> &'a ListEntitiesUpdateResponse {
        <ListEntitiesUpdateResponse as ::protobuf::Message>::default_instance()
    }
}

impl ListEntitiesUpdateResponse {
    pub fn new() -> ListEntitiesUpdateResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(9);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "object_id",
            |m: &ListEntitiesUpdateResponse| { &m.object_id },
            |m: &mut ListEntitiesUpdateResponse| { &mut m.object_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "key",
            |m: &ListEntitiesUpdateResponse| { &m.key },
            |m: &mut ListEntitiesUpdateResponse| { &mut m.key },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "name",
            |m: &ListEntitiesUpdateResponse| { &m.name },
            |m: &mut ListEntitiesUpdateResponse| { &mut m.name },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "unique_id",
            |m: &ListEntitiesUpdateResponse| { &m.unique_id },
            |m: &mut ListEntitiesUpdateResponse| { &mut m.unique_id },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "icon",
            |m: &ListEntitiesUpdateResponse| { &m.icon },
            |m: &mut ListEntitiesUpdateResponse| { &mut m.icon },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "disabled_by_default",
            |m: &ListEntitiesUpdateResponse| { &m.disabled_by_default },
            |m: &mut ListEntitiesUpdateResponse| { &mut m.disabled_by_default },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "entity_category",
            |m: &ListEntitiesUpdateResponse| { &m.entity_category },
            |m: &mut ListEntitiesUpdateResponse| { &mut m.entity_category },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "device_class",
            |m: &ListEntitiesUpdateResponse| { &m.device_class },
            |m: &mut ListEntitiesUpdateResponse| { &mut m.device_class },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "device_id",
            |m: &ListEntitiesUpdateResponse| { &m.device_id },
            |m: &mut ListEntitiesUpdateResponse| { &mut m.device_id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<ListEntitiesUpdateResponse>(
            "ListEntitiesUpdateResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for ListEntitiesUpdateResponse {
    const NAME: &'static str = "ListEntitiesUpdateResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                10 => {
                    self.object_id = is.read_string()?;
                },
                21 => {
                    self.key = is.read_fixed32()?;
                },
                26 => {
                    self.name = is.read_string()?;
                },
                34 => {
                    self.unique_id = is.read_string()?;
                },
                42 => {
                    self.icon = is.read_string()?;
                },
                48 => {
                    self.disabled_by_default = is.read_bool()?;
                },
                56 => {
                    self.entity_category = is.read_enum_or_unknown()?;
                },
                66 => {
                    self.device_class = is.read_string()?;
                },
                72 => {
                    self.device_id = is.read_uint32()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if !self.object_id.is_empty() {
            my_size += ::protobuf::rt::string_size(1, &self.object_id);
        }
        if self.key != 0 {
            my_size += 1 + 4;
        }
        if !self.name.is_empty() {
            my_size += ::protobuf::rt::string_size(3, &self.name);
        }
        if !self.unique_id.is_empty() {
            my_size += ::protobuf::rt::string_size(4, &self.unique_id);
        }
        if !self.icon.is_empty() {
            my_size += ::protobuf::rt::string_size(5, &self.icon);
        }
        if self.disabled_by_default != false {
            my_size += 1 + 1;
        }
        if self.entity_category != ::protobuf::EnumOrUnknown::new(EntityCategory::ENTITY_CATEGORY_NONE) {
            my_size += ::protobuf::rt::int32_size(7, self.entity_category.value());
        }
        if !self.device_class.is_empty() {
            my_size += ::protobuf::rt::string_size(8, &self.device_class);
        }
        if self.device_id != 0 {
            my_size += ::protobuf::rt::uint32_size(9, self.device_id);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if !self.object_id.is_empty() {
            os.write_string(1, &self.object_id)?;
        }
        if self.key != 0 {
            os.write_fixed32(2, self.key)?;
        }
        if !self.name.is_empty() {
            os.write_string(3, &self.name)?;
        }
        if !self.unique_id.is_empty() {
            os.write_string(4, &self.unique_id)?;
        }
        if !self.icon.is_empty() {
            os.write_string(5, &self.icon)?;
        }
        if self.disabled_by_default != false {
            os.write_bool(6, self.disabled_by_default)?;
        }
        if self.entity_category != ::protobuf::EnumOrUnknown::new(EntityCategory::ENTITY_CATEGORY_NONE) {
            os.write_enum(7, ::protobuf::EnumOrUnknown::value(&self.entity_category))?;
        }
        if !self.device_class.is_empty() {
            os.write_string(8, &self.device_class)?;
        }
        if self.device_id != 0 {
            os.write_uint32(9, self.device_id)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> ListEntitiesUpdateResponse {
        ListEntitiesUpdateResponse::new()
    }

    fn clear(&mut self) {
        self.object_id.clear();
        self.key = 0;
        self.name.clear();
        self.unique_id.clear();
        self.icon.clear();
        self.disabled_by_default = false;
        self.entity_category = ::protobuf::EnumOrUnknown::new(EntityCategory::ENTITY_CATEGORY_NONE);
        self.device_class.clear();
        self.device_id = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static ListEntitiesUpdateResponse {
        static instance: ListEntitiesUpdateResponse = ListEntitiesUpdateResponse {
            object_id: ::std::string::String::new(),
            key: 0,
            name: ::std::string::String::new(),
            unique_id: ::std::string::String::new(),
            icon: ::std::string::String::new(),
            disabled_by_default: false,
            entity_category: ::protobuf::EnumOrUnknown::from_i32(0),
            device_class: ::std::string::String::new(),
            device_id: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for ListEntitiesUpdateResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("ListEntitiesUpdateResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for ListEntitiesUpdateResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for ListEntitiesUpdateResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:UpdateStateResponse)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct UpdateStateResponse {
    // message fields
    // @@protoc_insertion_point(field:UpdateStateResponse.key)
    pub key: u32,
    // @@protoc_insertion_point(field:UpdateStateResponse.missing_state)
    pub missing_state: bool,
    // @@protoc_insertion_point(field:UpdateStateResponse.in_progress)
    pub in_progress: bool,
    // @@protoc_insertion_point(field:UpdateStateResponse.has_progress)
    pub has_progress: bool,
    // @@protoc_insertion_point(field:UpdateStateResponse.progress)
    pub progress: f32,
    // @@protoc_insertion_point(field:UpdateStateResponse.current_version)
    pub current_version: ::std::string::String,
    // @@protoc_insertion_point(field:UpdateStateResponse.latest_version)
    pub latest_version: ::std::string::String,
    // @@protoc_insertion_point(field:UpdateStateResponse.title)
    pub title: ::std::string::String,
    // @@protoc_insertion_point(field:UpdateStateResponse.release_summary)
    pub release_summary: ::std::string::String,
    // @@protoc_insertion_point(field:UpdateStateResponse.release_url)
    pub release_url: ::std::string::String,
    // @@protoc_insertion_point(field:UpdateStateResponse.device_id)
    pub device_id: u32,
    // special fields
    // @@protoc_insertion_point(special_field:UpdateStateResponse.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a UpdateStateResponse {
    fn default() -> &'a UpdateStateResponse {
        <UpdateStateResponse as ::protobuf::Message>::default_instance()
    }
}

impl UpdateStateResponse {
    pub fn new() -> UpdateStateResponse {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(11);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "key",
            |m: &UpdateStateResponse| { &m.key },
            |m: &mut UpdateStateResponse| { &mut m.key },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "missing_state",
            |m: &UpdateStateResponse| { &m.missing_state },
            |m: &mut UpdateStateResponse| { &mut m.missing_state },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "in_progress",
            |m: &UpdateStateResponse| { &m.in_progress },
            |m: &mut UpdateStateResponse| { &mut m.in_progress },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "has_progress",
            |m: &UpdateStateResponse| { &m.has_progress },
            |m: &mut UpdateStateResponse| { &mut m.has_progress },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "progress",
            |m: &UpdateStateResponse| { &m.progress },
            |m: &mut UpdateStateResponse| { &mut m.progress },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "current_version",
            |m: &UpdateStateResponse| { &m.current_version },
            |m: &mut UpdateStateResponse| { &mut m.current_version },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "latest_version",
            |m: &UpdateStateResponse| { &m.latest_version },
            |m: &mut UpdateStateResponse| { &mut m.latest_version },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "title",
            |m: &UpdateStateResponse| { &m.title },
            |m: &mut UpdateStateResponse| { &mut m.title },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "release_summary",
            |m: &UpdateStateResponse| { &m.release_summary },
            |m: &mut UpdateStateResponse| { &mut m.release_summary },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "release_url",
            |m: &UpdateStateResponse| { &m.release_url },
            |m: &mut UpdateStateResponse| { &mut m.release_url },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "device_id",
            |m: &UpdateStateResponse| { &m.device_id },
            |m: &mut UpdateStateResponse| { &mut m.device_id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<UpdateStateResponse>(
            "UpdateStateResponse",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for UpdateStateResponse {
    const NAME: &'static str = "UpdateStateResponse";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                13 => {
                    self.key = is.read_fixed32()?;
                },
                16 => {
                    self.missing_state = is.read_bool()?;
                },
                24 => {
                    self.in_progress = is.read_bool()?;
                },
                32 => {
                    self.has_progress = is.read_bool()?;
                },
                45 => {
                    self.progress = is.read_float()?;
                },
                50 => {
                    self.current_version = is.read_string()?;
                },
                58 => {
                    self.latest_version = is.read_string()?;
                },
                66 => {
                    self.title = is.read_string()?;
                },
                74 => {
                    self.release_summary = is.read_string()?;
                },
                82 => {
                    self.release_url = is.read_string()?;
                },
                88 => {
                    self.device_id = is.read_uint32()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.key != 0 {
            my_size += 1 + 4;
        }
        if self.missing_state != false {
            my_size += 1 + 1;
        }
        if self.in_progress != false {
            my_size += 1 + 1;
        }
        if self.has_progress != false {
            my_size += 1 + 1;
        }
        if self.progress != 0. {
            my_size += 1 + 4;
        }
        if !self.current_version.is_empty() {
            my_size += ::protobuf::rt::string_size(6, &self.current_version);
        }
        if !self.latest_version.is_empty() {
            my_size += ::protobuf::rt::string_size(7, &self.latest_version);
        }
        if !self.title.is_empty() {
            my_size += ::protobuf::rt::string_size(8, &self.title);
        }
        if !self.release_summary.is_empty() {
            my_size += ::protobuf::rt::string_size(9, &self.release_summary);
        }
        if !self.release_url.is_empty() {
            my_size += ::protobuf::rt::string_size(10, &self.release_url);
        }
        if self.device_id != 0 {
            my_size += ::protobuf::rt::uint32_size(11, self.device_id);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.key != 0 {
            os.write_fixed32(1, self.key)?;
        }
        if self.missing_state != false {
            os.write_bool(2, self.missing_state)?;
        }
        if self.in_progress != false {
            os.write_bool(3, self.in_progress)?;
        }
        if self.has_progress != false {
            os.write_bool(4, self.has_progress)?;
        }
        if self.progress != 0. {
            os.write_float(5, self.progress)?;
        }
        if !self.current_version.is_empty() {
            os.write_string(6, &self.current_version)?;
        }
        if !self.latest_version.is_empty() {
            os.write_string(7, &self.latest_version)?;
        }
        if !self.title.is_empty() {
            os.write_string(8, &self.title)?;
        }
        if !self.release_summary.is_empty() {
            os.write_string(9, &self.release_summary)?;
        }
        if !self.release_url.is_empty() {
            os.write_string(10, &self.release_url)?;
        }
        if self.device_id != 0 {
            os.write_uint32(11, self.device_id)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> UpdateStateResponse {
        UpdateStateResponse::new()
    }

    fn clear(&mut self) {
        self.key = 0;
        self.missing_state = false;
        self.in_progress = false;
        self.has_progress = false;
        self.progress = 0.;
        self.current_version.clear();
        self.latest_version.clear();
        self.title.clear();
        self.release_summary.clear();
        self.release_url.clear();
        self.device_id = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static UpdateStateResponse {
        static instance: UpdateStateResponse = UpdateStateResponse {
            key: 0,
            missing_state: false,
            in_progress: false,
            has_progress: false,
            progress: 0.,
            current_version: ::std::string::String::new(),
            latest_version: ::std::string::String::new(),
            title: ::std::string::String::new(),
            release_summary: ::std::string::String::new(),
            release_url: ::std::string::String::new(),
            device_id: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for UpdateStateResponse {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("UpdateStateResponse").unwrap()).clone()
    }
}

impl ::std::fmt::Display for UpdateStateResponse {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for UpdateStateResponse {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

// @@protoc_insertion_point(message:UpdateCommandRequest)
#[derive(PartialEq,Clone,Default,Debug)]
pub struct UpdateCommandRequest {
    // message fields
    // @@protoc_insertion_point(field:UpdateCommandRequest.key)
    pub key: u32,
    // @@protoc_insertion_point(field:UpdateCommandRequest.command)
    pub command: ::protobuf::EnumOrUnknown<UpdateCommand>,
    // @@protoc_insertion_point(field:UpdateCommandRequest.device_id)
    pub device_id: u32,
    // special fields
    // @@protoc_insertion_point(special_field:UpdateCommandRequest.special_fields)
    pub special_fields: ::protobuf::SpecialFields,
}

impl<'a> ::std::default::Default for &'a UpdateCommandRequest {
    fn default() -> &'a UpdateCommandRequest {
        <UpdateCommandRequest as ::protobuf::Message>::default_instance()
    }
}

impl UpdateCommandRequest {
    pub fn new() -> UpdateCommandRequest {
        ::std::default::Default::default()
    }

    fn generated_message_descriptor_data() -> ::protobuf::reflect::GeneratedMessageDescriptorData {
        let mut fields = ::std::vec::Vec::with_capacity(3);
        let mut oneofs = ::std::vec::Vec::with_capacity(0);
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "key",
            |m: &UpdateCommandRequest| { &m.key },
            |m: &mut UpdateCommandRequest| { &mut m.key },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "command",
            |m: &UpdateCommandRequest| { &m.command },
            |m: &mut UpdateCommandRequest| { &mut m.command },
        ));
        fields.push(::protobuf::reflect::rt::v2::make_simpler_field_accessor::<_, _>(
            "device_id",
            |m: &UpdateCommandRequest| { &m.device_id },
            |m: &mut UpdateCommandRequest| { &mut m.device_id },
        ));
        ::protobuf::reflect::GeneratedMessageDescriptorData::new_2::<UpdateCommandRequest>(
            "UpdateCommandRequest",
            fields,
            oneofs,
        )
    }
}

impl ::protobuf::Message for UpdateCommandRequest {
    const NAME: &'static str = "UpdateCommandRequest";

    fn is_initialized(&self) -> bool {
        true
    }

    fn merge_from(&mut self, is: &mut ::protobuf::CodedInputStream<'_>) -> ::protobuf::Result<()> {
        while let Some(tag) = is.read_raw_tag_or_eof()? {
            match tag {
                13 => {
                    self.key = is.read_fixed32()?;
                },
                16 => {
                    self.command = is.read_enum_or_unknown()?;
                },
                24 => {
                    self.device_id = is.read_uint32()?;
                },
                tag => {
                    ::protobuf::rt::read_unknown_or_skip_group(tag, is, self.special_fields.mut_unknown_fields())?;
                },
            };
        }
        ::std::result::Result::Ok(())
    }

    // Compute sizes of nested messages
    #[allow(unused_variables)]
    fn compute_size(&self) -> u64 {
        let mut my_size = 0;
        if self.key != 0 {
            my_size += 1 + 4;
        }
        if self.command != ::protobuf::EnumOrUnknown::new(UpdateCommand::UPDATE_COMMAND_NONE) {
            my_size += ::protobuf::rt::int32_size(2, self.command.value());
        }
        if self.device_id != 0 {
            my_size += ::protobuf::rt::uint32_size(3, self.device_id);
        }
        my_size += ::protobuf::rt::unknown_fields_size(self.special_fields.unknown_fields());
        self.special_fields.cached_size().set(my_size as u32);
        my_size
    }

    fn write_to_with_cached_sizes(&self, os: &mut ::protobuf::CodedOutputStream<'_>) -> ::protobuf::Result<()> {
        if self.key != 0 {
            os.write_fixed32(1, self.key)?;
        }
        if self.command != ::protobuf::EnumOrUnknown::new(UpdateCommand::UPDATE_COMMAND_NONE) {
            os.write_enum(2, ::protobuf::EnumOrUnknown::value(&self.command))?;
        }
        if self.device_id != 0 {
            os.write_uint32(3, self.device_id)?;
        }
        os.write_unknown_fields(self.special_fields.unknown_fields())?;
        ::std::result::Result::Ok(())
    }

    fn special_fields(&self) -> &::protobuf::SpecialFields {
        &self.special_fields
    }

    fn mut_special_fields(&mut self) -> &mut ::protobuf::SpecialFields {
        &mut self.special_fields
    }

    fn new() -> UpdateCommandRequest {
        UpdateCommandRequest::new()
    }

    fn clear(&mut self) {
        self.key = 0;
        self.command = ::protobuf::EnumOrUnknown::new(UpdateCommand::UPDATE_COMMAND_NONE);
        self.device_id = 0;
        self.special_fields.clear();
    }

    fn default_instance() -> &'static UpdateCommandRequest {
        static instance: UpdateCommandRequest = UpdateCommandRequest {
            key: 0,
            command: ::protobuf::EnumOrUnknown::from_i32(0),
            device_id: 0,
            special_fields: ::protobuf::SpecialFields::new(),
        };
        &instance
    }
}

impl ::protobuf::MessageFull for UpdateCommandRequest {
    fn descriptor() -> ::protobuf::reflect::MessageDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::MessageDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().message_by_package_relative_name("UpdateCommandRequest").unwrap()).clone()
    }
}

impl ::std::fmt::Display for UpdateCommandRequest {
    fn fmt(&self, f: &mut ::std::fmt::Formatter<'_>) -> ::std::fmt::Result {
        ::protobuf::text_format::fmt(self, f)
    }
}

impl ::protobuf::reflect::ProtobufValue for UpdateCommandRequest {
    type RuntimeType = ::protobuf::reflect::rt::RuntimeTypeMessage<Self>;
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:EntityCategory)
pub enum EntityCategory {
    // @@protoc_insertion_point(enum_value:EntityCategory.ENTITY_CATEGORY_NONE)
    ENTITY_CATEGORY_NONE = 0,
    // @@protoc_insertion_point(enum_value:EntityCategory.ENTITY_CATEGORY_CONFIG)
    ENTITY_CATEGORY_CONFIG = 1,
    // @@protoc_insertion_point(enum_value:EntityCategory.ENTITY_CATEGORY_DIAGNOSTIC)
    ENTITY_CATEGORY_DIAGNOSTIC = 2,
}

impl ::protobuf::Enum for EntityCategory {
    const NAME: &'static str = "EntityCategory";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<EntityCategory> {
        match value {
            0 => ::std::option::Option::Some(EntityCategory::ENTITY_CATEGORY_NONE),
            1 => ::std::option::Option::Some(EntityCategory::ENTITY_CATEGORY_CONFIG),
            2 => ::std::option::Option::Some(EntityCategory::ENTITY_CATEGORY_DIAGNOSTIC),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<EntityCategory> {
        match str {
            "ENTITY_CATEGORY_NONE" => ::std::option::Option::Some(EntityCategory::ENTITY_CATEGORY_NONE),
            "ENTITY_CATEGORY_CONFIG" => ::std::option::Option::Some(EntityCategory::ENTITY_CATEGORY_CONFIG),
            "ENTITY_CATEGORY_DIAGNOSTIC" => ::std::option::Option::Some(EntityCategory::ENTITY_CATEGORY_DIAGNOSTIC),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [EntityCategory] = &[
        EntityCategory::ENTITY_CATEGORY_NONE,
        EntityCategory::ENTITY_CATEGORY_CONFIG,
        EntityCategory::ENTITY_CATEGORY_DIAGNOSTIC,
    ];
}

impl ::protobuf::EnumFull for EntityCategory {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("EntityCategory").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = *self as usize;
        Self::enum_descriptor().value_by_index(index)
    }
}

impl ::std::default::Default for EntityCategory {
    fn default() -> Self {
        EntityCategory::ENTITY_CATEGORY_NONE
    }
}

impl EntityCategory {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<EntityCategory>("EntityCategory")
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:LegacyCoverState)
pub enum LegacyCoverState {
    // @@protoc_insertion_point(enum_value:LegacyCoverState.LEGACY_COVER_STATE_OPEN)
    LEGACY_COVER_STATE_OPEN = 0,
    // @@protoc_insertion_point(enum_value:LegacyCoverState.LEGACY_COVER_STATE_CLOSED)
    LEGACY_COVER_STATE_CLOSED = 1,
}

impl ::protobuf::Enum for LegacyCoverState {
    const NAME: &'static str = "LegacyCoverState";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<LegacyCoverState> {
        match value {
            0 => ::std::option::Option::Some(LegacyCoverState::LEGACY_COVER_STATE_OPEN),
            1 => ::std::option::Option::Some(LegacyCoverState::LEGACY_COVER_STATE_CLOSED),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<LegacyCoverState> {
        match str {
            "LEGACY_COVER_STATE_OPEN" => ::std::option::Option::Some(LegacyCoverState::LEGACY_COVER_STATE_OPEN),
            "LEGACY_COVER_STATE_CLOSED" => ::std::option::Option::Some(LegacyCoverState::LEGACY_COVER_STATE_CLOSED),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [LegacyCoverState] = &[
        LegacyCoverState::LEGACY_COVER_STATE_OPEN,
        LegacyCoverState::LEGACY_COVER_STATE_CLOSED,
    ];
}

impl ::protobuf::EnumFull for LegacyCoverState {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("LegacyCoverState").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = *self as usize;
        Self::enum_descriptor().value_by_index(index)
    }
}

impl ::std::default::Default for LegacyCoverState {
    fn default() -> Self {
        LegacyCoverState::LEGACY_COVER_STATE_OPEN
    }
}

impl LegacyCoverState {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<LegacyCoverState>("LegacyCoverState")
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:CoverOperation)
pub enum CoverOperation {
    // @@protoc_insertion_point(enum_value:CoverOperation.COVER_OPERATION_IDLE)
    COVER_OPERATION_IDLE = 0,
    // @@protoc_insertion_point(enum_value:CoverOperation.COVER_OPERATION_IS_OPENING)
    COVER_OPERATION_IS_OPENING = 1,
    // @@protoc_insertion_point(enum_value:CoverOperation.COVER_OPERATION_IS_CLOSING)
    COVER_OPERATION_IS_CLOSING = 2,
}

impl ::protobuf::Enum for CoverOperation {
    const NAME: &'static str = "CoverOperation";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<CoverOperation> {
        match value {
            0 => ::std::option::Option::Some(CoverOperation::COVER_OPERATION_IDLE),
            1 => ::std::option::Option::Some(CoverOperation::COVER_OPERATION_IS_OPENING),
            2 => ::std::option::Option::Some(CoverOperation::COVER_OPERATION_IS_CLOSING),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<CoverOperation> {
        match str {
            "COVER_OPERATION_IDLE" => ::std::option::Option::Some(CoverOperation::COVER_OPERATION_IDLE),
            "COVER_OPERATION_IS_OPENING" => ::std::option::Option::Some(CoverOperation::COVER_OPERATION_IS_OPENING),
            "COVER_OPERATION_IS_CLOSING" => ::std::option::Option::Some(CoverOperation::COVER_OPERATION_IS_CLOSING),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [CoverOperation] = &[
        CoverOperation::COVER_OPERATION_IDLE,
        CoverOperation::COVER_OPERATION_IS_OPENING,
        CoverOperation::COVER_OPERATION_IS_CLOSING,
    ];
}

impl ::protobuf::EnumFull for CoverOperation {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("CoverOperation").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = *self as usize;
        Self::enum_descriptor().value_by_index(index)
    }
}

impl ::std::default::Default for CoverOperation {
    fn default() -> Self {
        CoverOperation::COVER_OPERATION_IDLE
    }
}

impl CoverOperation {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<CoverOperation>("CoverOperation")
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:LegacyCoverCommand)
pub enum LegacyCoverCommand {
    // @@protoc_insertion_point(enum_value:LegacyCoverCommand.LEGACY_COVER_COMMAND_OPEN)
    LEGACY_COVER_COMMAND_OPEN = 0,
    // @@protoc_insertion_point(enum_value:LegacyCoverCommand.LEGACY_COVER_COMMAND_CLOSE)
    LEGACY_COVER_COMMAND_CLOSE = 1,
    // @@protoc_insertion_point(enum_value:LegacyCoverCommand.LEGACY_COVER_COMMAND_STOP)
    LEGACY_COVER_COMMAND_STOP = 2,
}

impl ::protobuf::Enum for LegacyCoverCommand {
    const NAME: &'static str = "LegacyCoverCommand";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<LegacyCoverCommand> {
        match value {
            0 => ::std::option::Option::Some(LegacyCoverCommand::LEGACY_COVER_COMMAND_OPEN),
            1 => ::std::option::Option::Some(LegacyCoverCommand::LEGACY_COVER_COMMAND_CLOSE),
            2 => ::std::option::Option::Some(LegacyCoverCommand::LEGACY_COVER_COMMAND_STOP),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<LegacyCoverCommand> {
        match str {
            "LEGACY_COVER_COMMAND_OPEN" => ::std::option::Option::Some(LegacyCoverCommand::LEGACY_COVER_COMMAND_OPEN),
            "LEGACY_COVER_COMMAND_CLOSE" => ::std::option::Option::Some(LegacyCoverCommand::LEGACY_COVER_COMMAND_CLOSE),
            "LEGACY_COVER_COMMAND_STOP" => ::std::option::Option::Some(LegacyCoverCommand::LEGACY_COVER_COMMAND_STOP),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [LegacyCoverCommand] = &[
        LegacyCoverCommand::LEGACY_COVER_COMMAND_OPEN,
        LegacyCoverCommand::LEGACY_COVER_COMMAND_CLOSE,
        LegacyCoverCommand::LEGACY_COVER_COMMAND_STOP,
    ];
}

impl ::protobuf::EnumFull for LegacyCoverCommand {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("LegacyCoverCommand").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = *self as usize;
        Self::enum_descriptor().value_by_index(index)
    }
}

impl ::std::default::Default for LegacyCoverCommand {
    fn default() -> Self {
        LegacyCoverCommand::LEGACY_COVER_COMMAND_OPEN
    }
}

impl LegacyCoverCommand {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<LegacyCoverCommand>("LegacyCoverCommand")
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:FanSpeed)
pub enum FanSpeed {
    // @@protoc_insertion_point(enum_value:FanSpeed.FAN_SPEED_LOW)
    FAN_SPEED_LOW = 0,
    // @@protoc_insertion_point(enum_value:FanSpeed.FAN_SPEED_MEDIUM)
    FAN_SPEED_MEDIUM = 1,
    // @@protoc_insertion_point(enum_value:FanSpeed.FAN_SPEED_HIGH)
    FAN_SPEED_HIGH = 2,
}

impl ::protobuf::Enum for FanSpeed {
    const NAME: &'static str = "FanSpeed";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<FanSpeed> {
        match value {
            0 => ::std::option::Option::Some(FanSpeed::FAN_SPEED_LOW),
            1 => ::std::option::Option::Some(FanSpeed::FAN_SPEED_MEDIUM),
            2 => ::std::option::Option::Some(FanSpeed::FAN_SPEED_HIGH),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<FanSpeed> {
        match str {
            "FAN_SPEED_LOW" => ::std::option::Option::Some(FanSpeed::FAN_SPEED_LOW),
            "FAN_SPEED_MEDIUM" => ::std::option::Option::Some(FanSpeed::FAN_SPEED_MEDIUM),
            "FAN_SPEED_HIGH" => ::std::option::Option::Some(FanSpeed::FAN_SPEED_HIGH),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [FanSpeed] = &[
        FanSpeed::FAN_SPEED_LOW,
        FanSpeed::FAN_SPEED_MEDIUM,
        FanSpeed::FAN_SPEED_HIGH,
    ];
}

impl ::protobuf::EnumFull for FanSpeed {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("FanSpeed").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = *self as usize;
        Self::enum_descriptor().value_by_index(index)
    }
}

impl ::std::default::Default for FanSpeed {
    fn default() -> Self {
        FanSpeed::FAN_SPEED_LOW
    }
}

impl FanSpeed {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<FanSpeed>("FanSpeed")
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:FanDirection)
pub enum FanDirection {
    // @@protoc_insertion_point(enum_value:FanDirection.FAN_DIRECTION_FORWARD)
    FAN_DIRECTION_FORWARD = 0,
    // @@protoc_insertion_point(enum_value:FanDirection.FAN_DIRECTION_REVERSE)
    FAN_DIRECTION_REVERSE = 1,
}

impl ::protobuf::Enum for FanDirection {
    const NAME: &'static str = "FanDirection";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<FanDirection> {
        match value {
            0 => ::std::option::Option::Some(FanDirection::FAN_DIRECTION_FORWARD),
            1 => ::std::option::Option::Some(FanDirection::FAN_DIRECTION_REVERSE),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<FanDirection> {
        match str {
            "FAN_DIRECTION_FORWARD" => ::std::option::Option::Some(FanDirection::FAN_DIRECTION_FORWARD),
            "FAN_DIRECTION_REVERSE" => ::std::option::Option::Some(FanDirection::FAN_DIRECTION_REVERSE),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [FanDirection] = &[
        FanDirection::FAN_DIRECTION_FORWARD,
        FanDirection::FAN_DIRECTION_REVERSE,
    ];
}

impl ::protobuf::EnumFull for FanDirection {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("FanDirection").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = *self as usize;
        Self::enum_descriptor().value_by_index(index)
    }
}

impl ::std::default::Default for FanDirection {
    fn default() -> Self {
        FanDirection::FAN_DIRECTION_FORWARD
    }
}

impl FanDirection {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<FanDirection>("FanDirection")
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:ColorMode)
pub enum ColorMode {
    // @@protoc_insertion_point(enum_value:ColorMode.COLOR_MODE_UNKNOWN)
    COLOR_MODE_UNKNOWN = 0,
    // @@protoc_insertion_point(enum_value:ColorMode.COLOR_MODE_ON_OFF)
    COLOR_MODE_ON_OFF = 1,
    // @@protoc_insertion_point(enum_value:ColorMode.COLOR_MODE_LEGACY_BRIGHTNESS)
    COLOR_MODE_LEGACY_BRIGHTNESS = 2,
    // @@protoc_insertion_point(enum_value:ColorMode.COLOR_MODE_BRIGHTNESS)
    COLOR_MODE_BRIGHTNESS = 3,
    // @@protoc_insertion_point(enum_value:ColorMode.COLOR_MODE_WHITE)
    COLOR_MODE_WHITE = 7,
    // @@protoc_insertion_point(enum_value:ColorMode.COLOR_MODE_COLOR_TEMPERATURE)
    COLOR_MODE_COLOR_TEMPERATURE = 11,
    // @@protoc_insertion_point(enum_value:ColorMode.COLOR_MODE_COLD_WARM_WHITE)
    COLOR_MODE_COLD_WARM_WHITE = 19,
    // @@protoc_insertion_point(enum_value:ColorMode.COLOR_MODE_RGB)
    COLOR_MODE_RGB = 35,
    // @@protoc_insertion_point(enum_value:ColorMode.COLOR_MODE_RGB_WHITE)
    COLOR_MODE_RGB_WHITE = 39,
    // @@protoc_insertion_point(enum_value:ColorMode.COLOR_MODE_RGB_COLOR_TEMPERATURE)
    COLOR_MODE_RGB_COLOR_TEMPERATURE = 47,
    // @@protoc_insertion_point(enum_value:ColorMode.COLOR_MODE_RGB_COLD_WARM_WHITE)
    COLOR_MODE_RGB_COLD_WARM_WHITE = 51,
}

impl ::protobuf::Enum for ColorMode {
    const NAME: &'static str = "ColorMode";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<ColorMode> {
        match value {
            0 => ::std::option::Option::Some(ColorMode::COLOR_MODE_UNKNOWN),
            1 => ::std::option::Option::Some(ColorMode::COLOR_MODE_ON_OFF),
            2 => ::std::option::Option::Some(ColorMode::COLOR_MODE_LEGACY_BRIGHTNESS),
            3 => ::std::option::Option::Some(ColorMode::COLOR_MODE_BRIGHTNESS),
            7 => ::std::option::Option::Some(ColorMode::COLOR_MODE_WHITE),
            11 => ::std::option::Option::Some(ColorMode::COLOR_MODE_COLOR_TEMPERATURE),
            19 => ::std::option::Option::Some(ColorMode::COLOR_MODE_COLD_WARM_WHITE),
            35 => ::std::option::Option::Some(ColorMode::COLOR_MODE_RGB),
            39 => ::std::option::Option::Some(ColorMode::COLOR_MODE_RGB_WHITE),
            47 => ::std::option::Option::Some(ColorMode::COLOR_MODE_RGB_COLOR_TEMPERATURE),
            51 => ::std::option::Option::Some(ColorMode::COLOR_MODE_RGB_COLD_WARM_WHITE),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<ColorMode> {
        match str {
            "COLOR_MODE_UNKNOWN" => ::std::option::Option::Some(ColorMode::COLOR_MODE_UNKNOWN),
            "COLOR_MODE_ON_OFF" => ::std::option::Option::Some(ColorMode::COLOR_MODE_ON_OFF),
            "COLOR_MODE_LEGACY_BRIGHTNESS" => ::std::option::Option::Some(ColorMode::COLOR_MODE_LEGACY_BRIGHTNESS),
            "COLOR_MODE_BRIGHTNESS" => ::std::option::Option::Some(ColorMode::COLOR_MODE_BRIGHTNESS),
            "COLOR_MODE_WHITE" => ::std::option::Option::Some(ColorMode::COLOR_MODE_WHITE),
            "COLOR_MODE_COLOR_TEMPERATURE" => ::std::option::Option::Some(ColorMode::COLOR_MODE_COLOR_TEMPERATURE),
            "COLOR_MODE_COLD_WARM_WHITE" => ::std::option::Option::Some(ColorMode::COLOR_MODE_COLD_WARM_WHITE),
            "COLOR_MODE_RGB" => ::std::option::Option::Some(ColorMode::COLOR_MODE_RGB),
            "COLOR_MODE_RGB_WHITE" => ::std::option::Option::Some(ColorMode::COLOR_MODE_RGB_WHITE),
            "COLOR_MODE_RGB_COLOR_TEMPERATURE" => ::std::option::Option::Some(ColorMode::COLOR_MODE_RGB_COLOR_TEMPERATURE),
            "COLOR_MODE_RGB_COLD_WARM_WHITE" => ::std::option::Option::Some(ColorMode::COLOR_MODE_RGB_COLD_WARM_WHITE),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [ColorMode] = &[
        ColorMode::COLOR_MODE_UNKNOWN,
        ColorMode::COLOR_MODE_ON_OFF,
        ColorMode::COLOR_MODE_LEGACY_BRIGHTNESS,
        ColorMode::COLOR_MODE_BRIGHTNESS,
        ColorMode::COLOR_MODE_WHITE,
        ColorMode::COLOR_MODE_COLOR_TEMPERATURE,
        ColorMode::COLOR_MODE_COLD_WARM_WHITE,
        ColorMode::COLOR_MODE_RGB,
        ColorMode::COLOR_MODE_RGB_WHITE,
        ColorMode::COLOR_MODE_RGB_COLOR_TEMPERATURE,
        ColorMode::COLOR_MODE_RGB_COLD_WARM_WHITE,
    ];
}

impl ::protobuf::EnumFull for ColorMode {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("ColorMode").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = match self {
            ColorMode::COLOR_MODE_UNKNOWN => 0,
            ColorMode::COLOR_MODE_ON_OFF => 1,
            ColorMode::COLOR_MODE_LEGACY_BRIGHTNESS => 2,
            ColorMode::COLOR_MODE_BRIGHTNESS => 3,
            ColorMode::COLOR_MODE_WHITE => 4,
            ColorMode::COLOR_MODE_COLOR_TEMPERATURE => 5,
            ColorMode::COLOR_MODE_COLD_WARM_WHITE => 6,
            ColorMode::COLOR_MODE_RGB => 7,
            ColorMode::COLOR_MODE_RGB_WHITE => 8,
            ColorMode::COLOR_MODE_RGB_COLOR_TEMPERATURE => 9,
            ColorMode::COLOR_MODE_RGB_COLD_WARM_WHITE => 10,
        };
        Self::enum_descriptor().value_by_index(index)
    }
}

impl ::std::default::Default for ColorMode {
    fn default() -> Self {
        ColorMode::COLOR_MODE_UNKNOWN
    }
}

impl ColorMode {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<ColorMode>("ColorMode")
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:SensorStateClass)
pub enum SensorStateClass {
    // @@protoc_insertion_point(enum_value:SensorStateClass.STATE_CLASS_NONE)
    STATE_CLASS_NONE = 0,
    // @@protoc_insertion_point(enum_value:SensorStateClass.STATE_CLASS_MEASUREMENT)
    STATE_CLASS_MEASUREMENT = 1,
    // @@protoc_insertion_point(enum_value:SensorStateClass.STATE_CLASS_TOTAL_INCREASING)
    STATE_CLASS_TOTAL_INCREASING = 2,
    // @@protoc_insertion_point(enum_value:SensorStateClass.STATE_CLASS_TOTAL)
    STATE_CLASS_TOTAL = 3,
}

impl ::protobuf::Enum for SensorStateClass {
    const NAME: &'static str = "SensorStateClass";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<SensorStateClass> {
        match value {
            0 => ::std::option::Option::Some(SensorStateClass::STATE_CLASS_NONE),
            1 => ::std::option::Option::Some(SensorStateClass::STATE_CLASS_MEASUREMENT),
            2 => ::std::option::Option::Some(SensorStateClass::STATE_CLASS_TOTAL_INCREASING),
            3 => ::std::option::Option::Some(SensorStateClass::STATE_CLASS_TOTAL),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<SensorStateClass> {
        match str {
            "STATE_CLASS_NONE" => ::std::option::Option::Some(SensorStateClass::STATE_CLASS_NONE),
            "STATE_CLASS_MEASUREMENT" => ::std::option::Option::Some(SensorStateClass::STATE_CLASS_MEASUREMENT),
            "STATE_CLASS_TOTAL_INCREASING" => ::std::option::Option::Some(SensorStateClass::STATE_CLASS_TOTAL_INCREASING),
            "STATE_CLASS_TOTAL" => ::std::option::Option::Some(SensorStateClass::STATE_CLASS_TOTAL),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [SensorStateClass] = &[
        SensorStateClass::STATE_CLASS_NONE,
        SensorStateClass::STATE_CLASS_MEASUREMENT,
        SensorStateClass::STATE_CLASS_TOTAL_INCREASING,
        SensorStateClass::STATE_CLASS_TOTAL,
    ];
}

impl ::protobuf::EnumFull for SensorStateClass {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("SensorStateClass").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = *self as usize;
        Self::enum_descriptor().value_by_index(index)
    }
}

impl ::std::default::Default for SensorStateClass {
    fn default() -> Self {
        SensorStateClass::STATE_CLASS_NONE
    }
}

impl SensorStateClass {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<SensorStateClass>("SensorStateClass")
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:SensorLastResetType)
pub enum SensorLastResetType {
    // @@protoc_insertion_point(enum_value:SensorLastResetType.LAST_RESET_NONE)
    LAST_RESET_NONE = 0,
    // @@protoc_insertion_point(enum_value:SensorLastResetType.LAST_RESET_NEVER)
    LAST_RESET_NEVER = 1,
    // @@protoc_insertion_point(enum_value:SensorLastResetType.LAST_RESET_AUTO)
    LAST_RESET_AUTO = 2,
}

impl ::protobuf::Enum for SensorLastResetType {
    const NAME: &'static str = "SensorLastResetType";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<SensorLastResetType> {
        match value {
            0 => ::std::option::Option::Some(SensorLastResetType::LAST_RESET_NONE),
            1 => ::std::option::Option::Some(SensorLastResetType::LAST_RESET_NEVER),
            2 => ::std::option::Option::Some(SensorLastResetType::LAST_RESET_AUTO),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<SensorLastResetType> {
        match str {
            "LAST_RESET_NONE" => ::std::option::Option::Some(SensorLastResetType::LAST_RESET_NONE),
            "LAST_RESET_NEVER" => ::std::option::Option::Some(SensorLastResetType::LAST_RESET_NEVER),
            "LAST_RESET_AUTO" => ::std::option::Option::Some(SensorLastResetType::LAST_RESET_AUTO),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [SensorLastResetType] = &[
        SensorLastResetType::LAST_RESET_NONE,
        SensorLastResetType::LAST_RESET_NEVER,
        SensorLastResetType::LAST_RESET_AUTO,
    ];
}

impl ::protobuf::EnumFull for SensorLastResetType {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("SensorLastResetType").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = *self as usize;
        Self::enum_descriptor().value_by_index(index)
    }
}

impl ::std::default::Default for SensorLastResetType {
    fn default() -> Self {
        SensorLastResetType::LAST_RESET_NONE
    }
}

impl SensorLastResetType {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<SensorLastResetType>("SensorLastResetType")
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:LogLevel)
pub enum LogLevel {
    // @@protoc_insertion_point(enum_value:LogLevel.LOG_LEVEL_NONE)
    LOG_LEVEL_NONE = 0,
    // @@protoc_insertion_point(enum_value:LogLevel.LOG_LEVEL_ERROR)
    LOG_LEVEL_ERROR = 1,
    // @@protoc_insertion_point(enum_value:LogLevel.LOG_LEVEL_WARN)
    LOG_LEVEL_WARN = 2,
    // @@protoc_insertion_point(enum_value:LogLevel.LOG_LEVEL_INFO)
    LOG_LEVEL_INFO = 3,
    // @@protoc_insertion_point(enum_value:LogLevel.LOG_LEVEL_CONFIG)
    LOG_LEVEL_CONFIG = 4,
    // @@protoc_insertion_point(enum_value:LogLevel.LOG_LEVEL_DEBUG)
    LOG_LEVEL_DEBUG = 5,
    // @@protoc_insertion_point(enum_value:LogLevel.LOG_LEVEL_VERBOSE)
    LOG_LEVEL_VERBOSE = 6,
    // @@protoc_insertion_point(enum_value:LogLevel.LOG_LEVEL_VERY_VERBOSE)
    LOG_LEVEL_VERY_VERBOSE = 7,
}

impl ::protobuf::Enum for LogLevel {
    const NAME: &'static str = "LogLevel";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<LogLevel> {
        match value {
            0 => ::std::option::Option::Some(LogLevel::LOG_LEVEL_NONE),
            1 => ::std::option::Option::Some(LogLevel::LOG_LEVEL_ERROR),
            2 => ::std::option::Option::Some(LogLevel::LOG_LEVEL_WARN),
            3 => ::std::option::Option::Some(LogLevel::LOG_LEVEL_INFO),
            4 => ::std::option::Option::Some(LogLevel::LOG_LEVEL_CONFIG),
            5 => ::std::option::Option::Some(LogLevel::LOG_LEVEL_DEBUG),
            6 => ::std::option::Option::Some(LogLevel::LOG_LEVEL_VERBOSE),
            7 => ::std::option::Option::Some(LogLevel::LOG_LEVEL_VERY_VERBOSE),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<LogLevel> {
        match str {
            "LOG_LEVEL_NONE" => ::std::option::Option::Some(LogLevel::LOG_LEVEL_NONE),
            "LOG_LEVEL_ERROR" => ::std::option::Option::Some(LogLevel::LOG_LEVEL_ERROR),
            "LOG_LEVEL_WARN" => ::std::option::Option::Some(LogLevel::LOG_LEVEL_WARN),
            "LOG_LEVEL_INFO" => ::std::option::Option::Some(LogLevel::LOG_LEVEL_INFO),
            "LOG_LEVEL_CONFIG" => ::std::option::Option::Some(LogLevel::LOG_LEVEL_CONFIG),
            "LOG_LEVEL_DEBUG" => ::std::option::Option::Some(LogLevel::LOG_LEVEL_DEBUG),
            "LOG_LEVEL_VERBOSE" => ::std::option::Option::Some(LogLevel::LOG_LEVEL_VERBOSE),
            "LOG_LEVEL_VERY_VERBOSE" => ::std::option::Option::Some(LogLevel::LOG_LEVEL_VERY_VERBOSE),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [LogLevel] = &[
        LogLevel::LOG_LEVEL_NONE,
        LogLevel::LOG_LEVEL_ERROR,
        LogLevel::LOG_LEVEL_WARN,
        LogLevel::LOG_LEVEL_INFO,
        LogLevel::LOG_LEVEL_CONFIG,
        LogLevel::LOG_LEVEL_DEBUG,
        LogLevel::LOG_LEVEL_VERBOSE,
        LogLevel::LOG_LEVEL_VERY_VERBOSE,
    ];
}

impl ::protobuf::EnumFull for LogLevel {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("LogLevel").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = *self as usize;
        Self::enum_descriptor().value_by_index(index)
    }
}

impl ::std::default::Default for LogLevel {
    fn default() -> Self {
        LogLevel::LOG_LEVEL_NONE
    }
}

impl LogLevel {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<LogLevel>("LogLevel")
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:ServiceArgType)
pub enum ServiceArgType {
    // @@protoc_insertion_point(enum_value:ServiceArgType.SERVICE_ARG_TYPE_BOOL)
    SERVICE_ARG_TYPE_BOOL = 0,
    // @@protoc_insertion_point(enum_value:ServiceArgType.SERVICE_ARG_TYPE_INT)
    SERVICE_ARG_TYPE_INT = 1,
    // @@protoc_insertion_point(enum_value:ServiceArgType.SERVICE_ARG_TYPE_FLOAT)
    SERVICE_ARG_TYPE_FLOAT = 2,
    // @@protoc_insertion_point(enum_value:ServiceArgType.SERVICE_ARG_TYPE_STRING)
    SERVICE_ARG_TYPE_STRING = 3,
    // @@protoc_insertion_point(enum_value:ServiceArgType.SERVICE_ARG_TYPE_BOOL_ARRAY)
    SERVICE_ARG_TYPE_BOOL_ARRAY = 4,
    // @@protoc_insertion_point(enum_value:ServiceArgType.SERVICE_ARG_TYPE_INT_ARRAY)
    SERVICE_ARG_TYPE_INT_ARRAY = 5,
    // @@protoc_insertion_point(enum_value:ServiceArgType.SERVICE_ARG_TYPE_FLOAT_ARRAY)
    SERVICE_ARG_TYPE_FLOAT_ARRAY = 6,
    // @@protoc_insertion_point(enum_value:ServiceArgType.SERVICE_ARG_TYPE_STRING_ARRAY)
    SERVICE_ARG_TYPE_STRING_ARRAY = 7,
}

impl ::protobuf::Enum for ServiceArgType {
    const NAME: &'static str = "ServiceArgType";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<ServiceArgType> {
        match value {
            0 => ::std::option::Option::Some(ServiceArgType::SERVICE_ARG_TYPE_BOOL),
            1 => ::std::option::Option::Some(ServiceArgType::SERVICE_ARG_TYPE_INT),
            2 => ::std::option::Option::Some(ServiceArgType::SERVICE_ARG_TYPE_FLOAT),
            3 => ::std::option::Option::Some(ServiceArgType::SERVICE_ARG_TYPE_STRING),
            4 => ::std::option::Option::Some(ServiceArgType::SERVICE_ARG_TYPE_BOOL_ARRAY),
            5 => ::std::option::Option::Some(ServiceArgType::SERVICE_ARG_TYPE_INT_ARRAY),
            6 => ::std::option::Option::Some(ServiceArgType::SERVICE_ARG_TYPE_FLOAT_ARRAY),
            7 => ::std::option::Option::Some(ServiceArgType::SERVICE_ARG_TYPE_STRING_ARRAY),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<ServiceArgType> {
        match str {
            "SERVICE_ARG_TYPE_BOOL" => ::std::option::Option::Some(ServiceArgType::SERVICE_ARG_TYPE_BOOL),
            "SERVICE_ARG_TYPE_INT" => ::std::option::Option::Some(ServiceArgType::SERVICE_ARG_TYPE_INT),
            "SERVICE_ARG_TYPE_FLOAT" => ::std::option::Option::Some(ServiceArgType::SERVICE_ARG_TYPE_FLOAT),
            "SERVICE_ARG_TYPE_STRING" => ::std::option::Option::Some(ServiceArgType::SERVICE_ARG_TYPE_STRING),
            "SERVICE_ARG_TYPE_BOOL_ARRAY" => ::std::option::Option::Some(ServiceArgType::SERVICE_ARG_TYPE_BOOL_ARRAY),
            "SERVICE_ARG_TYPE_INT_ARRAY" => ::std::option::Option::Some(ServiceArgType::SERVICE_ARG_TYPE_INT_ARRAY),
            "SERVICE_ARG_TYPE_FLOAT_ARRAY" => ::std::option::Option::Some(ServiceArgType::SERVICE_ARG_TYPE_FLOAT_ARRAY),
            "SERVICE_ARG_TYPE_STRING_ARRAY" => ::std::option::Option::Some(ServiceArgType::SERVICE_ARG_TYPE_STRING_ARRAY),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [ServiceArgType] = &[
        ServiceArgType::SERVICE_ARG_TYPE_BOOL,
        ServiceArgType::SERVICE_ARG_TYPE_INT,
        ServiceArgType::SERVICE_ARG_TYPE_FLOAT,
        ServiceArgType::SERVICE_ARG_TYPE_STRING,
        ServiceArgType::SERVICE_ARG_TYPE_BOOL_ARRAY,
        ServiceArgType::SERVICE_ARG_TYPE_INT_ARRAY,
        ServiceArgType::SERVICE_ARG_TYPE_FLOAT_ARRAY,
        ServiceArgType::SERVICE_ARG_TYPE_STRING_ARRAY,
    ];
}

impl ::protobuf::EnumFull for ServiceArgType {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("ServiceArgType").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = *self as usize;
        Self::enum_descriptor().value_by_index(index)
    }
}

impl ::std::default::Default for ServiceArgType {
    fn default() -> Self {
        ServiceArgType::SERVICE_ARG_TYPE_BOOL
    }
}

impl ServiceArgType {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<ServiceArgType>("ServiceArgType")
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:ClimateMode)
pub enum ClimateMode {
    // @@protoc_insertion_point(enum_value:ClimateMode.CLIMATE_MODE_OFF)
    CLIMATE_MODE_OFF = 0,
    // @@protoc_insertion_point(enum_value:ClimateMode.CLIMATE_MODE_HEAT_COOL)
    CLIMATE_MODE_HEAT_COOL = 1,
    // @@protoc_insertion_point(enum_value:ClimateMode.CLIMATE_MODE_COOL)
    CLIMATE_MODE_COOL = 2,
    // @@protoc_insertion_point(enum_value:ClimateMode.CLIMATE_MODE_HEAT)
    CLIMATE_MODE_HEAT = 3,
    // @@protoc_insertion_point(enum_value:ClimateMode.CLIMATE_MODE_FAN_ONLY)
    CLIMATE_MODE_FAN_ONLY = 4,
    // @@protoc_insertion_point(enum_value:ClimateMode.CLIMATE_MODE_DRY)
    CLIMATE_MODE_DRY = 5,
    // @@protoc_insertion_point(enum_value:ClimateMode.CLIMATE_MODE_AUTO)
    CLIMATE_MODE_AUTO = 6,
}

impl ::protobuf::Enum for ClimateMode {
    const NAME: &'static str = "ClimateMode";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<ClimateMode> {
        match value {
            0 => ::std::option::Option::Some(ClimateMode::CLIMATE_MODE_OFF),
            1 => ::std::option::Option::Some(ClimateMode::CLIMATE_MODE_HEAT_COOL),
            2 => ::std::option::Option::Some(ClimateMode::CLIMATE_MODE_COOL),
            3 => ::std::option::Option::Some(ClimateMode::CLIMATE_MODE_HEAT),
            4 => ::std::option::Option::Some(ClimateMode::CLIMATE_MODE_FAN_ONLY),
            5 => ::std::option::Option::Some(ClimateMode::CLIMATE_MODE_DRY),
            6 => ::std::option::Option::Some(ClimateMode::CLIMATE_MODE_AUTO),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<ClimateMode> {
        match str {
            "CLIMATE_MODE_OFF" => ::std::option::Option::Some(ClimateMode::CLIMATE_MODE_OFF),
            "CLIMATE_MODE_HEAT_COOL" => ::std::option::Option::Some(ClimateMode::CLIMATE_MODE_HEAT_COOL),
            "CLIMATE_MODE_COOL" => ::std::option::Option::Some(ClimateMode::CLIMATE_MODE_COOL),
            "CLIMATE_MODE_HEAT" => ::std::option::Option::Some(ClimateMode::CLIMATE_MODE_HEAT),
            "CLIMATE_MODE_FAN_ONLY" => ::std::option::Option::Some(ClimateMode::CLIMATE_MODE_FAN_ONLY),
            "CLIMATE_MODE_DRY" => ::std::option::Option::Some(ClimateMode::CLIMATE_MODE_DRY),
            "CLIMATE_MODE_AUTO" => ::std::option::Option::Some(ClimateMode::CLIMATE_MODE_AUTO),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [ClimateMode] = &[
        ClimateMode::CLIMATE_MODE_OFF,
        ClimateMode::CLIMATE_MODE_HEAT_COOL,
        ClimateMode::CLIMATE_MODE_COOL,
        ClimateMode::CLIMATE_MODE_HEAT,
        ClimateMode::CLIMATE_MODE_FAN_ONLY,
        ClimateMode::CLIMATE_MODE_DRY,
        ClimateMode::CLIMATE_MODE_AUTO,
    ];
}

impl ::protobuf::EnumFull for ClimateMode {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("ClimateMode").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = *self as usize;
        Self::enum_descriptor().value_by_index(index)
    }
}

impl ::std::default::Default for ClimateMode {
    fn default() -> Self {
        ClimateMode::CLIMATE_MODE_OFF
    }
}

impl ClimateMode {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<ClimateMode>("ClimateMode")
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:ClimateFanMode)
pub enum ClimateFanMode {
    // @@protoc_insertion_point(enum_value:ClimateFanMode.CLIMATE_FAN_ON)
    CLIMATE_FAN_ON = 0,
    // @@protoc_insertion_point(enum_value:ClimateFanMode.CLIMATE_FAN_OFF)
    CLIMATE_FAN_OFF = 1,
    // @@protoc_insertion_point(enum_value:ClimateFanMode.CLIMATE_FAN_AUTO)
    CLIMATE_FAN_AUTO = 2,
    // @@protoc_insertion_point(enum_value:ClimateFanMode.CLIMATE_FAN_LOW)
    CLIMATE_FAN_LOW = 3,
    // @@protoc_insertion_point(enum_value:ClimateFanMode.CLIMATE_FAN_MEDIUM)
    CLIMATE_FAN_MEDIUM = 4,
    // @@protoc_insertion_point(enum_value:ClimateFanMode.CLIMATE_FAN_HIGH)
    CLIMATE_FAN_HIGH = 5,
    // @@protoc_insertion_point(enum_value:ClimateFanMode.CLIMATE_FAN_MIDDLE)
    CLIMATE_FAN_MIDDLE = 6,
    // @@protoc_insertion_point(enum_value:ClimateFanMode.CLIMATE_FAN_FOCUS)
    CLIMATE_FAN_FOCUS = 7,
    // @@protoc_insertion_point(enum_value:ClimateFanMode.CLIMATE_FAN_DIFFUSE)
    CLIMATE_FAN_DIFFUSE = 8,
    // @@protoc_insertion_point(enum_value:ClimateFanMode.CLIMATE_FAN_QUIET)
    CLIMATE_FAN_QUIET = 9,
}

impl ::protobuf::Enum for ClimateFanMode {
    const NAME: &'static str = "ClimateFanMode";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<ClimateFanMode> {
        match value {
            0 => ::std::option::Option::Some(ClimateFanMode::CLIMATE_FAN_ON),
            1 => ::std::option::Option::Some(ClimateFanMode::CLIMATE_FAN_OFF),
            2 => ::std::option::Option::Some(ClimateFanMode::CLIMATE_FAN_AUTO),
            3 => ::std::option::Option::Some(ClimateFanMode::CLIMATE_FAN_LOW),
            4 => ::std::option::Option::Some(ClimateFanMode::CLIMATE_FAN_MEDIUM),
            5 => ::std::option::Option::Some(ClimateFanMode::CLIMATE_FAN_HIGH),
            6 => ::std::option::Option::Some(ClimateFanMode::CLIMATE_FAN_MIDDLE),
            7 => ::std::option::Option::Some(ClimateFanMode::CLIMATE_FAN_FOCUS),
            8 => ::std::option::Option::Some(ClimateFanMode::CLIMATE_FAN_DIFFUSE),
            9 => ::std::option::Option::Some(ClimateFanMode::CLIMATE_FAN_QUIET),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<ClimateFanMode> {
        match str {
            "CLIMATE_FAN_ON" => ::std::option::Option::Some(ClimateFanMode::CLIMATE_FAN_ON),
            "CLIMATE_FAN_OFF" => ::std::option::Option::Some(ClimateFanMode::CLIMATE_FAN_OFF),
            "CLIMATE_FAN_AUTO" => ::std::option::Option::Some(ClimateFanMode::CLIMATE_FAN_AUTO),
            "CLIMATE_FAN_LOW" => ::std::option::Option::Some(ClimateFanMode::CLIMATE_FAN_LOW),
            "CLIMATE_FAN_MEDIUM" => ::std::option::Option::Some(ClimateFanMode::CLIMATE_FAN_MEDIUM),
            "CLIMATE_FAN_HIGH" => ::std::option::Option::Some(ClimateFanMode::CLIMATE_FAN_HIGH),
            "CLIMATE_FAN_MIDDLE" => ::std::option::Option::Some(ClimateFanMode::CLIMATE_FAN_MIDDLE),
            "CLIMATE_FAN_FOCUS" => ::std::option::Option::Some(ClimateFanMode::CLIMATE_FAN_FOCUS),
            "CLIMATE_FAN_DIFFUSE" => ::std::option::Option::Some(ClimateFanMode::CLIMATE_FAN_DIFFUSE),
            "CLIMATE_FAN_QUIET" => ::std::option::Option::Some(ClimateFanMode::CLIMATE_FAN_QUIET),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [ClimateFanMode] = &[
        ClimateFanMode::CLIMATE_FAN_ON,
        ClimateFanMode::CLIMATE_FAN_OFF,
        ClimateFanMode::CLIMATE_FAN_AUTO,
        ClimateFanMode::CLIMATE_FAN_LOW,
        ClimateFanMode::CLIMATE_FAN_MEDIUM,
        ClimateFanMode::CLIMATE_FAN_HIGH,
        ClimateFanMode::CLIMATE_FAN_MIDDLE,
        ClimateFanMode::CLIMATE_FAN_FOCUS,
        ClimateFanMode::CLIMATE_FAN_DIFFUSE,
        ClimateFanMode::CLIMATE_FAN_QUIET,
    ];
}

impl ::protobuf::EnumFull for ClimateFanMode {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("ClimateFanMode").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = *self as usize;
        Self::enum_descriptor().value_by_index(index)
    }
}

impl ::std::default::Default for ClimateFanMode {
    fn default() -> Self {
        ClimateFanMode::CLIMATE_FAN_ON
    }
}

impl ClimateFanMode {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<ClimateFanMode>("ClimateFanMode")
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:ClimateSwingMode)
pub enum ClimateSwingMode {
    // @@protoc_insertion_point(enum_value:ClimateSwingMode.CLIMATE_SWING_OFF)
    CLIMATE_SWING_OFF = 0,
    // @@protoc_insertion_point(enum_value:ClimateSwingMode.CLIMATE_SWING_BOTH)
    CLIMATE_SWING_BOTH = 1,
    // @@protoc_insertion_point(enum_value:ClimateSwingMode.CLIMATE_SWING_VERTICAL)
    CLIMATE_SWING_VERTICAL = 2,
    // @@protoc_insertion_point(enum_value:ClimateSwingMode.CLIMATE_SWING_HORIZONTAL)
    CLIMATE_SWING_HORIZONTAL = 3,
}

impl ::protobuf::Enum for ClimateSwingMode {
    const NAME: &'static str = "ClimateSwingMode";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<ClimateSwingMode> {
        match value {
            0 => ::std::option::Option::Some(ClimateSwingMode::CLIMATE_SWING_OFF),
            1 => ::std::option::Option::Some(ClimateSwingMode::CLIMATE_SWING_BOTH),
            2 => ::std::option::Option::Some(ClimateSwingMode::CLIMATE_SWING_VERTICAL),
            3 => ::std::option::Option::Some(ClimateSwingMode::CLIMATE_SWING_HORIZONTAL),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<ClimateSwingMode> {
        match str {
            "CLIMATE_SWING_OFF" => ::std::option::Option::Some(ClimateSwingMode::CLIMATE_SWING_OFF),
            "CLIMATE_SWING_BOTH" => ::std::option::Option::Some(ClimateSwingMode::CLIMATE_SWING_BOTH),
            "CLIMATE_SWING_VERTICAL" => ::std::option::Option::Some(ClimateSwingMode::CLIMATE_SWING_VERTICAL),
            "CLIMATE_SWING_HORIZONTAL" => ::std::option::Option::Some(ClimateSwingMode::CLIMATE_SWING_HORIZONTAL),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [ClimateSwingMode] = &[
        ClimateSwingMode::CLIMATE_SWING_OFF,
        ClimateSwingMode::CLIMATE_SWING_BOTH,
        ClimateSwingMode::CLIMATE_SWING_VERTICAL,
        ClimateSwingMode::CLIMATE_SWING_HORIZONTAL,
    ];
}

impl ::protobuf::EnumFull for ClimateSwingMode {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("ClimateSwingMode").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = *self as usize;
        Self::enum_descriptor().value_by_index(index)
    }
}

impl ::std::default::Default for ClimateSwingMode {
    fn default() -> Self {
        ClimateSwingMode::CLIMATE_SWING_OFF
    }
}

impl ClimateSwingMode {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<ClimateSwingMode>("ClimateSwingMode")
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:ClimateAction)
pub enum ClimateAction {
    // @@protoc_insertion_point(enum_value:ClimateAction.CLIMATE_ACTION_OFF)
    CLIMATE_ACTION_OFF = 0,
    // @@protoc_insertion_point(enum_value:ClimateAction.CLIMATE_ACTION_COOLING)
    CLIMATE_ACTION_COOLING = 2,
    // @@protoc_insertion_point(enum_value:ClimateAction.CLIMATE_ACTION_HEATING)
    CLIMATE_ACTION_HEATING = 3,
    // @@protoc_insertion_point(enum_value:ClimateAction.CLIMATE_ACTION_IDLE)
    CLIMATE_ACTION_IDLE = 4,
    // @@protoc_insertion_point(enum_value:ClimateAction.CLIMATE_ACTION_DRYING)
    CLIMATE_ACTION_DRYING = 5,
    // @@protoc_insertion_point(enum_value:ClimateAction.CLIMATE_ACTION_FAN)
    CLIMATE_ACTION_FAN = 6,
}

impl ::protobuf::Enum for ClimateAction {
    const NAME: &'static str = "ClimateAction";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<ClimateAction> {
        match value {
            0 => ::std::option::Option::Some(ClimateAction::CLIMATE_ACTION_OFF),
            2 => ::std::option::Option::Some(ClimateAction::CLIMATE_ACTION_COOLING),
            3 => ::std::option::Option::Some(ClimateAction::CLIMATE_ACTION_HEATING),
            4 => ::std::option::Option::Some(ClimateAction::CLIMATE_ACTION_IDLE),
            5 => ::std::option::Option::Some(ClimateAction::CLIMATE_ACTION_DRYING),
            6 => ::std::option::Option::Some(ClimateAction::CLIMATE_ACTION_FAN),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<ClimateAction> {
        match str {
            "CLIMATE_ACTION_OFF" => ::std::option::Option::Some(ClimateAction::CLIMATE_ACTION_OFF),
            "CLIMATE_ACTION_COOLING" => ::std::option::Option::Some(ClimateAction::CLIMATE_ACTION_COOLING),
            "CLIMATE_ACTION_HEATING" => ::std::option::Option::Some(ClimateAction::CLIMATE_ACTION_HEATING),
            "CLIMATE_ACTION_IDLE" => ::std::option::Option::Some(ClimateAction::CLIMATE_ACTION_IDLE),
            "CLIMATE_ACTION_DRYING" => ::std::option::Option::Some(ClimateAction::CLIMATE_ACTION_DRYING),
            "CLIMATE_ACTION_FAN" => ::std::option::Option::Some(ClimateAction::CLIMATE_ACTION_FAN),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [ClimateAction] = &[
        ClimateAction::CLIMATE_ACTION_OFF,
        ClimateAction::CLIMATE_ACTION_COOLING,
        ClimateAction::CLIMATE_ACTION_HEATING,
        ClimateAction::CLIMATE_ACTION_IDLE,
        ClimateAction::CLIMATE_ACTION_DRYING,
        ClimateAction::CLIMATE_ACTION_FAN,
    ];
}

impl ::protobuf::EnumFull for ClimateAction {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("ClimateAction").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = match self {
            ClimateAction::CLIMATE_ACTION_OFF => 0,
            ClimateAction::CLIMATE_ACTION_COOLING => 1,
            ClimateAction::CLIMATE_ACTION_HEATING => 2,
            ClimateAction::CLIMATE_ACTION_IDLE => 3,
            ClimateAction::CLIMATE_ACTION_DRYING => 4,
            ClimateAction::CLIMATE_ACTION_FAN => 5,
        };
        Self::enum_descriptor().value_by_index(index)
    }
}

impl ::std::default::Default for ClimateAction {
    fn default() -> Self {
        ClimateAction::CLIMATE_ACTION_OFF
    }
}

impl ClimateAction {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<ClimateAction>("ClimateAction")
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:ClimatePreset)
pub enum ClimatePreset {
    // @@protoc_insertion_point(enum_value:ClimatePreset.CLIMATE_PRESET_NONE)
    CLIMATE_PRESET_NONE = 0,
    // @@protoc_insertion_point(enum_value:ClimatePreset.CLIMATE_PRESET_HOME)
    CLIMATE_PRESET_HOME = 1,
    // @@protoc_insertion_point(enum_value:ClimatePreset.CLIMATE_PRESET_AWAY)
    CLIMATE_PRESET_AWAY = 2,
    // @@protoc_insertion_point(enum_value:ClimatePreset.CLIMATE_PRESET_BOOST)
    CLIMATE_PRESET_BOOST = 3,
    // @@protoc_insertion_point(enum_value:ClimatePreset.CLIMATE_PRESET_COMFORT)
    CLIMATE_PRESET_COMFORT = 4,
    // @@protoc_insertion_point(enum_value:ClimatePreset.CLIMATE_PRESET_ECO)
    CLIMATE_PRESET_ECO = 5,
    // @@protoc_insertion_point(enum_value:ClimatePreset.CLIMATE_PRESET_SLEEP)
    CLIMATE_PRESET_SLEEP = 6,
    // @@protoc_insertion_point(enum_value:ClimatePreset.CLIMATE_PRESET_ACTIVITY)
    CLIMATE_PRESET_ACTIVITY = 7,
}

impl ::protobuf::Enum for ClimatePreset {
    const NAME: &'static str = "ClimatePreset";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<ClimatePreset> {
        match value {
            0 => ::std::option::Option::Some(ClimatePreset::CLIMATE_PRESET_NONE),
            1 => ::std::option::Option::Some(ClimatePreset::CLIMATE_PRESET_HOME),
            2 => ::std::option::Option::Some(ClimatePreset::CLIMATE_PRESET_AWAY),
            3 => ::std::option::Option::Some(ClimatePreset::CLIMATE_PRESET_BOOST),
            4 => ::std::option::Option::Some(ClimatePreset::CLIMATE_PRESET_COMFORT),
            5 => ::std::option::Option::Some(ClimatePreset::CLIMATE_PRESET_ECO),
            6 => ::std::option::Option::Some(ClimatePreset::CLIMATE_PRESET_SLEEP),
            7 => ::std::option::Option::Some(ClimatePreset::CLIMATE_PRESET_ACTIVITY),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<ClimatePreset> {
        match str {
            "CLIMATE_PRESET_NONE" => ::std::option::Option::Some(ClimatePreset::CLIMATE_PRESET_NONE),
            "CLIMATE_PRESET_HOME" => ::std::option::Option::Some(ClimatePreset::CLIMATE_PRESET_HOME),
            "CLIMATE_PRESET_AWAY" => ::std::option::Option::Some(ClimatePreset::CLIMATE_PRESET_AWAY),
            "CLIMATE_PRESET_BOOST" => ::std::option::Option::Some(ClimatePreset::CLIMATE_PRESET_BOOST),
            "CLIMATE_PRESET_COMFORT" => ::std::option::Option::Some(ClimatePreset::CLIMATE_PRESET_COMFORT),
            "CLIMATE_PRESET_ECO" => ::std::option::Option::Some(ClimatePreset::CLIMATE_PRESET_ECO),
            "CLIMATE_PRESET_SLEEP" => ::std::option::Option::Some(ClimatePreset::CLIMATE_PRESET_SLEEP),
            "CLIMATE_PRESET_ACTIVITY" => ::std::option::Option::Some(ClimatePreset::CLIMATE_PRESET_ACTIVITY),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [ClimatePreset] = &[
        ClimatePreset::CLIMATE_PRESET_NONE,
        ClimatePreset::CLIMATE_PRESET_HOME,
        ClimatePreset::CLIMATE_PRESET_AWAY,
        ClimatePreset::CLIMATE_PRESET_BOOST,
        ClimatePreset::CLIMATE_PRESET_COMFORT,
        ClimatePreset::CLIMATE_PRESET_ECO,
        ClimatePreset::CLIMATE_PRESET_SLEEP,
        ClimatePreset::CLIMATE_PRESET_ACTIVITY,
    ];
}

impl ::protobuf::EnumFull for ClimatePreset {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("ClimatePreset").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = *self as usize;
        Self::enum_descriptor().value_by_index(index)
    }
}

impl ::std::default::Default for ClimatePreset {
    fn default() -> Self {
        ClimatePreset::CLIMATE_PRESET_NONE
    }
}

impl ClimatePreset {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<ClimatePreset>("ClimatePreset")
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:NumberMode)
pub enum NumberMode {
    // @@protoc_insertion_point(enum_value:NumberMode.NUMBER_MODE_AUTO)
    NUMBER_MODE_AUTO = 0,
    // @@protoc_insertion_point(enum_value:NumberMode.NUMBER_MODE_BOX)
    NUMBER_MODE_BOX = 1,
    // @@protoc_insertion_point(enum_value:NumberMode.NUMBER_MODE_SLIDER)
    NUMBER_MODE_SLIDER = 2,
}

impl ::protobuf::Enum for NumberMode {
    const NAME: &'static str = "NumberMode";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<NumberMode> {
        match value {
            0 => ::std::option::Option::Some(NumberMode::NUMBER_MODE_AUTO),
            1 => ::std::option::Option::Some(NumberMode::NUMBER_MODE_BOX),
            2 => ::std::option::Option::Some(NumberMode::NUMBER_MODE_SLIDER),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<NumberMode> {
        match str {
            "NUMBER_MODE_AUTO" => ::std::option::Option::Some(NumberMode::NUMBER_MODE_AUTO),
            "NUMBER_MODE_BOX" => ::std::option::Option::Some(NumberMode::NUMBER_MODE_BOX),
            "NUMBER_MODE_SLIDER" => ::std::option::Option::Some(NumberMode::NUMBER_MODE_SLIDER),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [NumberMode] = &[
        NumberMode::NUMBER_MODE_AUTO,
        NumberMode::NUMBER_MODE_BOX,
        NumberMode::NUMBER_MODE_SLIDER,
    ];
}

impl ::protobuf::EnumFull for NumberMode {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("NumberMode").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = *self as usize;
        Self::enum_descriptor().value_by_index(index)
    }
}

impl ::std::default::Default for NumberMode {
    fn default() -> Self {
        NumberMode::NUMBER_MODE_AUTO
    }
}

impl NumberMode {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<NumberMode>("NumberMode")
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:LockState)
pub enum LockState {
    // @@protoc_insertion_point(enum_value:LockState.LOCK_STATE_NONE)
    LOCK_STATE_NONE = 0,
    // @@protoc_insertion_point(enum_value:LockState.LOCK_STATE_LOCKED)
    LOCK_STATE_LOCKED = 1,
    // @@protoc_insertion_point(enum_value:LockState.LOCK_STATE_UNLOCKED)
    LOCK_STATE_UNLOCKED = 2,
    // @@protoc_insertion_point(enum_value:LockState.LOCK_STATE_JAMMED)
    LOCK_STATE_JAMMED = 3,
    // @@protoc_insertion_point(enum_value:LockState.LOCK_STATE_LOCKING)
    LOCK_STATE_LOCKING = 4,
    // @@protoc_insertion_point(enum_value:LockState.LOCK_STATE_UNLOCKING)
    LOCK_STATE_UNLOCKING = 5,
}

impl ::protobuf::Enum for LockState {
    const NAME: &'static str = "LockState";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<LockState> {
        match value {
            0 => ::std::option::Option::Some(LockState::LOCK_STATE_NONE),
            1 => ::std::option::Option::Some(LockState::LOCK_STATE_LOCKED),
            2 => ::std::option::Option::Some(LockState::LOCK_STATE_UNLOCKED),
            3 => ::std::option::Option::Some(LockState::LOCK_STATE_JAMMED),
            4 => ::std::option::Option::Some(LockState::LOCK_STATE_LOCKING),
            5 => ::std::option::Option::Some(LockState::LOCK_STATE_UNLOCKING),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<LockState> {
        match str {
            "LOCK_STATE_NONE" => ::std::option::Option::Some(LockState::LOCK_STATE_NONE),
            "LOCK_STATE_LOCKED" => ::std::option::Option::Some(LockState::LOCK_STATE_LOCKED),
            "LOCK_STATE_UNLOCKED" => ::std::option::Option::Some(LockState::LOCK_STATE_UNLOCKED),
            "LOCK_STATE_JAMMED" => ::std::option::Option::Some(LockState::LOCK_STATE_JAMMED),
            "LOCK_STATE_LOCKING" => ::std::option::Option::Some(LockState::LOCK_STATE_LOCKING),
            "LOCK_STATE_UNLOCKING" => ::std::option::Option::Some(LockState::LOCK_STATE_UNLOCKING),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [LockState] = &[
        LockState::LOCK_STATE_NONE,
        LockState::LOCK_STATE_LOCKED,
        LockState::LOCK_STATE_UNLOCKED,
        LockState::LOCK_STATE_JAMMED,
        LockState::LOCK_STATE_LOCKING,
        LockState::LOCK_STATE_UNLOCKING,
    ];
}

impl ::protobuf::EnumFull for LockState {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("LockState").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = *self as usize;
        Self::enum_descriptor().value_by_index(index)
    }
}

impl ::std::default::Default for LockState {
    fn default() -> Self {
        LockState::LOCK_STATE_NONE
    }
}

impl LockState {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<LockState>("LockState")
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:LockCommand)
pub enum LockCommand {
    // @@protoc_insertion_point(enum_value:LockCommand.LOCK_UNLOCK)
    LOCK_UNLOCK = 0,
    // @@protoc_insertion_point(enum_value:LockCommand.LOCK_LOCK)
    LOCK_LOCK = 1,
    // @@protoc_insertion_point(enum_value:LockCommand.LOCK_OPEN)
    LOCK_OPEN = 2,
}

impl ::protobuf::Enum for LockCommand {
    const NAME: &'static str = "LockCommand";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<LockCommand> {
        match value {
            0 => ::std::option::Option::Some(LockCommand::LOCK_UNLOCK),
            1 => ::std::option::Option::Some(LockCommand::LOCK_LOCK),
            2 => ::std::option::Option::Some(LockCommand::LOCK_OPEN),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<LockCommand> {
        match str {
            "LOCK_UNLOCK" => ::std::option::Option::Some(LockCommand::LOCK_UNLOCK),
            "LOCK_LOCK" => ::std::option::Option::Some(LockCommand::LOCK_LOCK),
            "LOCK_OPEN" => ::std::option::Option::Some(LockCommand::LOCK_OPEN),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [LockCommand] = &[
        LockCommand::LOCK_UNLOCK,
        LockCommand::LOCK_LOCK,
        LockCommand::LOCK_OPEN,
    ];
}

impl ::protobuf::EnumFull for LockCommand {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("LockCommand").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = *self as usize;
        Self::enum_descriptor().value_by_index(index)
    }
}

impl ::std::default::Default for LockCommand {
    fn default() -> Self {
        LockCommand::LOCK_UNLOCK
    }
}

impl LockCommand {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<LockCommand>("LockCommand")
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:MediaPlayerState)
pub enum MediaPlayerState {
    // @@protoc_insertion_point(enum_value:MediaPlayerState.MEDIA_PLAYER_STATE_NONE)
    MEDIA_PLAYER_STATE_NONE = 0,
    // @@protoc_insertion_point(enum_value:MediaPlayerState.MEDIA_PLAYER_STATE_IDLE)
    MEDIA_PLAYER_STATE_IDLE = 1,
    // @@protoc_insertion_point(enum_value:MediaPlayerState.MEDIA_PLAYER_STATE_PLAYING)
    MEDIA_PLAYER_STATE_PLAYING = 2,
    // @@protoc_insertion_point(enum_value:MediaPlayerState.MEDIA_PLAYER_STATE_PAUSED)
    MEDIA_PLAYER_STATE_PAUSED = 3,
}

impl ::protobuf::Enum for MediaPlayerState {
    const NAME: &'static str = "MediaPlayerState";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<MediaPlayerState> {
        match value {
            0 => ::std::option::Option::Some(MediaPlayerState::MEDIA_PLAYER_STATE_NONE),
            1 => ::std::option::Option::Some(MediaPlayerState::MEDIA_PLAYER_STATE_IDLE),
            2 => ::std::option::Option::Some(MediaPlayerState::MEDIA_PLAYER_STATE_PLAYING),
            3 => ::std::option::Option::Some(MediaPlayerState::MEDIA_PLAYER_STATE_PAUSED),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<MediaPlayerState> {
        match str {
            "MEDIA_PLAYER_STATE_NONE" => ::std::option::Option::Some(MediaPlayerState::MEDIA_PLAYER_STATE_NONE),
            "MEDIA_PLAYER_STATE_IDLE" => ::std::option::Option::Some(MediaPlayerState::MEDIA_PLAYER_STATE_IDLE),
            "MEDIA_PLAYER_STATE_PLAYING" => ::std::option::Option::Some(MediaPlayerState::MEDIA_PLAYER_STATE_PLAYING),
            "MEDIA_PLAYER_STATE_PAUSED" => ::std::option::Option::Some(MediaPlayerState::MEDIA_PLAYER_STATE_PAUSED),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [MediaPlayerState] = &[
        MediaPlayerState::MEDIA_PLAYER_STATE_NONE,
        MediaPlayerState::MEDIA_PLAYER_STATE_IDLE,
        MediaPlayerState::MEDIA_PLAYER_STATE_PLAYING,
        MediaPlayerState::MEDIA_PLAYER_STATE_PAUSED,
    ];
}

impl ::protobuf::EnumFull for MediaPlayerState {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("MediaPlayerState").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = *self as usize;
        Self::enum_descriptor().value_by_index(index)
    }
}

impl ::std::default::Default for MediaPlayerState {
    fn default() -> Self {
        MediaPlayerState::MEDIA_PLAYER_STATE_NONE
    }
}

impl MediaPlayerState {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<MediaPlayerState>("MediaPlayerState")
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:MediaPlayerCommand)
pub enum MediaPlayerCommand {
    // @@protoc_insertion_point(enum_value:MediaPlayerCommand.MEDIA_PLAYER_COMMAND_PLAY)
    MEDIA_PLAYER_COMMAND_PLAY = 0,
    // @@protoc_insertion_point(enum_value:MediaPlayerCommand.MEDIA_PLAYER_COMMAND_PAUSE)
    MEDIA_PLAYER_COMMAND_PAUSE = 1,
    // @@protoc_insertion_point(enum_value:MediaPlayerCommand.MEDIA_PLAYER_COMMAND_STOP)
    MEDIA_PLAYER_COMMAND_STOP = 2,
    // @@protoc_insertion_point(enum_value:MediaPlayerCommand.MEDIA_PLAYER_COMMAND_MUTE)
    MEDIA_PLAYER_COMMAND_MUTE = 3,
    // @@protoc_insertion_point(enum_value:MediaPlayerCommand.MEDIA_PLAYER_COMMAND_UNMUTE)
    MEDIA_PLAYER_COMMAND_UNMUTE = 4,
}

impl ::protobuf::Enum for MediaPlayerCommand {
    const NAME: &'static str = "MediaPlayerCommand";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<MediaPlayerCommand> {
        match value {
            0 => ::std::option::Option::Some(MediaPlayerCommand::MEDIA_PLAYER_COMMAND_PLAY),
            1 => ::std::option::Option::Some(MediaPlayerCommand::MEDIA_PLAYER_COMMAND_PAUSE),
            2 => ::std::option::Option::Some(MediaPlayerCommand::MEDIA_PLAYER_COMMAND_STOP),
            3 => ::std::option::Option::Some(MediaPlayerCommand::MEDIA_PLAYER_COMMAND_MUTE),
            4 => ::std::option::Option::Some(MediaPlayerCommand::MEDIA_PLAYER_COMMAND_UNMUTE),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<MediaPlayerCommand> {
        match str {
            "MEDIA_PLAYER_COMMAND_PLAY" => ::std::option::Option::Some(MediaPlayerCommand::MEDIA_PLAYER_COMMAND_PLAY),
            "MEDIA_PLAYER_COMMAND_PAUSE" => ::std::option::Option::Some(MediaPlayerCommand::MEDIA_PLAYER_COMMAND_PAUSE),
            "MEDIA_PLAYER_COMMAND_STOP" => ::std::option::Option::Some(MediaPlayerCommand::MEDIA_PLAYER_COMMAND_STOP),
            "MEDIA_PLAYER_COMMAND_MUTE" => ::std::option::Option::Some(MediaPlayerCommand::MEDIA_PLAYER_COMMAND_MUTE),
            "MEDIA_PLAYER_COMMAND_UNMUTE" => ::std::option::Option::Some(MediaPlayerCommand::MEDIA_PLAYER_COMMAND_UNMUTE),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [MediaPlayerCommand] = &[
        MediaPlayerCommand::MEDIA_PLAYER_COMMAND_PLAY,
        MediaPlayerCommand::MEDIA_PLAYER_COMMAND_PAUSE,
        MediaPlayerCommand::MEDIA_PLAYER_COMMAND_STOP,
        MediaPlayerCommand::MEDIA_PLAYER_COMMAND_MUTE,
        MediaPlayerCommand::MEDIA_PLAYER_COMMAND_UNMUTE,
    ];
}

impl ::protobuf::EnumFull for MediaPlayerCommand {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("MediaPlayerCommand").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = *self as usize;
        Self::enum_descriptor().value_by_index(index)
    }
}

impl ::std::default::Default for MediaPlayerCommand {
    fn default() -> Self {
        MediaPlayerCommand::MEDIA_PLAYER_COMMAND_PLAY
    }
}

impl MediaPlayerCommand {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<MediaPlayerCommand>("MediaPlayerCommand")
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:MediaPlayerFormatPurpose)
pub enum MediaPlayerFormatPurpose {
    // @@protoc_insertion_point(enum_value:MediaPlayerFormatPurpose.MEDIA_PLAYER_FORMAT_PURPOSE_DEFAULT)
    MEDIA_PLAYER_FORMAT_PURPOSE_DEFAULT = 0,
    // @@protoc_insertion_point(enum_value:MediaPlayerFormatPurpose.MEDIA_PLAYER_FORMAT_PURPOSE_ANNOUNCEMENT)
    MEDIA_PLAYER_FORMAT_PURPOSE_ANNOUNCEMENT = 1,
}

impl ::protobuf::Enum for MediaPlayerFormatPurpose {
    const NAME: &'static str = "MediaPlayerFormatPurpose";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<MediaPlayerFormatPurpose> {
        match value {
            0 => ::std::option::Option::Some(MediaPlayerFormatPurpose::MEDIA_PLAYER_FORMAT_PURPOSE_DEFAULT),
            1 => ::std::option::Option::Some(MediaPlayerFormatPurpose::MEDIA_PLAYER_FORMAT_PURPOSE_ANNOUNCEMENT),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<MediaPlayerFormatPurpose> {
        match str {
            "MEDIA_PLAYER_FORMAT_PURPOSE_DEFAULT" => ::std::option::Option::Some(MediaPlayerFormatPurpose::MEDIA_PLAYER_FORMAT_PURPOSE_DEFAULT),
            "MEDIA_PLAYER_FORMAT_PURPOSE_ANNOUNCEMENT" => ::std::option::Option::Some(MediaPlayerFormatPurpose::MEDIA_PLAYER_FORMAT_PURPOSE_ANNOUNCEMENT),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [MediaPlayerFormatPurpose] = &[
        MediaPlayerFormatPurpose::MEDIA_PLAYER_FORMAT_PURPOSE_DEFAULT,
        MediaPlayerFormatPurpose::MEDIA_PLAYER_FORMAT_PURPOSE_ANNOUNCEMENT,
    ];
}

impl ::protobuf::EnumFull for MediaPlayerFormatPurpose {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("MediaPlayerFormatPurpose").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = *self as usize;
        Self::enum_descriptor().value_by_index(index)
    }
}

impl ::std::default::Default for MediaPlayerFormatPurpose {
    fn default() -> Self {
        MediaPlayerFormatPurpose::MEDIA_PLAYER_FORMAT_PURPOSE_DEFAULT
    }
}

impl MediaPlayerFormatPurpose {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<MediaPlayerFormatPurpose>("MediaPlayerFormatPurpose")
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:BluetoothDeviceRequestType)
pub enum BluetoothDeviceRequestType {
    // @@protoc_insertion_point(enum_value:BluetoothDeviceRequestType.BLUETOOTH_DEVICE_REQUEST_TYPE_CONNECT)
    BLUETOOTH_DEVICE_REQUEST_TYPE_CONNECT = 0,
    // @@protoc_insertion_point(enum_value:BluetoothDeviceRequestType.BLUETOOTH_DEVICE_REQUEST_TYPE_DISCONNECT)
    BLUETOOTH_DEVICE_REQUEST_TYPE_DISCONNECT = 1,
    // @@protoc_insertion_point(enum_value:BluetoothDeviceRequestType.BLUETOOTH_DEVICE_REQUEST_TYPE_PAIR)
    BLUETOOTH_DEVICE_REQUEST_TYPE_PAIR = 2,
    // @@protoc_insertion_point(enum_value:BluetoothDeviceRequestType.BLUETOOTH_DEVICE_REQUEST_TYPE_UNPAIR)
    BLUETOOTH_DEVICE_REQUEST_TYPE_UNPAIR = 3,
    // @@protoc_insertion_point(enum_value:BluetoothDeviceRequestType.BLUETOOTH_DEVICE_REQUEST_TYPE_CONNECT_V3_WITH_CACHE)
    BLUETOOTH_DEVICE_REQUEST_TYPE_CONNECT_V3_WITH_CACHE = 4,
    // @@protoc_insertion_point(enum_value:BluetoothDeviceRequestType.BLUETOOTH_DEVICE_REQUEST_TYPE_CONNECT_V3_WITHOUT_CACHE)
    BLUETOOTH_DEVICE_REQUEST_TYPE_CONNECT_V3_WITHOUT_CACHE = 5,
    // @@protoc_insertion_point(enum_value:BluetoothDeviceRequestType.BLUETOOTH_DEVICE_REQUEST_TYPE_CLEAR_CACHE)
    BLUETOOTH_DEVICE_REQUEST_TYPE_CLEAR_CACHE = 6,
}

impl ::protobuf::Enum for BluetoothDeviceRequestType {
    const NAME: &'static str = "BluetoothDeviceRequestType";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<BluetoothDeviceRequestType> {
        match value {
            0 => ::std::option::Option::Some(BluetoothDeviceRequestType::BLUETOOTH_DEVICE_REQUEST_TYPE_CONNECT),
            1 => ::std::option::Option::Some(BluetoothDeviceRequestType::BLUETOOTH_DEVICE_REQUEST_TYPE_DISCONNECT),
            2 => ::std::option::Option::Some(BluetoothDeviceRequestType::BLUETOOTH_DEVICE_REQUEST_TYPE_PAIR),
            3 => ::std::option::Option::Some(BluetoothDeviceRequestType::BLUETOOTH_DEVICE_REQUEST_TYPE_UNPAIR),
            4 => ::std::option::Option::Some(BluetoothDeviceRequestType::BLUETOOTH_DEVICE_REQUEST_TYPE_CONNECT_V3_WITH_CACHE),
            5 => ::std::option::Option::Some(BluetoothDeviceRequestType::BLUETOOTH_DEVICE_REQUEST_TYPE_CONNECT_V3_WITHOUT_CACHE),
            6 => ::std::option::Option::Some(BluetoothDeviceRequestType::BLUETOOTH_DEVICE_REQUEST_TYPE_CLEAR_CACHE),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<BluetoothDeviceRequestType> {
        match str {
            "BLUETOOTH_DEVICE_REQUEST_TYPE_CONNECT" => ::std::option::Option::Some(BluetoothDeviceRequestType::BLUETOOTH_DEVICE_REQUEST_TYPE_CONNECT),
            "BLUETOOTH_DEVICE_REQUEST_TYPE_DISCONNECT" => ::std::option::Option::Some(BluetoothDeviceRequestType::BLUETOOTH_DEVICE_REQUEST_TYPE_DISCONNECT),
            "BLUETOOTH_DEVICE_REQUEST_TYPE_PAIR" => ::std::option::Option::Some(BluetoothDeviceRequestType::BLUETOOTH_DEVICE_REQUEST_TYPE_PAIR),
            "BLUETOOTH_DEVICE_REQUEST_TYPE_UNPAIR" => ::std::option::Option::Some(BluetoothDeviceRequestType::BLUETOOTH_DEVICE_REQUEST_TYPE_UNPAIR),
            "BLUETOOTH_DEVICE_REQUEST_TYPE_CONNECT_V3_WITH_CACHE" => ::std::option::Option::Some(BluetoothDeviceRequestType::BLUETOOTH_DEVICE_REQUEST_TYPE_CONNECT_V3_WITH_CACHE),
            "BLUETOOTH_DEVICE_REQUEST_TYPE_CONNECT_V3_WITHOUT_CACHE" => ::std::option::Option::Some(BluetoothDeviceRequestType::BLUETOOTH_DEVICE_REQUEST_TYPE_CONNECT_V3_WITHOUT_CACHE),
            "BLUETOOTH_DEVICE_REQUEST_TYPE_CLEAR_CACHE" => ::std::option::Option::Some(BluetoothDeviceRequestType::BLUETOOTH_DEVICE_REQUEST_TYPE_CLEAR_CACHE),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [BluetoothDeviceRequestType] = &[
        BluetoothDeviceRequestType::BLUETOOTH_DEVICE_REQUEST_TYPE_CONNECT,
        BluetoothDeviceRequestType::BLUETOOTH_DEVICE_REQUEST_TYPE_DISCONNECT,
        BluetoothDeviceRequestType::BLUETOOTH_DEVICE_REQUEST_TYPE_PAIR,
        BluetoothDeviceRequestType::BLUETOOTH_DEVICE_REQUEST_TYPE_UNPAIR,
        BluetoothDeviceRequestType::BLUETOOTH_DEVICE_REQUEST_TYPE_CONNECT_V3_WITH_CACHE,
        BluetoothDeviceRequestType::BLUETOOTH_DEVICE_REQUEST_TYPE_CONNECT_V3_WITHOUT_CACHE,
        BluetoothDeviceRequestType::BLUETOOTH_DEVICE_REQUEST_TYPE_CLEAR_CACHE,
    ];
}

impl ::protobuf::EnumFull for BluetoothDeviceRequestType {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("BluetoothDeviceRequestType").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = *self as usize;
        Self::enum_descriptor().value_by_index(index)
    }
}

impl ::std::default::Default for BluetoothDeviceRequestType {
    fn default() -> Self {
        BluetoothDeviceRequestType::BLUETOOTH_DEVICE_REQUEST_TYPE_CONNECT
    }
}

impl BluetoothDeviceRequestType {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<BluetoothDeviceRequestType>("BluetoothDeviceRequestType")
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:BluetoothScannerState)
pub enum BluetoothScannerState {
    // @@protoc_insertion_point(enum_value:BluetoothScannerState.BLUETOOTH_SCANNER_STATE_IDLE)
    BLUETOOTH_SCANNER_STATE_IDLE = 0,
    // @@protoc_insertion_point(enum_value:BluetoothScannerState.BLUETOOTH_SCANNER_STATE_STARTING)
    BLUETOOTH_SCANNER_STATE_STARTING = 1,
    // @@protoc_insertion_point(enum_value:BluetoothScannerState.BLUETOOTH_SCANNER_STATE_RUNNING)
    BLUETOOTH_SCANNER_STATE_RUNNING = 2,
    // @@protoc_insertion_point(enum_value:BluetoothScannerState.BLUETOOTH_SCANNER_STATE_FAILED)
    BLUETOOTH_SCANNER_STATE_FAILED = 3,
    // @@protoc_insertion_point(enum_value:BluetoothScannerState.BLUETOOTH_SCANNER_STATE_STOPPING)
    BLUETOOTH_SCANNER_STATE_STOPPING = 4,
    // @@protoc_insertion_point(enum_value:BluetoothScannerState.BLUETOOTH_SCANNER_STATE_STOPPED)
    BLUETOOTH_SCANNER_STATE_STOPPED = 5,
}

impl ::protobuf::Enum for BluetoothScannerState {
    const NAME: &'static str = "BluetoothScannerState";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<BluetoothScannerState> {
        match value {
            0 => ::std::option::Option::Some(BluetoothScannerState::BLUETOOTH_SCANNER_STATE_IDLE),
            1 => ::std::option::Option::Some(BluetoothScannerState::BLUETOOTH_SCANNER_STATE_STARTING),
            2 => ::std::option::Option::Some(BluetoothScannerState::BLUETOOTH_SCANNER_STATE_RUNNING),
            3 => ::std::option::Option::Some(BluetoothScannerState::BLUETOOTH_SCANNER_STATE_FAILED),
            4 => ::std::option::Option::Some(BluetoothScannerState::BLUETOOTH_SCANNER_STATE_STOPPING),
            5 => ::std::option::Option::Some(BluetoothScannerState::BLUETOOTH_SCANNER_STATE_STOPPED),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<BluetoothScannerState> {
        match str {
            "BLUETOOTH_SCANNER_STATE_IDLE" => ::std::option::Option::Some(BluetoothScannerState::BLUETOOTH_SCANNER_STATE_IDLE),
            "BLUETOOTH_SCANNER_STATE_STARTING" => ::std::option::Option::Some(BluetoothScannerState::BLUETOOTH_SCANNER_STATE_STARTING),
            "BLUETOOTH_SCANNER_STATE_RUNNING" => ::std::option::Option::Some(BluetoothScannerState::BLUETOOTH_SCANNER_STATE_RUNNING),
            "BLUETOOTH_SCANNER_STATE_FAILED" => ::std::option::Option::Some(BluetoothScannerState::BLUETOOTH_SCANNER_STATE_FAILED),
            "BLUETOOTH_SCANNER_STATE_STOPPING" => ::std::option::Option::Some(BluetoothScannerState::BLUETOOTH_SCANNER_STATE_STOPPING),
            "BLUETOOTH_SCANNER_STATE_STOPPED" => ::std::option::Option::Some(BluetoothScannerState::BLUETOOTH_SCANNER_STATE_STOPPED),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [BluetoothScannerState] = &[
        BluetoothScannerState::BLUETOOTH_SCANNER_STATE_IDLE,
        BluetoothScannerState::BLUETOOTH_SCANNER_STATE_STARTING,
        BluetoothScannerState::BLUETOOTH_SCANNER_STATE_RUNNING,
        BluetoothScannerState::BLUETOOTH_SCANNER_STATE_FAILED,
        BluetoothScannerState::BLUETOOTH_SCANNER_STATE_STOPPING,
        BluetoothScannerState::BLUETOOTH_SCANNER_STATE_STOPPED,
    ];
}

impl ::protobuf::EnumFull for BluetoothScannerState {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("BluetoothScannerState").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = *self as usize;
        Self::enum_descriptor().value_by_index(index)
    }
}

impl ::std::default::Default for BluetoothScannerState {
    fn default() -> Self {
        BluetoothScannerState::BLUETOOTH_SCANNER_STATE_IDLE
    }
}

impl BluetoothScannerState {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<BluetoothScannerState>("BluetoothScannerState")
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:BluetoothScannerMode)
pub enum BluetoothScannerMode {
    // @@protoc_insertion_point(enum_value:BluetoothScannerMode.BLUETOOTH_SCANNER_MODE_PASSIVE)
    BLUETOOTH_SCANNER_MODE_PASSIVE = 0,
    // @@protoc_insertion_point(enum_value:BluetoothScannerMode.BLUETOOTH_SCANNER_MODE_ACTIVE)
    BLUETOOTH_SCANNER_MODE_ACTIVE = 1,
}

impl ::protobuf::Enum for BluetoothScannerMode {
    const NAME: &'static str = "BluetoothScannerMode";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<BluetoothScannerMode> {
        match value {
            0 => ::std::option::Option::Some(BluetoothScannerMode::BLUETOOTH_SCANNER_MODE_PASSIVE),
            1 => ::std::option::Option::Some(BluetoothScannerMode::BLUETOOTH_SCANNER_MODE_ACTIVE),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<BluetoothScannerMode> {
        match str {
            "BLUETOOTH_SCANNER_MODE_PASSIVE" => ::std::option::Option::Some(BluetoothScannerMode::BLUETOOTH_SCANNER_MODE_PASSIVE),
            "BLUETOOTH_SCANNER_MODE_ACTIVE" => ::std::option::Option::Some(BluetoothScannerMode::BLUETOOTH_SCANNER_MODE_ACTIVE),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [BluetoothScannerMode] = &[
        BluetoothScannerMode::BLUETOOTH_SCANNER_MODE_PASSIVE,
        BluetoothScannerMode::BLUETOOTH_SCANNER_MODE_ACTIVE,
    ];
}

impl ::protobuf::EnumFull for BluetoothScannerMode {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("BluetoothScannerMode").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = *self as usize;
        Self::enum_descriptor().value_by_index(index)
    }
}

impl ::std::default::Default for BluetoothScannerMode {
    fn default() -> Self {
        BluetoothScannerMode::BLUETOOTH_SCANNER_MODE_PASSIVE
    }
}

impl BluetoothScannerMode {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<BluetoothScannerMode>("BluetoothScannerMode")
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:VoiceAssistantSubscribeFlag)
pub enum VoiceAssistantSubscribeFlag {
    // @@protoc_insertion_point(enum_value:VoiceAssistantSubscribeFlag.VOICE_ASSISTANT_SUBSCRIBE_NONE)
    VOICE_ASSISTANT_SUBSCRIBE_NONE = 0,
    // @@protoc_insertion_point(enum_value:VoiceAssistantSubscribeFlag.VOICE_ASSISTANT_SUBSCRIBE_API_AUDIO)
    VOICE_ASSISTANT_SUBSCRIBE_API_AUDIO = 1,
}

impl ::protobuf::Enum for VoiceAssistantSubscribeFlag {
    const NAME: &'static str = "VoiceAssistantSubscribeFlag";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<VoiceAssistantSubscribeFlag> {
        match value {
            0 => ::std::option::Option::Some(VoiceAssistantSubscribeFlag::VOICE_ASSISTANT_SUBSCRIBE_NONE),
            1 => ::std::option::Option::Some(VoiceAssistantSubscribeFlag::VOICE_ASSISTANT_SUBSCRIBE_API_AUDIO),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<VoiceAssistantSubscribeFlag> {
        match str {
            "VOICE_ASSISTANT_SUBSCRIBE_NONE" => ::std::option::Option::Some(VoiceAssistantSubscribeFlag::VOICE_ASSISTANT_SUBSCRIBE_NONE),
            "VOICE_ASSISTANT_SUBSCRIBE_API_AUDIO" => ::std::option::Option::Some(VoiceAssistantSubscribeFlag::VOICE_ASSISTANT_SUBSCRIBE_API_AUDIO),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [VoiceAssistantSubscribeFlag] = &[
        VoiceAssistantSubscribeFlag::VOICE_ASSISTANT_SUBSCRIBE_NONE,
        VoiceAssistantSubscribeFlag::VOICE_ASSISTANT_SUBSCRIBE_API_AUDIO,
    ];
}

impl ::protobuf::EnumFull for VoiceAssistantSubscribeFlag {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("VoiceAssistantSubscribeFlag").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = *self as usize;
        Self::enum_descriptor().value_by_index(index)
    }
}

impl ::std::default::Default for VoiceAssistantSubscribeFlag {
    fn default() -> Self {
        VoiceAssistantSubscribeFlag::VOICE_ASSISTANT_SUBSCRIBE_NONE
    }
}

impl VoiceAssistantSubscribeFlag {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<VoiceAssistantSubscribeFlag>("VoiceAssistantSubscribeFlag")
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:VoiceAssistantRequestFlag)
pub enum VoiceAssistantRequestFlag {
    // @@protoc_insertion_point(enum_value:VoiceAssistantRequestFlag.VOICE_ASSISTANT_REQUEST_NONE)
    VOICE_ASSISTANT_REQUEST_NONE = 0,
    // @@protoc_insertion_point(enum_value:VoiceAssistantRequestFlag.VOICE_ASSISTANT_REQUEST_USE_VAD)
    VOICE_ASSISTANT_REQUEST_USE_VAD = 1,
    // @@protoc_insertion_point(enum_value:VoiceAssistantRequestFlag.VOICE_ASSISTANT_REQUEST_USE_WAKE_WORD)
    VOICE_ASSISTANT_REQUEST_USE_WAKE_WORD = 2,
}

impl ::protobuf::Enum for VoiceAssistantRequestFlag {
    const NAME: &'static str = "VoiceAssistantRequestFlag";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<VoiceAssistantRequestFlag> {
        match value {
            0 => ::std::option::Option::Some(VoiceAssistantRequestFlag::VOICE_ASSISTANT_REQUEST_NONE),
            1 => ::std::option::Option::Some(VoiceAssistantRequestFlag::VOICE_ASSISTANT_REQUEST_USE_VAD),
            2 => ::std::option::Option::Some(VoiceAssistantRequestFlag::VOICE_ASSISTANT_REQUEST_USE_WAKE_WORD),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<VoiceAssistantRequestFlag> {
        match str {
            "VOICE_ASSISTANT_REQUEST_NONE" => ::std::option::Option::Some(VoiceAssistantRequestFlag::VOICE_ASSISTANT_REQUEST_NONE),
            "VOICE_ASSISTANT_REQUEST_USE_VAD" => ::std::option::Option::Some(VoiceAssistantRequestFlag::VOICE_ASSISTANT_REQUEST_USE_VAD),
            "VOICE_ASSISTANT_REQUEST_USE_WAKE_WORD" => ::std::option::Option::Some(VoiceAssistantRequestFlag::VOICE_ASSISTANT_REQUEST_USE_WAKE_WORD),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [VoiceAssistantRequestFlag] = &[
        VoiceAssistantRequestFlag::VOICE_ASSISTANT_REQUEST_NONE,
        VoiceAssistantRequestFlag::VOICE_ASSISTANT_REQUEST_USE_VAD,
        VoiceAssistantRequestFlag::VOICE_ASSISTANT_REQUEST_USE_WAKE_WORD,
    ];
}

impl ::protobuf::EnumFull for VoiceAssistantRequestFlag {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("VoiceAssistantRequestFlag").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = *self as usize;
        Self::enum_descriptor().value_by_index(index)
    }
}

impl ::std::default::Default for VoiceAssistantRequestFlag {
    fn default() -> Self {
        VoiceAssistantRequestFlag::VOICE_ASSISTANT_REQUEST_NONE
    }
}

impl VoiceAssistantRequestFlag {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<VoiceAssistantRequestFlag>("VoiceAssistantRequestFlag")
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:VoiceAssistantEvent)
pub enum VoiceAssistantEvent {
    // @@protoc_insertion_point(enum_value:VoiceAssistantEvent.VOICE_ASSISTANT_ERROR)
    VOICE_ASSISTANT_ERROR = 0,
    // @@protoc_insertion_point(enum_value:VoiceAssistantEvent.VOICE_ASSISTANT_RUN_START)
    VOICE_ASSISTANT_RUN_START = 1,
    // @@protoc_insertion_point(enum_value:VoiceAssistantEvent.VOICE_ASSISTANT_RUN_END)
    VOICE_ASSISTANT_RUN_END = 2,
    // @@protoc_insertion_point(enum_value:VoiceAssistantEvent.VOICE_ASSISTANT_STT_START)
    VOICE_ASSISTANT_STT_START = 3,
    // @@protoc_insertion_point(enum_value:VoiceAssistantEvent.VOICE_ASSISTANT_STT_END)
    VOICE_ASSISTANT_STT_END = 4,
    // @@protoc_insertion_point(enum_value:VoiceAssistantEvent.VOICE_ASSISTANT_INTENT_START)
    VOICE_ASSISTANT_INTENT_START = 5,
    // @@protoc_insertion_point(enum_value:VoiceAssistantEvent.VOICE_ASSISTANT_INTENT_END)
    VOICE_ASSISTANT_INTENT_END = 6,
    // @@protoc_insertion_point(enum_value:VoiceAssistantEvent.VOICE_ASSISTANT_TTS_START)
    VOICE_ASSISTANT_TTS_START = 7,
    // @@protoc_insertion_point(enum_value:VoiceAssistantEvent.VOICE_ASSISTANT_TTS_END)
    VOICE_ASSISTANT_TTS_END = 8,
    // @@protoc_insertion_point(enum_value:VoiceAssistantEvent.VOICE_ASSISTANT_WAKE_WORD_START)
    VOICE_ASSISTANT_WAKE_WORD_START = 9,
    // @@protoc_insertion_point(enum_value:VoiceAssistantEvent.VOICE_ASSISTANT_WAKE_WORD_END)
    VOICE_ASSISTANT_WAKE_WORD_END = 10,
    // @@protoc_insertion_point(enum_value:VoiceAssistantEvent.VOICE_ASSISTANT_STT_VAD_START)
    VOICE_ASSISTANT_STT_VAD_START = 11,
    // @@protoc_insertion_point(enum_value:VoiceAssistantEvent.VOICE_ASSISTANT_STT_VAD_END)
    VOICE_ASSISTANT_STT_VAD_END = 12,
    // @@protoc_insertion_point(enum_value:VoiceAssistantEvent.VOICE_ASSISTANT_TTS_STREAM_START)
    VOICE_ASSISTANT_TTS_STREAM_START = 98,
    // @@protoc_insertion_point(enum_value:VoiceAssistantEvent.VOICE_ASSISTANT_TTS_STREAM_END)
    VOICE_ASSISTANT_TTS_STREAM_END = 99,
    // @@protoc_insertion_point(enum_value:VoiceAssistantEvent.VOICE_ASSISTANT_INTENT_PROGRESS)
    VOICE_ASSISTANT_INTENT_PROGRESS = 100,
}

impl ::protobuf::Enum for VoiceAssistantEvent {
    const NAME: &'static str = "VoiceAssistantEvent";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<VoiceAssistantEvent> {
        match value {
            0 => ::std::option::Option::Some(VoiceAssistantEvent::VOICE_ASSISTANT_ERROR),
            1 => ::std::option::Option::Some(VoiceAssistantEvent::VOICE_ASSISTANT_RUN_START),
            2 => ::std::option::Option::Some(VoiceAssistantEvent::VOICE_ASSISTANT_RUN_END),
            3 => ::std::option::Option::Some(VoiceAssistantEvent::VOICE_ASSISTANT_STT_START),
            4 => ::std::option::Option::Some(VoiceAssistantEvent::VOICE_ASSISTANT_STT_END),
            5 => ::std::option::Option::Some(VoiceAssistantEvent::VOICE_ASSISTANT_INTENT_START),
            6 => ::std::option::Option::Some(VoiceAssistantEvent::VOICE_ASSISTANT_INTENT_END),
            7 => ::std::option::Option::Some(VoiceAssistantEvent::VOICE_ASSISTANT_TTS_START),
            8 => ::std::option::Option::Some(VoiceAssistantEvent::VOICE_ASSISTANT_TTS_END),
            9 => ::std::option::Option::Some(VoiceAssistantEvent::VOICE_ASSISTANT_WAKE_WORD_START),
            10 => ::std::option::Option::Some(VoiceAssistantEvent::VOICE_ASSISTANT_WAKE_WORD_END),
            11 => ::std::option::Option::Some(VoiceAssistantEvent::VOICE_ASSISTANT_STT_VAD_START),
            12 => ::std::option::Option::Some(VoiceAssistantEvent::VOICE_ASSISTANT_STT_VAD_END),
            98 => ::std::option::Option::Some(VoiceAssistantEvent::VOICE_ASSISTANT_TTS_STREAM_START),
            99 => ::std::option::Option::Some(VoiceAssistantEvent::VOICE_ASSISTANT_TTS_STREAM_END),
            100 => ::std::option::Option::Some(VoiceAssistantEvent::VOICE_ASSISTANT_INTENT_PROGRESS),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<VoiceAssistantEvent> {
        match str {
            "VOICE_ASSISTANT_ERROR" => ::std::option::Option::Some(VoiceAssistantEvent::VOICE_ASSISTANT_ERROR),
            "VOICE_ASSISTANT_RUN_START" => ::std::option::Option::Some(VoiceAssistantEvent::VOICE_ASSISTANT_RUN_START),
            "VOICE_ASSISTANT_RUN_END" => ::std::option::Option::Some(VoiceAssistantEvent::VOICE_ASSISTANT_RUN_END),
            "VOICE_ASSISTANT_STT_START" => ::std::option::Option::Some(VoiceAssistantEvent::VOICE_ASSISTANT_STT_START),
            "VOICE_ASSISTANT_STT_END" => ::std::option::Option::Some(VoiceAssistantEvent::VOICE_ASSISTANT_STT_END),
            "VOICE_ASSISTANT_INTENT_START" => ::std::option::Option::Some(VoiceAssistantEvent::VOICE_ASSISTANT_INTENT_START),
            "VOICE_ASSISTANT_INTENT_END" => ::std::option::Option::Some(VoiceAssistantEvent::VOICE_ASSISTANT_INTENT_END),
            "VOICE_ASSISTANT_TTS_START" => ::std::option::Option::Some(VoiceAssistantEvent::VOICE_ASSISTANT_TTS_START),
            "VOICE_ASSISTANT_TTS_END" => ::std::option::Option::Some(VoiceAssistantEvent::VOICE_ASSISTANT_TTS_END),
            "VOICE_ASSISTANT_WAKE_WORD_START" => ::std::option::Option::Some(VoiceAssistantEvent::VOICE_ASSISTANT_WAKE_WORD_START),
            "VOICE_ASSISTANT_WAKE_WORD_END" => ::std::option::Option::Some(VoiceAssistantEvent::VOICE_ASSISTANT_WAKE_WORD_END),
            "VOICE_ASSISTANT_STT_VAD_START" => ::std::option::Option::Some(VoiceAssistantEvent::VOICE_ASSISTANT_STT_VAD_START),
            "VOICE_ASSISTANT_STT_VAD_END" => ::std::option::Option::Some(VoiceAssistantEvent::VOICE_ASSISTANT_STT_VAD_END),
            "VOICE_ASSISTANT_TTS_STREAM_START" => ::std::option::Option::Some(VoiceAssistantEvent::VOICE_ASSISTANT_TTS_STREAM_START),
            "VOICE_ASSISTANT_TTS_STREAM_END" => ::std::option::Option::Some(VoiceAssistantEvent::VOICE_ASSISTANT_TTS_STREAM_END),
            "VOICE_ASSISTANT_INTENT_PROGRESS" => ::std::option::Option::Some(VoiceAssistantEvent::VOICE_ASSISTANT_INTENT_PROGRESS),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [VoiceAssistantEvent] = &[
        VoiceAssistantEvent::VOICE_ASSISTANT_ERROR,
        VoiceAssistantEvent::VOICE_ASSISTANT_RUN_START,
        VoiceAssistantEvent::VOICE_ASSISTANT_RUN_END,
        VoiceAssistantEvent::VOICE_ASSISTANT_STT_START,
        VoiceAssistantEvent::VOICE_ASSISTANT_STT_END,
        VoiceAssistantEvent::VOICE_ASSISTANT_INTENT_START,
        VoiceAssistantEvent::VOICE_ASSISTANT_INTENT_END,
        VoiceAssistantEvent::VOICE_ASSISTANT_TTS_START,
        VoiceAssistantEvent::VOICE_ASSISTANT_TTS_END,
        VoiceAssistantEvent::VOICE_ASSISTANT_WAKE_WORD_START,
        VoiceAssistantEvent::VOICE_ASSISTANT_WAKE_WORD_END,
        VoiceAssistantEvent::VOICE_ASSISTANT_STT_VAD_START,
        VoiceAssistantEvent::VOICE_ASSISTANT_STT_VAD_END,
        VoiceAssistantEvent::VOICE_ASSISTANT_TTS_STREAM_START,
        VoiceAssistantEvent::VOICE_ASSISTANT_TTS_STREAM_END,
        VoiceAssistantEvent::VOICE_ASSISTANT_INTENT_PROGRESS,
    ];
}

impl ::protobuf::EnumFull for VoiceAssistantEvent {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("VoiceAssistantEvent").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = match self {
            VoiceAssistantEvent::VOICE_ASSISTANT_ERROR => 0,
            VoiceAssistantEvent::VOICE_ASSISTANT_RUN_START => 1,
            VoiceAssistantEvent::VOICE_ASSISTANT_RUN_END => 2,
            VoiceAssistantEvent::VOICE_ASSISTANT_STT_START => 3,
            VoiceAssistantEvent::VOICE_ASSISTANT_STT_END => 4,
            VoiceAssistantEvent::VOICE_ASSISTANT_INTENT_START => 5,
            VoiceAssistantEvent::VOICE_ASSISTANT_INTENT_END => 6,
            VoiceAssistantEvent::VOICE_ASSISTANT_TTS_START => 7,
            VoiceAssistantEvent::VOICE_ASSISTANT_TTS_END => 8,
            VoiceAssistantEvent::VOICE_ASSISTANT_WAKE_WORD_START => 9,
            VoiceAssistantEvent::VOICE_ASSISTANT_WAKE_WORD_END => 10,
            VoiceAssistantEvent::VOICE_ASSISTANT_STT_VAD_START => 11,
            VoiceAssistantEvent::VOICE_ASSISTANT_STT_VAD_END => 12,
            VoiceAssistantEvent::VOICE_ASSISTANT_TTS_STREAM_START => 13,
            VoiceAssistantEvent::VOICE_ASSISTANT_TTS_STREAM_END => 14,
            VoiceAssistantEvent::VOICE_ASSISTANT_INTENT_PROGRESS => 15,
        };
        Self::enum_descriptor().value_by_index(index)
    }
}

impl ::std::default::Default for VoiceAssistantEvent {
    fn default() -> Self {
        VoiceAssistantEvent::VOICE_ASSISTANT_ERROR
    }
}

impl VoiceAssistantEvent {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<VoiceAssistantEvent>("VoiceAssistantEvent")
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:VoiceAssistantTimerEvent)
pub enum VoiceAssistantTimerEvent {
    // @@protoc_insertion_point(enum_value:VoiceAssistantTimerEvent.VOICE_ASSISTANT_TIMER_STARTED)
    VOICE_ASSISTANT_TIMER_STARTED = 0,
    // @@protoc_insertion_point(enum_value:VoiceAssistantTimerEvent.VOICE_ASSISTANT_TIMER_UPDATED)
    VOICE_ASSISTANT_TIMER_UPDATED = 1,
    // @@protoc_insertion_point(enum_value:VoiceAssistantTimerEvent.VOICE_ASSISTANT_TIMER_CANCELLED)
    VOICE_ASSISTANT_TIMER_CANCELLED = 2,
    // @@protoc_insertion_point(enum_value:VoiceAssistantTimerEvent.VOICE_ASSISTANT_TIMER_FINISHED)
    VOICE_ASSISTANT_TIMER_FINISHED = 3,
}

impl ::protobuf::Enum for VoiceAssistantTimerEvent {
    const NAME: &'static str = "VoiceAssistantTimerEvent";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<VoiceAssistantTimerEvent> {
        match value {
            0 => ::std::option::Option::Some(VoiceAssistantTimerEvent::VOICE_ASSISTANT_TIMER_STARTED),
            1 => ::std::option::Option::Some(VoiceAssistantTimerEvent::VOICE_ASSISTANT_TIMER_UPDATED),
            2 => ::std::option::Option::Some(VoiceAssistantTimerEvent::VOICE_ASSISTANT_TIMER_CANCELLED),
            3 => ::std::option::Option::Some(VoiceAssistantTimerEvent::VOICE_ASSISTANT_TIMER_FINISHED),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<VoiceAssistantTimerEvent> {
        match str {
            "VOICE_ASSISTANT_TIMER_STARTED" => ::std::option::Option::Some(VoiceAssistantTimerEvent::VOICE_ASSISTANT_TIMER_STARTED),
            "VOICE_ASSISTANT_TIMER_UPDATED" => ::std::option::Option::Some(VoiceAssistantTimerEvent::VOICE_ASSISTANT_TIMER_UPDATED),
            "VOICE_ASSISTANT_TIMER_CANCELLED" => ::std::option::Option::Some(VoiceAssistantTimerEvent::VOICE_ASSISTANT_TIMER_CANCELLED),
            "VOICE_ASSISTANT_TIMER_FINISHED" => ::std::option::Option::Some(VoiceAssistantTimerEvent::VOICE_ASSISTANT_TIMER_FINISHED),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [VoiceAssistantTimerEvent] = &[
        VoiceAssistantTimerEvent::VOICE_ASSISTANT_TIMER_STARTED,
        VoiceAssistantTimerEvent::VOICE_ASSISTANT_TIMER_UPDATED,
        VoiceAssistantTimerEvent::VOICE_ASSISTANT_TIMER_CANCELLED,
        VoiceAssistantTimerEvent::VOICE_ASSISTANT_TIMER_FINISHED,
    ];
}

impl ::protobuf::EnumFull for VoiceAssistantTimerEvent {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("VoiceAssistantTimerEvent").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = *self as usize;
        Self::enum_descriptor().value_by_index(index)
    }
}

impl ::std::default::Default for VoiceAssistantTimerEvent {
    fn default() -> Self {
        VoiceAssistantTimerEvent::VOICE_ASSISTANT_TIMER_STARTED
    }
}

impl VoiceAssistantTimerEvent {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<VoiceAssistantTimerEvent>("VoiceAssistantTimerEvent")
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:AlarmControlPanelState)
pub enum AlarmControlPanelState {
    // @@protoc_insertion_point(enum_value:AlarmControlPanelState.ALARM_STATE_DISARMED)
    ALARM_STATE_DISARMED = 0,
    // @@protoc_insertion_point(enum_value:AlarmControlPanelState.ALARM_STATE_ARMED_HOME)
    ALARM_STATE_ARMED_HOME = 1,
    // @@protoc_insertion_point(enum_value:AlarmControlPanelState.ALARM_STATE_ARMED_AWAY)
    ALARM_STATE_ARMED_AWAY = 2,
    // @@protoc_insertion_point(enum_value:AlarmControlPanelState.ALARM_STATE_ARMED_NIGHT)
    ALARM_STATE_ARMED_NIGHT = 3,
    // @@protoc_insertion_point(enum_value:AlarmControlPanelState.ALARM_STATE_ARMED_VACATION)
    ALARM_STATE_ARMED_VACATION = 4,
    // @@protoc_insertion_point(enum_value:AlarmControlPanelState.ALARM_STATE_ARMED_CUSTOM_BYPASS)
    ALARM_STATE_ARMED_CUSTOM_BYPASS = 5,
    // @@protoc_insertion_point(enum_value:AlarmControlPanelState.ALARM_STATE_PENDING)
    ALARM_STATE_PENDING = 6,
    // @@protoc_insertion_point(enum_value:AlarmControlPanelState.ALARM_STATE_ARMING)
    ALARM_STATE_ARMING = 7,
    // @@protoc_insertion_point(enum_value:AlarmControlPanelState.ALARM_STATE_DISARMING)
    ALARM_STATE_DISARMING = 8,
    // @@protoc_insertion_point(enum_value:AlarmControlPanelState.ALARM_STATE_TRIGGERED)
    ALARM_STATE_TRIGGERED = 9,
}

impl ::protobuf::Enum for AlarmControlPanelState {
    const NAME: &'static str = "AlarmControlPanelState";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<AlarmControlPanelState> {
        match value {
            0 => ::std::option::Option::Some(AlarmControlPanelState::ALARM_STATE_DISARMED),
            1 => ::std::option::Option::Some(AlarmControlPanelState::ALARM_STATE_ARMED_HOME),
            2 => ::std::option::Option::Some(AlarmControlPanelState::ALARM_STATE_ARMED_AWAY),
            3 => ::std::option::Option::Some(AlarmControlPanelState::ALARM_STATE_ARMED_NIGHT),
            4 => ::std::option::Option::Some(AlarmControlPanelState::ALARM_STATE_ARMED_VACATION),
            5 => ::std::option::Option::Some(AlarmControlPanelState::ALARM_STATE_ARMED_CUSTOM_BYPASS),
            6 => ::std::option::Option::Some(AlarmControlPanelState::ALARM_STATE_PENDING),
            7 => ::std::option::Option::Some(AlarmControlPanelState::ALARM_STATE_ARMING),
            8 => ::std::option::Option::Some(AlarmControlPanelState::ALARM_STATE_DISARMING),
            9 => ::std::option::Option::Some(AlarmControlPanelState::ALARM_STATE_TRIGGERED),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<AlarmControlPanelState> {
        match str {
            "ALARM_STATE_DISARMED" => ::std::option::Option::Some(AlarmControlPanelState::ALARM_STATE_DISARMED),
            "ALARM_STATE_ARMED_HOME" => ::std::option::Option::Some(AlarmControlPanelState::ALARM_STATE_ARMED_HOME),
            "ALARM_STATE_ARMED_AWAY" => ::std::option::Option::Some(AlarmControlPanelState::ALARM_STATE_ARMED_AWAY),
            "ALARM_STATE_ARMED_NIGHT" => ::std::option::Option::Some(AlarmControlPanelState::ALARM_STATE_ARMED_NIGHT),
            "ALARM_STATE_ARMED_VACATION" => ::std::option::Option::Some(AlarmControlPanelState::ALARM_STATE_ARMED_VACATION),
            "ALARM_STATE_ARMED_CUSTOM_BYPASS" => ::std::option::Option::Some(AlarmControlPanelState::ALARM_STATE_ARMED_CUSTOM_BYPASS),
            "ALARM_STATE_PENDING" => ::std::option::Option::Some(AlarmControlPanelState::ALARM_STATE_PENDING),
            "ALARM_STATE_ARMING" => ::std::option::Option::Some(AlarmControlPanelState::ALARM_STATE_ARMING),
            "ALARM_STATE_DISARMING" => ::std::option::Option::Some(AlarmControlPanelState::ALARM_STATE_DISARMING),
            "ALARM_STATE_TRIGGERED" => ::std::option::Option::Some(AlarmControlPanelState::ALARM_STATE_TRIGGERED),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [AlarmControlPanelState] = &[
        AlarmControlPanelState::ALARM_STATE_DISARMED,
        AlarmControlPanelState::ALARM_STATE_ARMED_HOME,
        AlarmControlPanelState::ALARM_STATE_ARMED_AWAY,
        AlarmControlPanelState::ALARM_STATE_ARMED_NIGHT,
        AlarmControlPanelState::ALARM_STATE_ARMED_VACATION,
        AlarmControlPanelState::ALARM_STATE_ARMED_CUSTOM_BYPASS,
        AlarmControlPanelState::ALARM_STATE_PENDING,
        AlarmControlPanelState::ALARM_STATE_ARMING,
        AlarmControlPanelState::ALARM_STATE_DISARMING,
        AlarmControlPanelState::ALARM_STATE_TRIGGERED,
    ];
}

impl ::protobuf::EnumFull for AlarmControlPanelState {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("AlarmControlPanelState").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = *self as usize;
        Self::enum_descriptor().value_by_index(index)
    }
}

impl ::std::default::Default for AlarmControlPanelState {
    fn default() -> Self {
        AlarmControlPanelState::ALARM_STATE_DISARMED
    }
}

impl AlarmControlPanelState {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<AlarmControlPanelState>("AlarmControlPanelState")
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:AlarmControlPanelStateCommand)
pub enum AlarmControlPanelStateCommand {
    // @@protoc_insertion_point(enum_value:AlarmControlPanelStateCommand.ALARM_CONTROL_PANEL_DISARM)
    ALARM_CONTROL_PANEL_DISARM = 0,
    // @@protoc_insertion_point(enum_value:AlarmControlPanelStateCommand.ALARM_CONTROL_PANEL_ARM_AWAY)
    ALARM_CONTROL_PANEL_ARM_AWAY = 1,
    // @@protoc_insertion_point(enum_value:AlarmControlPanelStateCommand.ALARM_CONTROL_PANEL_ARM_HOME)
    ALARM_CONTROL_PANEL_ARM_HOME = 2,
    // @@protoc_insertion_point(enum_value:AlarmControlPanelStateCommand.ALARM_CONTROL_PANEL_ARM_NIGHT)
    ALARM_CONTROL_PANEL_ARM_NIGHT = 3,
    // @@protoc_insertion_point(enum_value:AlarmControlPanelStateCommand.ALARM_CONTROL_PANEL_ARM_VACATION)
    ALARM_CONTROL_PANEL_ARM_VACATION = 4,
    // @@protoc_insertion_point(enum_value:AlarmControlPanelStateCommand.ALARM_CONTROL_PANEL_ARM_CUSTOM_BYPASS)
    ALARM_CONTROL_PANEL_ARM_CUSTOM_BYPASS = 5,
    // @@protoc_insertion_point(enum_value:AlarmControlPanelStateCommand.ALARM_CONTROL_PANEL_TRIGGER)
    ALARM_CONTROL_PANEL_TRIGGER = 6,
}

impl ::protobuf::Enum for AlarmControlPanelStateCommand {
    const NAME: &'static str = "AlarmControlPanelStateCommand";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<AlarmControlPanelStateCommand> {
        match value {
            0 => ::std::option::Option::Some(AlarmControlPanelStateCommand::ALARM_CONTROL_PANEL_DISARM),
            1 => ::std::option::Option::Some(AlarmControlPanelStateCommand::ALARM_CONTROL_PANEL_ARM_AWAY),
            2 => ::std::option::Option::Some(AlarmControlPanelStateCommand::ALARM_CONTROL_PANEL_ARM_HOME),
            3 => ::std::option::Option::Some(AlarmControlPanelStateCommand::ALARM_CONTROL_PANEL_ARM_NIGHT),
            4 => ::std::option::Option::Some(AlarmControlPanelStateCommand::ALARM_CONTROL_PANEL_ARM_VACATION),
            5 => ::std::option::Option::Some(AlarmControlPanelStateCommand::ALARM_CONTROL_PANEL_ARM_CUSTOM_BYPASS),
            6 => ::std::option::Option::Some(AlarmControlPanelStateCommand::ALARM_CONTROL_PANEL_TRIGGER),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<AlarmControlPanelStateCommand> {
        match str {
            "ALARM_CONTROL_PANEL_DISARM" => ::std::option::Option::Some(AlarmControlPanelStateCommand::ALARM_CONTROL_PANEL_DISARM),
            "ALARM_CONTROL_PANEL_ARM_AWAY" => ::std::option::Option::Some(AlarmControlPanelStateCommand::ALARM_CONTROL_PANEL_ARM_AWAY),
            "ALARM_CONTROL_PANEL_ARM_HOME" => ::std::option::Option::Some(AlarmControlPanelStateCommand::ALARM_CONTROL_PANEL_ARM_HOME),
            "ALARM_CONTROL_PANEL_ARM_NIGHT" => ::std::option::Option::Some(AlarmControlPanelStateCommand::ALARM_CONTROL_PANEL_ARM_NIGHT),
            "ALARM_CONTROL_PANEL_ARM_VACATION" => ::std::option::Option::Some(AlarmControlPanelStateCommand::ALARM_CONTROL_PANEL_ARM_VACATION),
            "ALARM_CONTROL_PANEL_ARM_CUSTOM_BYPASS" => ::std::option::Option::Some(AlarmControlPanelStateCommand::ALARM_CONTROL_PANEL_ARM_CUSTOM_BYPASS),
            "ALARM_CONTROL_PANEL_TRIGGER" => ::std::option::Option::Some(AlarmControlPanelStateCommand::ALARM_CONTROL_PANEL_TRIGGER),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [AlarmControlPanelStateCommand] = &[
        AlarmControlPanelStateCommand::ALARM_CONTROL_PANEL_DISARM,
        AlarmControlPanelStateCommand::ALARM_CONTROL_PANEL_ARM_AWAY,
        AlarmControlPanelStateCommand::ALARM_CONTROL_PANEL_ARM_HOME,
        AlarmControlPanelStateCommand::ALARM_CONTROL_PANEL_ARM_NIGHT,
        AlarmControlPanelStateCommand::ALARM_CONTROL_PANEL_ARM_VACATION,
        AlarmControlPanelStateCommand::ALARM_CONTROL_PANEL_ARM_CUSTOM_BYPASS,
        AlarmControlPanelStateCommand::ALARM_CONTROL_PANEL_TRIGGER,
    ];
}

impl ::protobuf::EnumFull for AlarmControlPanelStateCommand {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("AlarmControlPanelStateCommand").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = *self as usize;
        Self::enum_descriptor().value_by_index(index)
    }
}

impl ::std::default::Default for AlarmControlPanelStateCommand {
    fn default() -> Self {
        AlarmControlPanelStateCommand::ALARM_CONTROL_PANEL_DISARM
    }
}

impl AlarmControlPanelStateCommand {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<AlarmControlPanelStateCommand>("AlarmControlPanelStateCommand")
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:TextMode)
pub enum TextMode {
    // @@protoc_insertion_point(enum_value:TextMode.TEXT_MODE_TEXT)
    TEXT_MODE_TEXT = 0,
    // @@protoc_insertion_point(enum_value:TextMode.TEXT_MODE_PASSWORD)
    TEXT_MODE_PASSWORD = 1,
}

impl ::protobuf::Enum for TextMode {
    const NAME: &'static str = "TextMode";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<TextMode> {
        match value {
            0 => ::std::option::Option::Some(TextMode::TEXT_MODE_TEXT),
            1 => ::std::option::Option::Some(TextMode::TEXT_MODE_PASSWORD),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<TextMode> {
        match str {
            "TEXT_MODE_TEXT" => ::std::option::Option::Some(TextMode::TEXT_MODE_TEXT),
            "TEXT_MODE_PASSWORD" => ::std::option::Option::Some(TextMode::TEXT_MODE_PASSWORD),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [TextMode] = &[
        TextMode::TEXT_MODE_TEXT,
        TextMode::TEXT_MODE_PASSWORD,
    ];
}

impl ::protobuf::EnumFull for TextMode {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("TextMode").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = *self as usize;
        Self::enum_descriptor().value_by_index(index)
    }
}

impl ::std::default::Default for TextMode {
    fn default() -> Self {
        TextMode::TEXT_MODE_TEXT
    }
}

impl TextMode {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<TextMode>("TextMode")
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:ValveOperation)
pub enum ValveOperation {
    // @@protoc_insertion_point(enum_value:ValveOperation.VALVE_OPERATION_IDLE)
    VALVE_OPERATION_IDLE = 0,
    // @@protoc_insertion_point(enum_value:ValveOperation.VALVE_OPERATION_IS_OPENING)
    VALVE_OPERATION_IS_OPENING = 1,
    // @@protoc_insertion_point(enum_value:ValveOperation.VALVE_OPERATION_IS_CLOSING)
    VALVE_OPERATION_IS_CLOSING = 2,
}

impl ::protobuf::Enum for ValveOperation {
    const NAME: &'static str = "ValveOperation";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<ValveOperation> {
        match value {
            0 => ::std::option::Option::Some(ValveOperation::VALVE_OPERATION_IDLE),
            1 => ::std::option::Option::Some(ValveOperation::VALVE_OPERATION_IS_OPENING),
            2 => ::std::option::Option::Some(ValveOperation::VALVE_OPERATION_IS_CLOSING),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<ValveOperation> {
        match str {
            "VALVE_OPERATION_IDLE" => ::std::option::Option::Some(ValveOperation::VALVE_OPERATION_IDLE),
            "VALVE_OPERATION_IS_OPENING" => ::std::option::Option::Some(ValveOperation::VALVE_OPERATION_IS_OPENING),
            "VALVE_OPERATION_IS_CLOSING" => ::std::option::Option::Some(ValveOperation::VALVE_OPERATION_IS_CLOSING),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [ValveOperation] = &[
        ValveOperation::VALVE_OPERATION_IDLE,
        ValveOperation::VALVE_OPERATION_IS_OPENING,
        ValveOperation::VALVE_OPERATION_IS_CLOSING,
    ];
}

impl ::protobuf::EnumFull for ValveOperation {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("ValveOperation").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = *self as usize;
        Self::enum_descriptor().value_by_index(index)
    }
}

impl ::std::default::Default for ValveOperation {
    fn default() -> Self {
        ValveOperation::VALVE_OPERATION_IDLE
    }
}

impl ValveOperation {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<ValveOperation>("ValveOperation")
    }
}

#[derive(Clone,Copy,PartialEq,Eq,Debug,Hash)]
// @@protoc_insertion_point(enum:UpdateCommand)
pub enum UpdateCommand {
    // @@protoc_insertion_point(enum_value:UpdateCommand.UPDATE_COMMAND_NONE)
    UPDATE_COMMAND_NONE = 0,
    // @@protoc_insertion_point(enum_value:UpdateCommand.UPDATE_COMMAND_UPDATE)
    UPDATE_COMMAND_UPDATE = 1,
    // @@protoc_insertion_point(enum_value:UpdateCommand.UPDATE_COMMAND_CHECK)
    UPDATE_COMMAND_CHECK = 2,
}

impl ::protobuf::Enum for UpdateCommand {
    const NAME: &'static str = "UpdateCommand";

    fn value(&self) -> i32 {
        *self as i32
    }

    fn from_i32(value: i32) -> ::std::option::Option<UpdateCommand> {
        match value {
            0 => ::std::option::Option::Some(UpdateCommand::UPDATE_COMMAND_NONE),
            1 => ::std::option::Option::Some(UpdateCommand::UPDATE_COMMAND_UPDATE),
            2 => ::std::option::Option::Some(UpdateCommand::UPDATE_COMMAND_CHECK),
            _ => ::std::option::Option::None
        }
    }

    fn from_str(str: &str) -> ::std::option::Option<UpdateCommand> {
        match str {
            "UPDATE_COMMAND_NONE" => ::std::option::Option::Some(UpdateCommand::UPDATE_COMMAND_NONE),
            "UPDATE_COMMAND_UPDATE" => ::std::option::Option::Some(UpdateCommand::UPDATE_COMMAND_UPDATE),
            "UPDATE_COMMAND_CHECK" => ::std::option::Option::Some(UpdateCommand::UPDATE_COMMAND_CHECK),
            _ => ::std::option::Option::None
        }
    }

    const VALUES: &'static [UpdateCommand] = &[
        UpdateCommand::UPDATE_COMMAND_NONE,
        UpdateCommand::UPDATE_COMMAND_UPDATE,
        UpdateCommand::UPDATE_COMMAND_CHECK,
    ];
}

impl ::protobuf::EnumFull for UpdateCommand {
    fn enum_descriptor() -> ::protobuf::reflect::EnumDescriptor {
        static descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::EnumDescriptor> = ::protobuf::rt::Lazy::new();
        descriptor.get(|| file_descriptor().enum_by_package_relative_name("UpdateCommand").unwrap()).clone()
    }

    fn descriptor(&self) -> ::protobuf::reflect::EnumValueDescriptor {
        let index = *self as usize;
        Self::enum_descriptor().value_by_index(index)
    }
}

impl ::std::default::Default for UpdateCommand {
    fn default() -> Self {
        UpdateCommand::UPDATE_COMMAND_NONE
    }
}

impl UpdateCommand {
    fn generated_enum_descriptor_data() -> ::protobuf::reflect::GeneratedEnumDescriptorData {
        ::protobuf::reflect::GeneratedEnumDescriptorData::new::<UpdateCommand>("UpdateCommand")
    }
}

static file_descriptor_proto_data: &'static [u8] = b"\
    \n\tapi.proto\x1a\x11api_options.proto\"\x92\x01\n\x0cHelloRequest\x12\
    \x1f\n\x0bclient_info\x18\x01\x20\x01(\tR\nclientInfo\x12*\n\x11api_vers\
    ion_major\x18\x02\x20\x01(\rR\x0fapiVersionMajor\x12*\n\x11api_version_m\
    inor\x18\x03\x20\x01(\rR\x0fapiVersionMinor:\t\x80A\x01\xe0@\x01\xe8@\
    \x02\"\xa7\x01\n\rHelloResponse\x12*\n\x11api_version_major\x18\x01\x20\
    \x01(\rR\x0fapiVersionMajor\x12*\n\x11api_version_minor\x18\x02\x20\x01(\
    \rR\x0fapiVersionMinor\x12\x1f\n\x0bserver_info\x18\x03\x20\x01(\tR\nser\
    verInfo\x12\x12\n\x04name\x18\x04\x20\x01(\tR\x04name:\t\x80A\x01\xe0@\
    \x02\xe8@\x01\"7\n\x0eConnectRequest\x12\x1a\n\x08password\x18\x01\x20\
    \x01(\tR\x08password:\t\x80A\x01\xe0@\x03\xe8@\x02\"G\n\x0fConnectRespon\
    se\x12)\n\x10invalid_password\x18\x01\x20\x01(\x08R\x0finvalidPassword:\
    \t\x80A\x01\xe0@\x04\xe8@\x01\"\x1e\n\x11DisconnectRequest:\t\x80A\x01\
    \xe0@\x05\xe8@\0\"\x1f\n\x12DisconnectResponse:\t\x80A\x01\xe0@\x06\xe8@\
    \0\"\x15\n\x0bPingRequest:\x06\xe0@\x07\xe8@\0\"\x16\n\x0cPingResponse:\
    \x06\xe0@\x08\xe8@\0\"\x1b\n\x11DeviceInfoRequest:\x06\xe0@\t\xe8@\x02\"\
    7\n\x08AreaInfo\x12\x17\n\x07area_id\x18\x01\x20\x01(\rR\x06areaId\x12\
    \x12\n\x04name\x18\x02\x20\x01(\tR\x04name\"V\n\nDeviceInfo\x12\x1b\n\td\
    evice_id\x18\x01\x20\x01(\rR\x08deviceId\x12\x12\n\x04name\x18\x02\x20\
    \x01(\tR\x04name\x12\x17\n\x07area_id\x18\x03\x20\x01(\rR\x06areaId\"\
    \xce\x07\n\x12DeviceInfoResponse\x12#\n\ruses_password\x18\x01\x20\x01(\
    \x08R\x0cusesPassword\x12\x12\n\x04name\x18\x02\x20\x01(\tR\x04name\x12\
    \x1f\n\x0bmac_address\x18\x03\x20\x01(\tR\nmacAddress\x12'\n\x0fesphome_\
    version\x18\x04\x20\x01(\tR\x0eesphomeVersion\x12)\n\x10compilation_time\
    \x18\x05\x20\x01(\tR\x0fcompilationTime\x12\x14\n\x05model\x18\x06\x20\
    \x01(\tR\x05model\x12$\n\x0ehas_deep_sleep\x18\x07\x20\x01(\x08R\x0chasD\
    eepSleep\x12!\n\x0cproject_name\x18\x08\x20\x01(\tR\x0bprojectName\x12'\
    \n\x0fproject_version\x18\t\x20\x01(\tR\x0eprojectVersion\x12%\n\x0ewebs\
    erver_port\x18\n\x20\x01(\rR\rwebserverPort\x12C\n\x1elegacy_bluetooth_p\
    roxy_version\x18\x0b\x20\x01(\rR\x1blegacyBluetoothProxyVersion\x12A\n\
    \x1dbluetooth_proxy_feature_flags\x18\x0f\x20\x01(\rR\x1abluetoothProxyF\
    eatureFlags\x12\"\n\x0cmanufacturer\x18\x0c\x20\x01(\tR\x0cmanufacturer\
    \x12#\n\rfriendly_name\x18\r\x20\x01(\tR\x0cfriendlyName\x12C\n\x1elegac\
    y_voice_assistant_version\x18\x0e\x20\x01(\rR\x1blegacyVoiceAssistantVer\
    sion\x12A\n\x1dvoice_assistant_feature_flags\x18\x11\x20\x01(\rR\x1avoic\
    eAssistantFeatureFlags\x12%\n\x0esuggested_area\x18\x10\x20\x01(\tR\rsug\
    gestedArea\x122\n\x15bluetooth_mac_address\x18\x12\x20\x01(\tR\x13blueto\
    othMacAddress\x128\n\x18api_encryption_supported\x18\x13\x20\x01(\x08R\
    \x16apiEncryptionSupported\x12%\n\x07devices\x18\x14\x20\x03(\x0b2\x0b.D\
    eviceInfoR\x07devices\x12\x1f\n\x05areas\x18\x15\x20\x03(\x0b2\t.AreaInf\
    oR\x05areas\x12\x1d\n\x04area\x18\x16\x20\x01(\x0b2\t.AreaInfoR\x04area:\
    \x06\xe0@\n\xe8@\x01\"\x1d\n\x13ListEntitiesRequest:\x06\xe0@\x0b\xe8@\
    \x02\"%\n\x18ListEntitiesDoneResponse:\t\x80A\x01\xe0@\x13\xe8@\x01\"\
    \x20\n\x16SubscribeStatesRequest:\x06\xe0@\x14\xe8@\x02\"\xae\x03\n\x20L\
    istEntitiesBinarySensorResponse\x12\x1b\n\tobject_id\x18\x01\x20\x01(\tR\
    \x08objectId\x12\x10\n\x03key\x18\x02\x20\x01(\x07R\x03key\x12\x12\n\x04\
    name\x18\x03\x20\x01(\tR\x04name\x12\x1b\n\tunique_id\x18\x04\x20\x01(\t\
    R\x08uniqueId\x12!\n\x0cdevice_class\x18\x05\x20\x01(\tR\x0bdeviceClass\
    \x125\n\x17is_status_binary_sensor\x18\x06\x20\x01(\x08R\x14isStatusBina\
    rySensor\x12.\n\x13disabled_by_default\x18\x07\x20\x01(\x08R\x11disabled\
    ByDefault\x12\x12\n\x04icon\x18\x08\x20\x01(\tR\x04icon\x128\n\x0fentity\
    _category\x18\t\x20\x01(\x0e2\x0f.EntityCategoryR\x0eentityCategory\x12\
    \x1b\n\tdevice_id\x18\n\x20\x01(\rR\x08deviceId:5\x8aA\x18InfoResponsePr\
    otoMessage\xf2@\x11USE_BINARY_SENSOR\xe0@\x0c\xe8@\x01\"\xc0\x01\n\x19Bi\
    narySensorStateResponse\x12\x10\n\x03key\x18\x01\x20\x01(\x07R\x03key\
    \x12\x14\n\x05state\x18\x02\x20\x01(\x08R\x05state\x12#\n\rmissing_state\
    \x18\x03\x20\x01(\x08R\x0cmissingState\x12\x1b\n\tdevice_id\x18\x04\x20\
    \x01(\rR\x08deviceId:9\x8aA\x19StateResponseProtoMessage\x80A\x01\xf2@\
    \x11USE_BINARY_SENSOR\xe0@\x15\xe8@\x01\"\x84\x04\n\x19ListEntitiesCover\
    Response\x12\x1b\n\tobject_id\x18\x01\x20\x01(\tR\x08objectId\x12\x10\n\
    \x03key\x18\x02\x20\x01(\x07R\x03key\x12\x12\n\x04name\x18\x03\x20\x01(\
    \tR\x04name\x12\x1b\n\tunique_id\x18\x04\x20\x01(\tR\x08uniqueId\x12#\n\
    \rassumed_state\x18\x05\x20\x01(\x08R\x0cassumedState\x12+\n\x11supports\
    _position\x18\x06\x20\x01(\x08R\x10supportsPosition\x12#\n\rsupports_til\
    t\x18\x07\x20\x01(\x08R\x0csupportsTilt\x12!\n\x0cdevice_class\x18\x08\
    \x20\x01(\tR\x0bdeviceClass\x12.\n\x13disabled_by_default\x18\t\x20\x01(\
    \x08R\x11disabledByDefault\x12\x12\n\x04icon\x18\n\x20\x01(\tR\x04icon\
    \x128\n\x0fentity_category\x18\x0b\x20\x01(\x0e2\x0f.EntityCategoryR\x0e\
    entityCategory\x12#\n\rsupports_stop\x18\x0c\x20\x01(\x08R\x0csupportsSt\
    op\x12\x1b\n\tdevice_id\x18\r\x20\x01(\rR\x08deviceId:-\x8aA\x18InfoResp\
    onseProtoMessage\xf2@\tUSE_COVER\xe0@\r\xe8@\x01\"\x9a\x02\n\x12CoverSta\
    teResponse\x12\x10\n\x03key\x18\x01\x20\x01(\x07R\x03key\x124\n\x0clegac\
    y_state\x18\x02\x20\x01(\x0e2\x11.LegacyCoverStateR\x0blegacyState\x12\
    \x1a\n\x08position\x18\x03\x20\x01(\x02R\x08position\x12\x12\n\x04tilt\
    \x18\x04\x20\x01(\x02R\x04tilt\x12<\n\x11current_operation\x18\x05\x20\
    \x01(\x0e2\x0f.CoverOperationR\x10currentOperation\x12\x1b\n\tdevice_id\
    \x18\x06\x20\x01(\rR\x08deviceId:1\x8aA\x19StateResponseProtoMessage\x80\
    A\x01\xf2@\tUSE_COVER\xe0@\x16\xe8@\x01\"\xdd\x02\n\x13CoverCommandReque\
    st\x12\x10\n\x03key\x18\x01\x20\x01(\x07R\x03key\x12,\n\x12has_legacy_co\
    mmand\x18\x02\x20\x01(\x08R\x10hasLegacyCommand\x12:\n\x0elegacy_command\
    \x18\x03\x20\x01(\x0e2\x13.LegacyCoverCommandR\rlegacyCommand\x12!\n\x0c\
    has_position\x18\x04\x20\x01(\x08R\x0bhasPosition\x12\x1a\n\x08position\
    \x18\x05\x20\x01(\x02R\x08position\x12\x19\n\x08has_tilt\x18\x06\x20\x01\
    (\x08R\x07hasTilt\x12\x12\n\x04tilt\x18\x07\x20\x01(\x02R\x04tilt\x12\
    \x12\n\x04stop\x18\x08\x20\x01(\x08R\x04stop\x12\x1b\n\tdevice_id\x18\t\
    \x20\x01(\rR\x08deviceId:+\x8aA\x13CommandProtoMessage\x80A\x01\xf2@\tUS\
    E_COVER\xe0@\x1e\xe8@\x02\"\xb4\x04\n\x17ListEntitiesFanResponse\x12\x1b\
    \n\tobject_id\x18\x01\x20\x01(\tR\x08objectId\x12\x10\n\x03key\x18\x02\
    \x20\x01(\x07R\x03key\x12\x12\n\x04name\x18\x03\x20\x01(\tR\x04name\x12\
    \x1b\n\tunique_id\x18\x04\x20\x01(\tR\x08uniqueId\x121\n\x14supports_osc\
    illation\x18\x05\x20\x01(\x08R\x13supportsOscillation\x12%\n\x0esupports\
    _speed\x18\x06\x20\x01(\x08R\rsupportsSpeed\x12-\n\x12supports_direction\
    \x18\x07\x20\x01(\x08R\x11supportsDirection\x122\n\x15supported_speed_co\
    unt\x18\x08\x20\x01(\x05R\x13supportedSpeedCount\x12.\n\x13disabled_by_d\
    efault\x18\t\x20\x01(\x08R\x11disabledByDefault\x12\x12\n\x04icon\x18\n\
    \x20\x01(\tR\x04icon\x128\n\x0fentity_category\x18\x0b\x20\x01(\x0e2\x0f\
    .EntityCategoryR\x0eentityCategory\x124\n\x16supported_preset_modes\x18\
    \x0c\x20\x03(\tR\x14supportedPresetModes\x12\x1b\n\tdevice_id\x18\r\x20\
    \x01(\rR\x08deviceId:+\x8aA\x18InfoResponseProtoMessage\xf2@\x07USE_FAN\
    \xe0@\x0e\xe8@\x01\"\xbe\x02\n\x10FanStateResponse\x12\x10\n\x03key\x18\
    \x01\x20\x01(\x07R\x03key\x12\x14\n\x05state\x18\x02\x20\x01(\x08R\x05st\
    ate\x12\x20\n\x0boscillating\x18\x03\x20\x01(\x08R\x0boscillating\x12#\n\
    \x05speed\x18\x04\x20\x01(\x0e2\t.FanSpeedR\x05speedB\x02\x18\x01\x12+\n\
    \tdirection\x18\x05\x20\x01(\x0e2\r.FanDirectionR\tdirection\x12\x1f\n\
    \x0bspeed_level\x18\x06\x20\x01(\x05R\nspeedLevel\x12\x1f\n\x0bpreset_mo\
    de\x18\x07\x20\x01(\tR\npresetMode\x12\x1b\n\tdevice_id\x18\x08\x20\x01(\
    \rR\x08deviceId:/\x8aA\x19StateResponseProtoMessage\x80A\x01\xf2@\x07USE\
    _FAN\xe0@\x17\xe8@\x01\"\x95\x04\n\x11FanCommandRequest\x12\x10\n\x03key\
    \x18\x01\x20\x01(\x07R\x03key\x12\x1b\n\thas_state\x18\x02\x20\x01(\x08R\
    \x08hasState\x12\x14\n\x05state\x18\x03\x20\x01(\x08R\x05state\x12\x1f\n\
    \thas_speed\x18\x04\x20\x01(\x08R\x08hasSpeedB\x02\x18\x01\x12#\n\x05spe\
    ed\x18\x05\x20\x01(\x0e2\t.FanSpeedR\x05speedB\x02\x18\x01\x12'\n\x0fhas\
    _oscillating\x18\x06\x20\x01(\x08R\x0ehasOscillating\x12\x20\n\x0boscill\
    ating\x18\x07\x20\x01(\x08R\x0boscillating\x12#\n\rhas_direction\x18\x08\
    \x20\x01(\x08R\x0chasDirection\x12+\n\tdirection\x18\t\x20\x01(\x0e2\r.F\
    anDirectionR\tdirection\x12&\n\x0fhas_speed_level\x18\n\x20\x01(\x08R\rh\
    asSpeedLevel\x12\x1f\n\x0bspeed_level\x18\x0b\x20\x01(\x05R\nspeedLevel\
    \x12&\n\x0fhas_preset_mode\x18\x0c\x20\x01(\x08R\rhasPresetMode\x12\x1f\
    \n\x0bpreset_mode\x18\r\x20\x01(\tR\npresetMode\x12\x1b\n\tdevice_id\x18\
    \x0e\x20\x01(\rR\x08deviceId:)\x8aA\x13CommandProtoMessage\x80A\x01\xf2@\
    \x07USE_FAN\xe0@\x1f\xe8@\x02\"\xe5\x05\n\x19ListEntitiesLightResponse\
    \x12\x1b\n\tobject_id\x18\x01\x20\x01(\tR\x08objectId\x12\x10\n\x03key\
    \x18\x02\x20\x01(\x07R\x03key\x12\x12\n\x04name\x18\x03\x20\x01(\tR\x04n\
    ame\x12\x1b\n\tunique_id\x18\x04\x20\x01(\tR\x08uniqueId\x12>\n\x15suppo\
    rted_color_modes\x18\x0c\x20\x03(\x0e2\n.ColorModeR\x13supportedColorMod\
    es\x12@\n\x1alegacy_supports_brightness\x18\x05\x20\x01(\x08R\x18legacyS\
    upportsBrightnessB\x02\x18\x01\x122\n\x13legacy_supports_rgb\x18\x06\x20\
    \x01(\x08R\x11legacySupportsRgbB\x02\x18\x01\x12A\n\x1blegacy_supports_w\
    hite_value\x18\x07\x20\x01(\x08R\x18legacySupportsWhiteValueB\x02\x18\
    \x01\x12M\n!legacy_supports_color_temperature\x18\x08\x20\x01(\x08R\x1el\
    egacySupportsColorTemperatureB\x02\x18\x01\x12\x1d\n\nmin_mireds\x18\t\
    \x20\x01(\x02R\tminMireds\x12\x1d\n\nmax_mireds\x18\n\x20\x01(\x02R\tmax\
    Mireds\x12\x18\n\x07effects\x18\x0b\x20\x03(\tR\x07effects\x12.\n\x13dis\
    abled_by_default\x18\r\x20\x01(\x08R\x11disabledByDefault\x12\x12\n\x04i\
    con\x18\x0e\x20\x01(\tR\x04icon\x128\n\x0fentity_category\x18\x0f\x20\
    \x01(\x0e2\x0f.EntityCategoryR\x0eentityCategory\x12\x1b\n\tdevice_id\
    \x18\x10\x20\x01(\rR\x08deviceId:-\x8aA\x18InfoResponseProtoMessage\xf2@\
    \tUSE_LIGHT\xe0@\x0f\xe8@\x01\"\xd7\x03\n\x12LightStateResponse\x12\x10\
    \n\x03key\x18\x01\x20\x01(\x07R\x03key\x12\x14\n\x05state\x18\x02\x20\
    \x01(\x08R\x05state\x12\x1e\n\nbrightness\x18\x03\x20\x01(\x02R\nbrightn\
    ess\x12)\n\ncolor_mode\x18\x0b\x20\x01(\x0e2\n.ColorModeR\tcolorMode\x12\
    )\n\x10color_brightness\x18\n\x20\x01(\x02R\x0fcolorBrightness\x12\x10\n\
    \x03red\x18\x04\x20\x01(\x02R\x03red\x12\x14\n\x05green\x18\x05\x20\x01(\
    \x02R\x05green\x12\x12\n\x04blue\x18\x06\x20\x01(\x02R\x04blue\x12\x14\n\
    \x05white\x18\x07\x20\x01(\x02R\x05white\x12+\n\x11color_temperature\x18\
    \x08\x20\x01(\x02R\x10colorTemperature\x12\x1d\n\ncold_white\x18\x0c\x20\
    \x01(\x02R\tcoldWhite\x12\x1d\n\nwarm_white\x18\r\x20\x01(\x02R\twarmWhi\
    te\x12\x16\n\x06effect\x18\t\x20\x01(\tR\x06effect\x12\x1b\n\tdevice_id\
    \x18\x0e\x20\x01(\rR\x08deviceId:1\x8aA\x19StateResponseProtoMessage\x80\
    A\x01\xf2@\tUSE_LIGHT\xe0@\x18\xe8@\x01\"\xf1\x07\n\x13LightCommandReque\
    st\x12\x10\n\x03key\x18\x01\x20\x01(\x07R\x03key\x12\x1b\n\thas_state\
    \x18\x02\x20\x01(\x08R\x08hasState\x12\x14\n\x05state\x18\x03\x20\x01(\
    \x08R\x05state\x12%\n\x0ehas_brightness\x18\x04\x20\x01(\x08R\rhasBright\
    ness\x12\x1e\n\nbrightness\x18\x05\x20\x01(\x02R\nbrightness\x12$\n\x0eh\
    as_color_mode\x18\x16\x20\x01(\x08R\x0chasColorMode\x12)\n\ncolor_mode\
    \x18\x17\x20\x01(\x0e2\n.ColorModeR\tcolorMode\x120\n\x14has_color_brigh\
    tness\x18\x14\x20\x01(\x08R\x12hasColorBrightness\x12)\n\x10color_bright\
    ness\x18\x15\x20\x01(\x02R\x0fcolorBrightness\x12\x17\n\x07has_rgb\x18\
    \x06\x20\x01(\x08R\x06hasRgb\x12\x10\n\x03red\x18\x07\x20\x01(\x02R\x03r\
    ed\x12\x14\n\x05green\x18\x08\x20\x01(\x02R\x05green\x12\x12\n\x04blue\
    \x18\t\x20\x01(\x02R\x04blue\x12\x1b\n\thas_white\x18\n\x20\x01(\x08R\
    \x08hasWhite\x12\x14\n\x05white\x18\x0b\x20\x01(\x02R\x05white\x122\n\
    \x15has_color_temperature\x18\x0c\x20\x01(\x08R\x13hasColorTemperature\
    \x12+\n\x11color_temperature\x18\r\x20\x01(\x02R\x10colorTemperature\x12\
    $\n\x0ehas_cold_white\x18\x18\x20\x01(\x08R\x0chasColdWhite\x12\x1d\n\nc\
    old_white\x18\x19\x20\x01(\x02R\tcoldWhite\x12$\n\x0ehas_warm_white\x18\
    \x1a\x20\x01(\x08R\x0chasWarmWhite\x12\x1d\n\nwarm_white\x18\x1b\x20\x01\
    (\x02R\twarmWhite\x122\n\x15has_transition_length\x18\x0e\x20\x01(\x08R\
    \x13hasTransitionLength\x12+\n\x11transition_length\x18\x0f\x20\x01(\rR\
    \x10transitionLength\x12(\n\x10has_flash_length\x18\x10\x20\x01(\x08R\
    \x0ehasFlashLength\x12!\n\x0cflash_length\x18\x11\x20\x01(\rR\x0bflashLe\
    ngth\x12\x1d\n\nhas_effect\x18\x12\x20\x01(\x08R\thasEffect\x12\x16\n\
    \x06effect\x18\x13\x20\x01(\tR\x06effect\x12\x1b\n\tdevice_id\x18\x1c\
    \x20\x01(\rR\x08deviceId:+\x8aA\x13CommandProtoMessage\x80A\x01\xf2@\tUS\
    E_LIGHT\xe0@\x20\xe8@\x02\"\xe9\x04\n\x1aListEntitiesSensorResponse\x12\
    \x1b\n\tobject_id\x18\x01\x20\x01(\tR\x08objectId\x12\x10\n\x03key\x18\
    \x02\x20\x01(\x07R\x03key\x12\x12\n\x04name\x18\x03\x20\x01(\tR\x04name\
    \x12\x1b\n\tunique_id\x18\x04\x20\x01(\tR\x08uniqueId\x12\x12\n\x04icon\
    \x18\x05\x20\x01(\tR\x04icon\x12.\n\x13unit_of_measurement\x18\x06\x20\
    \x01(\tR\x11unitOfMeasurement\x12+\n\x11accuracy_decimals\x18\x07\x20\
    \x01(\x05R\x10accuracyDecimals\x12!\n\x0cforce_update\x18\x08\x20\x01(\
    \x08R\x0bforceUpdate\x12!\n\x0cdevice_class\x18\t\x20\x01(\tR\x0bdeviceC\
    lass\x122\n\x0bstate_class\x18\n\x20\x01(\x0e2\x11.SensorStateClassR\nst\
    ateClass\x12I\n\x16legacy_last_reset_type\x18\x0b\x20\x01(\x0e2\x14.Sens\
    orLastResetTypeR\x13legacyLastResetType\x12.\n\x13disabled_by_default\
    \x18\x0c\x20\x01(\x08R\x11disabledByDefault\x128\n\x0fentity_category\
    \x18\r\x20\x01(\x0e2\x0f.EntityCategoryR\x0eentityCategory\x12\x1b\n\tde\
    vice_id\x18\x0e\x20\x01(\rR\x08deviceId:.\x8aA\x18InfoResponseProtoMessa\
    ge\xf2@\nUSE_SENSOR\xe0@\x10\xe8@\x01\"\xb3\x01\n\x13SensorStateResponse\
    \x12\x10\n\x03key\x18\x01\x20\x01(\x07R\x03key\x12\x14\n\x05state\x18\
    \x02\x20\x01(\x02R\x05state\x12#\n\rmissing_state\x18\x03\x20\x01(\x08R\
    \x0cmissingState\x12\x1b\n\tdevice_id\x18\x04\x20\x01(\rR\x08deviceId:2\
    \x8aA\x19StateResponseProtoMessage\x80A\x01\xf2@\nUSE_SENSOR\xe0@\x19\
    \xe8@\x01\"\x8f\x03\n\x1aListEntitiesSwitchResponse\x12\x1b\n\tobject_id\
    \x18\x01\x20\x01(\tR\x08objectId\x12\x10\n\x03key\x18\x02\x20\x01(\x07R\
    \x03key\x12\x12\n\x04name\x18\x03\x20\x01(\tR\x04name\x12\x1b\n\tunique_\
    id\x18\x04\x20\x01(\tR\x08uniqueId\x12\x12\n\x04icon\x18\x05\x20\x01(\tR\
    \x04icon\x12#\n\rassumed_state\x18\x06\x20\x01(\x08R\x0cassumedState\x12\
    .\n\x13disabled_by_default\x18\x07\x20\x01(\x08R\x11disabledByDefault\
    \x128\n\x0fentity_category\x18\x08\x20\x01(\x0e2\x0f.EntityCategoryR\x0e\
    entityCategory\x12!\n\x0cdevice_class\x18\t\x20\x01(\tR\x0bdeviceClass\
    \x12\x1b\n\tdevice_id\x18\n\x20\x01(\rR\x08deviceId:.\x8aA\x18InfoRespon\
    seProtoMessage\xf2@\nUSE_SWITCH\xe0@\x11\xe8@\x01\"\x8e\x01\n\x13SwitchS\
    tateResponse\x12\x10\n\x03key\x18\x01\x20\x01(\x07R\x03key\x12\x14\n\x05\
    state\x18\x02\x20\x01(\x08R\x05state\x12\x1b\n\tdevice_id\x18\x03\x20\
    \x01(\rR\x08deviceId:2\x8aA\x19StateResponseProtoMessage\x80A\x01\xf2@\n\
    USE_SWITCH\xe0@\x1a\xe8@\x01\"\x89\x01\n\x14SwitchCommandRequest\x12\x10\
    \n\x03key\x18\x01\x20\x01(\x07R\x03key\x12\x14\n\x05state\x18\x02\x20\
    \x01(\x08R\x05state\x12\x1b\n\tdevice_id\x18\x03\x20\x01(\rR\x08deviceId\
    :,\x8aA\x13CommandProtoMessage\x80A\x01\xf2@\nUSE_SWITCH\xe0@!\xe8@\x02\
    \"\xf3\x02\n\x1eListEntitiesTextSensorResponse\x12\x1b\n\tobject_id\x18\
    \x01\x20\x01(\tR\x08objectId\x12\x10\n\x03key\x18\x02\x20\x01(\x07R\x03k\
    ey\x12\x12\n\x04name\x18\x03\x20\x01(\tR\x04name\x12\x1b\n\tunique_id\
    \x18\x04\x20\x01(\tR\x08uniqueId\x12\x12\n\x04icon\x18\x05\x20\x01(\tR\
    \x04icon\x12.\n\x13disabled_by_default\x18\x06\x20\x01(\x08R\x11disabled\
    ByDefault\x128\n\x0fentity_category\x18\x07\x20\x01(\x0e2\x0f.EntityCate\
    goryR\x0eentityCategory\x12!\n\x0cdevice_class\x18\x08\x20\x01(\tR\x0bde\
    viceClass\x12\x1b\n\tdevice_id\x18\t\x20\x01(\rR\x08deviceId:3\x8aA\x18I\
    nfoResponseProtoMessage\xf2@\x0fUSE_TEXT_SENSOR\xe0@\x12\xe8@\x01\"\xbc\
    \x01\n\x17TextSensorStateResponse\x12\x10\n\x03key\x18\x01\x20\x01(\x07R\
    \x03key\x12\x14\n\x05state\x18\x02\x20\x01(\tR\x05state\x12#\n\rmissing_\
    state\x18\x03\x20\x01(\x08R\x0cmissingState\x12\x1b\n\tdevice_id\x18\x04\
    \x20\x01(\rR\x08deviceId:7\x8aA\x19StateResponseProtoMessage\x80A\x01\
    \xf2@\x0fUSE_TEXT_SENSOR\xe0@\x1b\xe8@\x01\"`\n\x14SubscribeLogsRequest\
    \x12\x1f\n\x05level\x18\x01\x20\x01(\x0e2\t.LogLevelR\x05level\x12\x1f\n\
    \x0bdump_config\x18\x02\x20\x01(\x08R\ndumpConfig:\x06\xe0@\x1c\xe8@\x02\
    \"\x81\x01\n\x15SubscribeLogsResponse\x12\x1f\n\x05level\x18\x01\x20\x01\
    (\x0e2\t.LogLevelR\x05level\x12\x18\n\x07message\x18\x03\x20\x01(\x0cR\
    \x07message\x12\x1f\n\x0bsend_failed\x18\x04\x20\x01(\x08R\nsendFailed:\
    \x0c\xf8@\0\x80A\0\xe0@\x1d\xe8@\x01\"H\n\x1cNoiseEncryptionSetKeyReques\
    t\x12\x10\n\x03key\x18\x01\x20\x01(\x0cR\x03key:\x16\xf2@\rUSE_API_NOISE\
    \xe0@|\xe8@\x02\"Q\n\x1dNoiseEncryptionSetKeyResponse\x12\x18\n\x07succe\
    ss\x18\x01\x20\x01(\x08R\x07success:\x16\xf2@\rUSE_API_NOISE\xe0@}\xe8@\
    \x01\"/\n%SubscribeHomeassistantServicesRequest:\x06\xe0@\"\xe8@\x02\"A\
    \n\x17HomeassistantServiceMap\x12\x10\n\x03key\x18\x01\x20\x01(\tR\x03ke\
    y\x12\x14\n\x05value\x18\x02\x20\x01(\tR\x05value\"\x83\x02\n\x1cHomeass\
    istantServiceResponse\x12\x18\n\x07service\x18\x01\x20\x01(\tR\x07servic\
    e\x12,\n\x04data\x18\x02\x20\x03(\x0b2\x18.HomeassistantServiceMapR\x04d\
    ata\x12=\n\rdata_template\x18\x03\x20\x03(\x0b2\x18.HomeassistantService\
    MapR\x0cdataTemplate\x126\n\tvariables\x18\x04\x20\x03(\x0b2\x18.Homeass\
    istantServiceMapR\tvariables\x12\x19\n\x08is_event\x18\x05\x20\x01(\x08R\
    \x07isEvent:\t\x80A\x01\xe0@#\xe8@\x01\"-\n#SubscribeHomeAssistantStates\
    Request:\x06\xe0@&\xe8@\x02\"|\n#SubscribeHomeAssistantStateResponse\x12\
    \x1b\n\tentity_id\x18\x01\x20\x01(\tR\x08entityId\x12\x1c\n\tattribute\
    \x18\x02\x20\x01(\tR\tattribute\x12\x12\n\x04once\x18\x03\x20\x01(\x08R\
    \x04once:\x06\xe0@'\xe8@\x01\"x\n\x1aHomeAssistantStateResponse\x12\x1b\
    \n\tentity_id\x18\x01\x20\x01(\tR\x08entityId\x12\x14\n\x05state\x18\x02\
    \x20\x01(\tR\x05state\x12\x1c\n\tattribute\x18\x03\x20\x01(\tR\tattribut\
    e:\t\x80A\x01\xe0@(\xe8@\x02\"\x18\n\x0eGetTimeRequest:\x06\xe0@$\xe8@\0\
    \"A\n\x0fGetTimeResponse\x12#\n\repoch_seconds\x18\x01\x20\x01(\x07R\x0c\
    epochSeconds:\t\x80A\x01\xe0@%\xe8@\0\"W\n\x1cListEntitiesServicesArgume\
    nt\x12\x12\n\x04name\x18\x01\x20\x01(\tR\x04name\x12#\n\x04type\x18\x02\
    \x20\x01(\x0e2\x0f.ServiceArgTypeR\x04type\"\x7f\n\x1cListEntitiesServic\
    esResponse\x12\x12\n\x04name\x18\x01\x20\x01(\tR\x04name\x12\x10\n\x03ke\
    y\x18\x02\x20\x01(\x07R\x03key\x121\n\x04args\x18\x03\x20\x03(\x0b2\x1d.\
    ListEntitiesServicesArgumentR\x04args:\x06\xe0@)\xe8@\x01\"\x9b\x02\n\
    \x16ExecuteServiceArgument\x12\x13\n\x05bool_\x18\x01\x20\x01(\x08R\x04b\
    ool\x12\x1d\n\nlegacy_int\x18\x02\x20\x01(\x05R\tlegacyInt\x12\x15\n\x06\
    float_\x18\x03\x20\x01(\x02R\x05float\x12\x17\n\x07string_\x18\x04\x20\
    \x01(\tR\x06string\x12\x11\n\x04int_\x18\x05\x20\x01(\x11R\x03int\x12!\n\
    \nbool_array\x18\x06\x20\x03(\x08R\tboolArrayB\x02\x10\0\x12\x1f\n\tint_\
    array\x18\x07\x20\x03(\x11R\x08intArrayB\x02\x10\0\x12#\n\x0bfloat_array\
    \x18\x08\x20\x03(\x02R\nfloatArrayB\x02\x10\0\x12!\n\x0cstring_array\x18\
    \t\x20\x03(\tR\x0bstringArray\"a\n\x15ExecuteServiceRequest\x12\x10\n\
    \x03key\x18\x01\x20\x01(\x07R\x03key\x12+\n\x04args\x18\x02\x20\x03(\x0b\
    2\x17.ExecuteServiceArgumentR\x04args:\t\x80A\x01\xe0@*\xe8@\x02\"\xc7\
    \x02\n\x1aListEntitiesCameraResponse\x12\x1b\n\tobject_id\x18\x01\x20\
    \x01(\tR\x08objectId\x12\x10\n\x03key\x18\x02\x20\x01(\x07R\x03key\x12\
    \x12\n\x04name\x18\x03\x20\x01(\tR\x04name\x12\x1b\n\tunique_id\x18\x04\
    \x20\x01(\tR\x08uniqueId\x12.\n\x13disabled_by_default\x18\x05\x20\x01(\
    \x08R\x11disabledByDefault\x12\x12\n\x04icon\x18\x06\x20\x01(\tR\x04icon\
    \x128\n\x0fentity_category\x18\x07\x20\x01(\x0e2\x0f.EntityCategoryR\x0e\
    entityCategory\x12\x1b\n\tdevice_id\x18\x08\x20\x01(\rR\x08deviceId:.\
    \x8aA\x18InfoResponseProtoMessage\xf2@\nUSE_CAMERA\xe0@+\xe8@\x01\"\x9d\
    \x01\n\x13CameraImageResponse\x12\x10\n\x03key\x18\x01\x20\x01(\x07R\x03\
    key\x12\x12\n\x04data\x18\x02\x20\x01(\x0cR\x04data\x12\x12\n\x04done\
    \x18\x03\x20\x01(\x08R\x04done\x12\x1b\n\tdevice_id\x18\x04\x20\x01(\rR\
    \x08deviceId:/\x8aA\x19StateResponseProtoMessage\xf2@\nUSE_CAMERA\xe0@,\
    \xe8@\x01\"\\\n\x12CameraImageRequest\x12\x16\n\x06single\x18\x01\x20\
    \x01(\x08R\x06single\x12\x16\n\x06stream\x18\x02\x20\x01(\x08R\x06stream\
    :\x16\x80A\x01\xf2@\nUSE_CAMERA\xe0@-\xe8@\x02\"\xf9\n\n\x1bListEntities\
    ClimateResponse\x12\x1b\n\tobject_id\x18\x01\x20\x01(\tR\x08objectId\x12\
    \x10\n\x03key\x18\x02\x20\x01(\x07R\x03key\x12\x12\n\x04name\x18\x03\x20\
    \x01(\tR\x04name\x12\x1b\n\tunique_id\x18\x04\x20\x01(\tR\x08uniqueId\
    \x12@\n\x1csupports_current_temperature\x18\x05\x20\x01(\x08R\x1asupport\
    sCurrentTemperature\x12P\n%supports_two_point_target_temperature\x18\x06\
    \x20\x01(\x08R!supportsTwoPointTargetTemperature\x125\n\x0fsupported_mod\
    es\x18\x07\x20\x03(\x0e2\x0c.ClimateModeR\x0esupportedModes\x124\n\x16vi\
    sual_min_temperature\x18\x08\x20\x01(\x02R\x14visualMinTemperature\x124\
    \n\x16visual_max_temperature\x18\t\x20\x01(\x02R\x14visualMaxTemperature\
    \x12C\n\x1evisual_target_temperature_step\x18\n\x20\x01(\x02R\x1bvisualT\
    argetTemperatureStep\x120\n\x14legacy_supports_away\x18\x0b\x20\x01(\x08\
    R\x12legacySupportsAway\x12'\n\x0fsupports_action\x18\x0c\x20\x01(\x08R\
    \x0esupportsAction\x12?\n\x13supported_fan_modes\x18\r\x20\x03(\x0e2\x0f\
    .ClimateFanModeR\x11supportedFanModes\x12E\n\x15supported_swing_modes\
    \x18\x0e\x20\x03(\x0e2\x11.ClimateSwingModeR\x13supportedSwingModes\x12;\
    \n\x1asupported_custom_fan_modes\x18\x0f\x20\x03(\tR\x17supportedCustomF\
    anModes\x12;\n\x11supported_presets\x18\x10\x20\x03(\x0e2\x0e.ClimatePre\
    setR\x10supportedPresets\x128\n\x18supported_custom_presets\x18\x11\x20\
    \x03(\tR\x16supportedCustomPresets\x12.\n\x13disabled_by_default\x18\x12\
    \x20\x01(\x08R\x11disabledByDefault\x12\x12\n\x04icon\x18\x13\x20\x01(\t\
    R\x04icon\x128\n\x0fentity_category\x18\x14\x20\x01(\x0e2\x0f.EntityCate\
    goryR\x0eentityCategory\x12E\n\x1fvisual_current_temperature_step\x18\
    \x15\x20\x01(\x02R\x1cvisualCurrentTemperatureStep\x12:\n\x19supports_cu\
    rrent_humidity\x18\x16\x20\x01(\x08R\x17supportsCurrentHumidity\x128\n\
    \x18supports_target_humidity\x18\x17\x20\x01(\x08R\x16supportsTargetHumi\
    dity\x12.\n\x13visual_min_humidity\x18\x18\x20\x01(\x02R\x11visualMinHum\
    idity\x12.\n\x13visual_max_humidity\x18\x19\x20\x01(\x02R\x11visualMaxHu\
    midity\x12\x1b\n\tdevice_id\x18\x1a\x20\x01(\rR\x08deviceId:/\x8aA\x18In\
    foResponseProtoMessage\xf2@\x0bUSE_CLIMATE\xe0@.\xe8@\x01\"\xe7\x05\n\
    \x14ClimateStateResponse\x12\x10\n\x03key\x18\x01\x20\x01(\x07R\x03key\
    \x12\x20\n\x04mode\x18\x02\x20\x01(\x0e2\x0c.ClimateModeR\x04mode\x12/\n\
    \x13current_temperature\x18\x03\x20\x01(\x02R\x12currentTemperature\x12-\
    \n\x12target_temperature\x18\x04\x20\x01(\x02R\x11targetTemperature\x124\
    \n\x16target_temperature_low\x18\x05\x20\x01(\x02R\x14targetTemperatureL\
    ow\x126\n\x17target_temperature_high\x18\x06\x20\x01(\x02R\x15targetTemp\
    eratureHigh\x12,\n\x12unused_legacy_away\x18\x07\x20\x01(\x08R\x10unused\
    LegacyAway\x12&\n\x06action\x18\x08\x20\x01(\x0e2\x0e.ClimateActionR\x06\
    action\x12*\n\x08fan_mode\x18\t\x20\x01(\x0e2\x0f.ClimateFanModeR\x07fan\
    Mode\x120\n\nswing_mode\x18\n\x20\x01(\x0e2\x11.ClimateSwingModeR\tswing\
    Mode\x12&\n\x0fcustom_fan_mode\x18\x0b\x20\x01(\tR\rcustomFanMode\x12&\n\
    \x06preset\x18\x0c\x20\x01(\x0e2\x0e.ClimatePresetR\x06preset\x12#\n\rcu\
    stom_preset\x18\r\x20\x01(\tR\x0ccustomPreset\x12)\n\x10current_humidity\
    \x18\x0e\x20\x01(\x02R\x0fcurrentHumidity\x12'\n\x0ftarget_humidity\x18\
    \x0f\x20\x01(\x02R\x0etargetHumidity\x12\x1b\n\tdevice_id\x18\x10\x20\
    \x01(\rR\x08deviceId:3\x8aA\x19StateResponseProtoMessage\x80A\x01\xf2@\
    \x0bUSE_CLIMATE\xe0@/\xe8@\x01\"\xd2\x08\n\x15ClimateCommandRequest\x12\
    \x10\n\x03key\x18\x01\x20\x01(\x07R\x03key\x12\x19\n\x08has_mode\x18\x02\
    \x20\x01(\x08R\x07hasMode\x12\x20\n\x04mode\x18\x03\x20\x01(\x0e2\x0c.Cl\
    imateModeR\x04mode\x124\n\x16has_target_temperature\x18\x04\x20\x01(\x08\
    R\x14hasTargetTemperature\x12-\n\x12target_temperature\x18\x05\x20\x01(\
    \x02R\x11targetTemperature\x12;\n\x1ahas_target_temperature_low\x18\x06\
    \x20\x01(\x08R\x17hasTargetTemperatureLow\x124\n\x16target_temperature_l\
    ow\x18\x07\x20\x01(\x02R\x14targetTemperatureLow\x12=\n\x1bhas_target_te\
    mperature_high\x18\x08\x20\x01(\x08R\x18hasTargetTemperatureHigh\x126\n\
    \x17target_temperature_high\x18\t\x20\x01(\x02R\x15targetTemperatureHigh\
    \x123\n\x16unused_has_legacy_away\x18\n\x20\x01(\x08R\x13unusedHasLegacy\
    Away\x12,\n\x12unused_legacy_away\x18\x0b\x20\x01(\x08R\x10unusedLegacyA\
    way\x12\x20\n\x0chas_fan_mode\x18\x0c\x20\x01(\x08R\nhasFanMode\x12*\n\
    \x08fan_mode\x18\r\x20\x01(\x0e2\x0f.ClimateFanModeR\x07fanMode\x12$\n\
    \x0ehas_swing_mode\x18\x0e\x20\x01(\x08R\x0chasSwingMode\x120\n\nswing_m\
    ode\x18\x0f\x20\x01(\x0e2\x11.ClimateSwingModeR\tswingMode\x12-\n\x13has\
    _custom_fan_mode\x18\x10\x20\x01(\x08R\x10hasCustomFanMode\x12&\n\x0fcus\
    tom_fan_mode\x18\x11\x20\x01(\tR\rcustomFanMode\x12\x1d\n\nhas_preset\
    \x18\x12\x20\x01(\x08R\thasPreset\x12&\n\x06preset\x18\x13\x20\x01(\x0e2\
    \x0e.ClimatePresetR\x06preset\x12*\n\x11has_custom_preset\x18\x14\x20\
    \x01(\x08R\x0fhasCustomPreset\x12#\n\rcustom_preset\x18\x15\x20\x01(\tR\
    \x0ccustomPreset\x12.\n\x13has_target_humidity\x18\x16\x20\x01(\x08R\x11\
    hasTargetHumidity\x12'\n\x0ftarget_humidity\x18\x17\x20\x01(\x02R\x0etar\
    getHumidity\x12\x1b\n\tdevice_id\x18\x18\x20\x01(\rR\x08deviceId:-\x8aA\
    \x13CommandProtoMessage\x80A\x01\xf2@\x0bUSE_CLIMATE\xe0@0\xe8@\x02\"\
    \x89\x04\n\x1aListEntitiesNumberResponse\x12\x1b\n\tobject_id\x18\x01\
    \x20\x01(\tR\x08objectId\x12\x10\n\x03key\x18\x02\x20\x01(\x07R\x03key\
    \x12\x12\n\x04name\x18\x03\x20\x01(\tR\x04name\x12\x1b\n\tunique_id\x18\
    \x04\x20\x01(\tR\x08uniqueId\x12\x12\n\x04icon\x18\x05\x20\x01(\tR\x04ic\
    on\x12\x1b\n\tmin_value\x18\x06\x20\x01(\x02R\x08minValue\x12\x1b\n\tmax\
    _value\x18\x07\x20\x01(\x02R\x08maxValue\x12\x12\n\x04step\x18\x08\x20\
    \x01(\x02R\x04step\x12.\n\x13disabled_by_default\x18\t\x20\x01(\x08R\x11\
    disabledByDefault\x128\n\x0fentity_category\x18\n\x20\x01(\x0e2\x0f.Enti\
    tyCategoryR\x0eentityCategory\x12.\n\x13unit_of_measurement\x18\x0b\x20\
    \x01(\tR\x11unitOfMeasurement\x12\x1f\n\x04mode\x18\x0c\x20\x01(\x0e2\
    \x0b.NumberModeR\x04mode\x12!\n\x0cdevice_class\x18\r\x20\x01(\tR\x0bdev\
    iceClass\x12\x1b\n\tdevice_id\x18\x0e\x20\x01(\rR\x08deviceId:.\x8aA\x18\
    InfoResponseProtoMessage\xf2@\nUSE_NUMBER\xe0@1\xe8@\x01\"\xb3\x01\n\x13\
    NumberStateResponse\x12\x10\n\x03key\x18\x01\x20\x01(\x07R\x03key\x12\
    \x14\n\x05state\x18\x02\x20\x01(\x02R\x05state\x12#\n\rmissing_state\x18\
    \x03\x20\x01(\x08R\x0cmissingState\x12\x1b\n\tdevice_id\x18\x04\x20\x01(\
    \rR\x08deviceId:2\x8aA\x19StateResponseProtoMessage\x80A\x01\xf2@\nUSE_N\
    UMBER\xe0@2\xe8@\x01\"\x89\x01\n\x14NumberCommandRequest\x12\x10\n\x03ke\
    y\x18\x01\x20\x01(\x07R\x03key\x12\x14\n\x05state\x18\x02\x20\x01(\x02R\
    \x05state\x12\x1b\n\tdevice_id\x18\x03\x20\x01(\rR\x08deviceId:,\x8aA\
    \x13CommandProtoMessage\x80A\x01\xf2@\nUSE_NUMBER\xe0@3\xe8@\x02\"\xe1\
    \x02\n\x1aListEntitiesSelectResponse\x12\x1b\n\tobject_id\x18\x01\x20\
    \x01(\tR\x08objectId\x12\x10\n\x03key\x18\x02\x20\x01(\x07R\x03key\x12\
    \x12\n\x04name\x18\x03\x20\x01(\tR\x04name\x12\x1b\n\tunique_id\x18\x04\
    \x20\x01(\tR\x08uniqueId\x12\x12\n\x04icon\x18\x05\x20\x01(\tR\x04icon\
    \x12\x18\n\x07options\x18\x06\x20\x03(\tR\x07options\x12.\n\x13disabled_\
    by_default\x18\x07\x20\x01(\x08R\x11disabledByDefault\x128\n\x0fentity_c\
    ategory\x18\x08\x20\x01(\x0e2\x0f.EntityCategoryR\x0eentityCategory\x12\
    \x1b\n\tdevice_id\x18\t\x20\x01(\rR\x08deviceId:.\x8aA\x18InfoResponsePr\
    otoMessage\xf2@\nUSE_SELECT\xe0@4\xe8@\x01\"\xb3\x01\n\x13SelectStateRes\
    ponse\x12\x10\n\x03key\x18\x01\x20\x01(\x07R\x03key\x12\x14\n\x05state\
    \x18\x02\x20\x01(\tR\x05state\x12#\n\rmissing_state\x18\x03\x20\x01(\x08\
    R\x0cmissingState\x12\x1b\n\tdevice_id\x18\x04\x20\x01(\rR\x08deviceId:2\
    \x8aA\x19StateResponseProtoMessage\x80A\x01\xf2@\nUSE_SELECT\xe0@5\xe8@\
    \x01\"\x89\x01\n\x14SelectCommandRequest\x12\x10\n\x03key\x18\x01\x20\
    \x01(\x07R\x03key\x12\x14\n\x05state\x18\x02\x20\x01(\tR\x05state\x12\
    \x1b\n\tdevice_id\x18\x03\x20\x01(\rR\x08deviceId:,\x8aA\x13CommandProto\
    Message\x80A\x01\xf2@\nUSE_SELECT\xe0@6\xe8@\x02\"\xb1\x03\n\x19ListEnti\
    tiesSirenResponse\x12\x1b\n\tobject_id\x18\x01\x20\x01(\tR\x08objectId\
    \x12\x10\n\x03key\x18\x02\x20\x01(\x07R\x03key\x12\x12\n\x04name\x18\x03\
    \x20\x01(\tR\x04name\x12\x1b\n\tunique_id\x18\x04\x20\x01(\tR\x08uniqueI\
    d\x12\x12\n\x04icon\x18\x05\x20\x01(\tR\x04icon\x12.\n\x13disabled_by_de\
    fault\x18\x06\x20\x01(\x08R\x11disabledByDefault\x12\x14\n\x05tones\x18\
    \x07\x20\x03(\tR\x05tones\x12+\n\x11supports_duration\x18\x08\x20\x01(\
    \x08R\x10supportsDuration\x12'\n\x0fsupports_volume\x18\t\x20\x01(\x08R\
    \x0esupportsVolume\x128\n\x0fentity_category\x18\n\x20\x01(\x0e2\x0f.Ent\
    ityCategoryR\x0eentityCategory\x12\x1b\n\tdevice_id\x18\x0b\x20\x01(\rR\
    \x08deviceId:-\x8aA\x18InfoResponseProtoMessage\xf2@\tUSE_SIREN\xe0@7\
    \xe8@\x01\"\x8c\x01\n\x12SirenStateResponse\x12\x10\n\x03key\x18\x01\x20\
    \x01(\x07R\x03key\x12\x14\n\x05state\x18\x02\x20\x01(\x08R\x05state\x12\
    \x1b\n\tdevice_id\x18\x03\x20\x01(\rR\x08deviceId:1\x8aA\x19StateRespons\
    eProtoMessage\x80A\x01\xf2@\tUSE_SIREN\xe0@8\xe8@\x01\"\xc9\x02\n\x13Sir\
    enCommandRequest\x12\x10\n\x03key\x18\x01\x20\x01(\x07R\x03key\x12\x1b\n\
    \thas_state\x18\x02\x20\x01(\x08R\x08hasState\x12\x14\n\x05state\x18\x03\
    \x20\x01(\x08R\x05state\x12\x19\n\x08has_tone\x18\x04\x20\x01(\x08R\x07h\
    asTone\x12\x12\n\x04tone\x18\x05\x20\x01(\tR\x04tone\x12!\n\x0chas_durat\
    ion\x18\x06\x20\x01(\x08R\x0bhasDuration\x12\x1a\n\x08duration\x18\x07\
    \x20\x01(\rR\x08duration\x12\x1d\n\nhas_volume\x18\x08\x20\x01(\x08R\tha\
    sVolume\x12\x16\n\x06volume\x18\t\x20\x01(\x02R\x06volume\x12\x1b\n\tdev\
    ice_id\x18\n\x20\x01(\rR\x08deviceId:+\x8aA\x13CommandProtoMessage\x80A\
    \x01\xf2@\tUSE_SIREN\xe0@9\xe8@\x02\"\xd3\x03\n\x18ListEntitiesLockRespo\
    nse\x12\x1b\n\tobject_id\x18\x01\x20\x01(\tR\x08objectId\x12\x10\n\x03ke\
    y\x18\x02\x20\x01(\x07R\x03key\x12\x12\n\x04name\x18\x03\x20\x01(\tR\x04\
    name\x12\x1b\n\tunique_id\x18\x04\x20\x01(\tR\x08uniqueId\x12\x12\n\x04i\
    con\x18\x05\x20\x01(\tR\x04icon\x12.\n\x13disabled_by_default\x18\x06\
    \x20\x01(\x08R\x11disabledByDefault\x128\n\x0fentity_category\x18\x07\
    \x20\x01(\x0e2\x0f.EntityCategoryR\x0eentityCategory\x12#\n\rassumed_sta\
    te\x18\x08\x20\x01(\x08R\x0cassumedState\x12#\n\rsupports_open\x18\t\x20\
    \x01(\x08R\x0csupportsOpen\x12#\n\rrequires_code\x18\n\x20\x01(\x08R\x0c\
    requiresCode\x12\x1f\n\x0bcode_format\x18\x0b\x20\x01(\tR\ncodeFormat\
    \x12\x1b\n\tdevice_id\x18\x0c\x20\x01(\rR\x08deviceId:,\x8aA\x18InfoResp\
    onseProtoMessage\xf2@\x08USE_LOCK\xe0@:\xe8@\x01\"\x96\x01\n\x11LockStat\
    eResponse\x12\x10\n\x03key\x18\x01\x20\x01(\x07R\x03key\x12\x20\n\x05sta\
    te\x18\x02\x20\x01(\x0e2\n.LockStateR\x05state\x12\x1b\n\tdevice_id\x18\
    \x03\x20\x01(\rR\x08deviceId:0\x8aA\x19StateResponseProtoMessage\x80A\
    \x01\xf2@\x08USE_LOCK\xe0@;\xe8@\x01\"\xc6\x01\n\x12LockCommandRequest\
    \x12\x10\n\x03key\x18\x01\x20\x01(\x07R\x03key\x12&\n\x07command\x18\x02\
    \x20\x01(\x0e2\x0c.LockCommandR\x07command\x12\x19\n\x08has_code\x18\x03\
    \x20\x01(\x08R\x07hasCode\x12\x12\n\x04code\x18\x04\x20\x01(\tR\x04code\
    \x12\x1b\n\tdevice_id\x18\x05\x20\x01(\rR\x08deviceId:*\x8aA\x13CommandP\
    rotoMessage\x80A\x01\xf2@\x08USE_LOCK\xe0@<\xe8@\x02\"\xea\x02\n\x1aList\
    EntitiesButtonResponse\x12\x1b\n\tobject_id\x18\x01\x20\x01(\tR\x08objec\
    tId\x12\x10\n\x03key\x18\x02\x20\x01(\x07R\x03key\x12\x12\n\x04name\x18\
    \x03\x20\x01(\tR\x04name\x12\x1b\n\tunique_id\x18\x04\x20\x01(\tR\x08uni\
    queId\x12\x12\n\x04icon\x18\x05\x20\x01(\tR\x04icon\x12.\n\x13disabled_b\
    y_default\x18\x06\x20\x01(\x08R\x11disabledByDefault\x128\n\x0fentity_ca\
    tegory\x18\x07\x20\x01(\x0e2\x0f.EntityCategoryR\x0eentityCategory\x12!\
    \n\x0cdevice_class\x18\x08\x20\x01(\tR\x0bdeviceClass\x12\x1b\n\tdevice_\
    id\x18\t\x20\x01(\rR\x08deviceId:.\x8aA\x18InfoResponseProtoMessage\xf2@\
    \nUSE_BUTTON\xe0@=\xe8@\x01\"s\n\x14ButtonCommandRequest\x12\x10\n\x03ke\
    y\x18\x01\x20\x01(\x07R\x03key\x12\x1b\n\tdevice_id\x18\x02\x20\x01(\rR\
    \x08deviceId:,\x8aA\x13CommandProtoMessage\x80A\x01\xf2@\nUSE_BUTTON\xe0\
    @>\xe8@\x02\"\xe5\x01\n\x1aMediaPlayerSupportedFormat\x12\x16\n\x06forma\
    t\x18\x01\x20\x01(\tR\x06format\x12\x1f\n\x0bsample_rate\x18\x02\x20\x01\
    (\rR\nsampleRate\x12!\n\x0cnum_channels\x18\x03\x20\x01(\rR\x0bnumChanne\
    ls\x123\n\x07purpose\x18\x04\x20\x01(\x0e2\x19.MediaPlayerFormatPurposeR\
    \x07purpose\x12!\n\x0csample_bytes\x18\x05\x20\x01(\rR\x0bsampleBytes:\
    \x13\xf2@\x10USE_MEDIA_PLAYER\"\xc3\x03\n\x1fListEntitiesMediaPlayerResp\
    onse\x12\x1b\n\tobject_id\x18\x01\x20\x01(\tR\x08objectId\x12\x10\n\x03k\
    ey\x18\x02\x20\x01(\x07R\x03key\x12\x12\n\x04name\x18\x03\x20\x01(\tR\
    \x04name\x12\x1b\n\tunique_id\x18\x04\x20\x01(\tR\x08uniqueId\x12\x12\n\
    \x04icon\x18\x05\x20\x01(\tR\x04icon\x12.\n\x13disabled_by_default\x18\
    \x06\x20\x01(\x08R\x11disabledByDefault\x128\n\x0fentity_category\x18\
    \x07\x20\x01(\x0e2\x0f.EntityCategoryR\x0eentityCategory\x12%\n\x0esuppo\
    rts_pause\x18\x08\x20\x01(\x08R\rsupportsPause\x12H\n\x11supported_forma\
    ts\x18\t\x20\x03(\x0b2\x1b.MediaPlayerSupportedFormatR\x10supportedForma\
    ts\x12\x1b\n\tdevice_id\x18\n\x20\x01(\rR\x08deviceId:4\x8aA\x18InfoResp\
    onseProtoMessage\xf2@\x10USE_MEDIA_PLAYER\xe0@?\xe8@\x01\"\xda\x01\n\x18\
    MediaPlayerStateResponse\x12\x10\n\x03key\x18\x01\x20\x01(\x07R\x03key\
    \x12'\n\x05state\x18\x02\x20\x01(\x0e2\x11.MediaPlayerStateR\x05state\
    \x12\x16\n\x06volume\x18\x03\x20\x01(\x02R\x06volume\x12\x14\n\x05muted\
    \x18\x04\x20\x01(\x08R\x05muted\x12\x1b\n\tdevice_id\x18\x05\x20\x01(\rR\
    \x08deviceId:8\x8aA\x19StateResponseProtoMessage\x80A\x01\xf2@\x10USE_ME\
    DIA_PLAYER\xe0@@\xe8@\x01\"\x95\x03\n\x19MediaPlayerCommandRequest\x12\
    \x10\n\x03key\x18\x01\x20\x01(\x07R\x03key\x12\x1f\n\x0bhas_command\x18\
    \x02\x20\x01(\x08R\nhasCommand\x12-\n\x07command\x18\x03\x20\x01(\x0e2\
    \x13.MediaPlayerCommandR\x07command\x12\x1d\n\nhas_volume\x18\x04\x20\
    \x01(\x08R\thasVolume\x12\x16\n\x06volume\x18\x05\x20\x01(\x02R\x06volum\
    e\x12\"\n\rhas_media_url\x18\x06\x20\x01(\x08R\x0bhasMediaUrl\x12\x1b\n\
    \tmedia_url\x18\x07\x20\x01(\tR\x08mediaUrl\x12)\n\x10has_announcement\
    \x18\x08\x20\x01(\x08R\x0fhasAnnouncement\x12\"\n\x0cannouncement\x18\t\
    \x20\x01(\x08R\x0cannouncement\x12\x1b\n\tdevice_id\x18\n\x20\x01(\rR\
    \x08deviceId:2\x8aA\x13CommandProtoMessage\x80A\x01\xf2@\x10USE_MEDIA_PL\
    AYER\xe0@A\xe8@\x02\"_\n)SubscribeBluetoothLEAdvertisementsRequest\x12\
    \x14\n\x05flags\x18\x01\x20\x01(\rR\x05flags:\x1c\xf2@\x13USE_BLUETOOTH_\
    PROXY\xe0@B\xe8@\x02\"c\n\x14BluetoothServiceData\x12\x12\n\x04uuid\x18\
    \x01\x20\x01(\tR\x04uuid\x12#\n\x0blegacy_data\x18\x02\x20\x03(\rR\nlega\
    cyDataB\x02\x18\x01\x12\x12\n\x04data\x18\x03\x20\x01(\x0cR\x04data\"\
    \xcb\x02\n\x20BluetoothLEAdvertisementResponse\x12\x18\n\x07address\x18\
    \x01\x20\x01(\x04R\x07address\x12\x12\n\x04name\x18\x02\x20\x01(\x0cR\
    \x04name\x12\x12\n\x04rssi\x18\x03\x20\x01(\x11R\x04rssi\x12#\n\rservice\
    _uuids\x18\x04\x20\x03(\tR\x0cserviceUuids\x128\n\x0cservice_data\x18\
    \x05\x20\x03(\x0b2\x15.BluetoothServiceDataR\x0bserviceData\x12B\n\x11ma\
    nufacturer_data\x18\x06\x20\x03(\x0b2\x15.BluetoothServiceDataR\x10manuf\
    acturerData\x12!\n\x0caddress_type\x18\x07\x20\x01(\rR\x0baddressType:\
    \x1f\x80A\x01\xf2@\x13USE_BLUETOOTH_PROXY\xe0@C\xe8@\x01\"\x82\x01\n\x1b\
    BluetoothLERawAdvertisement\x12\x18\n\x07address\x18\x01\x20\x01(\x04R\
    \x07address\x12\x12\n\x04rssi\x18\x02\x20\x01(\x11R\x04rssi\x12!\n\x0cad\
    dress_type\x18\x03\x20\x01(\rR\x0baddressType\x12\x12\n\x04data\x18\x04\
    \x20\x01(\x0cR\x04data\"\x8d\x01\n$BluetoothLERawAdvertisementsResponse\
    \x12D\n\x0eadvertisements\x18\x01\x20\x03(\x0b2\x1c.BluetoothLERawAdvert\
    isementR\x0eadvertisements:\x1f\x80A\x01\xf2@\x13USE_BLUETOOTH_PROXY\xe0\
    @]\xe8@\x01\"\xdd\x01\n\x16BluetoothDeviceRequest\x12\x18\n\x07address\
    \x18\x01\x20\x01(\x04R\x07address\x12>\n\x0crequest_type\x18\x02\x20\x01\
    (\x0e2\x1b.BluetoothDeviceRequestTypeR\x0brequestType\x12(\n\x10has_addr\
    ess_type\x18\x03\x20\x01(\x08R\x0ehasAddressType\x12!\n\x0caddress_type\
    \x18\x04\x20\x01(\rR\x0baddressType:\x1c\xf2@\x13USE_BLUETOOTH_PROXY\xe0\
    @D\xe8@\x02\"\xa1\x01\n!BluetoothDeviceConnectionResponse\x12\x18\n\x07a\
    ddress\x18\x01\x20\x01(\x04R\x07address\x12\x1c\n\tconnected\x18\x02\x20\
    \x01(\x08R\tconnected\x12\x10\n\x03mtu\x18\x03\x20\x01(\rR\x03mtu\x12\
    \x14\n\x05error\x18\x04\x20\x01(\x05R\x05error:\x1c\xf2@\x13USE_BLUETOOT\
    H_PROXY\xe0@E\xe8@\x01\"Y\n\x1fBluetoothGATTGetServicesRequest\x12\x18\n\
    \x07address\x18\x01\x20\x01(\x04R\x07address:\x1c\xf2@\x13USE_BLUETOOTH_\
    PROXY\xe0@F\xe8@\x02\"E\n\x17BluetoothGATTDescriptor\x12\x12\n\x04uuid\
    \x18\x01\x20\x03(\x04R\x04uuid\x12\x16\n\x06handle\x18\x02\x20\x01(\rR\
    \x06handle\"\xa5\x01\n\x1bBluetoothGATTCharacteristic\x12\x12\n\x04uuid\
    \x18\x01\x20\x03(\x04R\x04uuid\x12\x16\n\x06handle\x18\x02\x20\x01(\rR\
    \x06handle\x12\x1e\n\nproperties\x18\x03\x20\x01(\rR\nproperties\x12:\n\
    \x0bdescriptors\x18\x04\x20\x03(\x0b2\x18.BluetoothGATTDescriptorR\x0bde\
    scriptors\"\x8a\x01\n\x14BluetoothGATTService\x12\x12\n\x04uuid\x18\x01\
    \x20\x03(\x04R\x04uuid\x12\x16\n\x06handle\x18\x02\x20\x01(\rR\x06handle\
    \x12F\n\x0fcharacteristics\x18\x03\x20\x03(\x0b2\x1c.BluetoothGATTCharac\
    teristicR\x0fcharacteristics\"\x8d\x01\n\x20BluetoothGATTGetServicesResp\
    onse\x12\x18\n\x07address\x18\x01\x20\x01(\x04R\x07address\x121\n\x08ser\
    vices\x18\x02\x20\x03(\x0b2\x15.BluetoothGATTServiceR\x08services:\x1c\
    \xf2@\x13USE_BLUETOOTH_PROXY\xe0@G\xe8@\x01\"^\n$BluetoothGATTGetService\
    sDoneResponse\x12\x18\n\x07address\x18\x01\x20\x01(\x04R\x07address:\x1c\
    \xf2@\x13USE_BLUETOOTH_PROXY\xe0@H\xe8@\x01\"j\n\x18BluetoothGATTReadReq\
    uest\x12\x18\n\x07address\x18\x01\x20\x01(\x04R\x07address\x12\x16\n\x06\
    handle\x18\x02\x20\x01(\rR\x06handle:\x1c\xf2@\x13USE_BLUETOOTH_PROXY\
    \xe0@I\xe8@\x02\"\x7f\n\x19BluetoothGATTReadResponse\x12\x18\n\x07addres\
    s\x18\x01\x20\x01(\x04R\x07address\x12\x16\n\x06handle\x18\x02\x20\x01(\
    \rR\x06handle\x12\x12\n\x04data\x18\x03\x20\x01(\x0cR\x04data:\x1c\xf2@\
    \x13USE_BLUETOOTH_PROXY\xe0@J\xe8@\x01\"\x9b\x01\n\x19BluetoothGATTWrite\
    Request\x12\x18\n\x07address\x18\x01\x20\x01(\x04R\x07address\x12\x16\n\
    \x06handle\x18\x02\x20\x01(\rR\x06handle\x12\x1a\n\x08response\x18\x03\
    \x20\x01(\x08R\x08response\x12\x12\n\x04data\x18\x04\x20\x01(\x0cR\x04da\
    ta:\x1c\xf2@\x13USE_BLUETOOTH_PROXY\xe0@K\xe8@\x02\"t\n\"BluetoothGATTRe\
    adDescriptorRequest\x12\x18\n\x07address\x18\x01\x20\x01(\x04R\x07addres\
    s\x12\x16\n\x06handle\x18\x02\x20\x01(\rR\x06handle:\x1c\xf2@\x13USE_BLU\
    ETOOTH_PROXY\xe0@L\xe8@\x02\"\x89\x01\n#BluetoothGATTWriteDescriptorRequ\
    est\x12\x18\n\x07address\x18\x01\x20\x01(\x04R\x07address\x12\x16\n\x06h\
    andle\x18\x02\x20\x01(\rR\x06handle\x12\x12\n\x04data\x18\x03\x20\x01(\
    \x0cR\x04data:\x1c\xf2@\x13USE_BLUETOOTH_PROXY\xe0@M\xe8@\x02\"\x84\x01\
    \n\x1aBluetoothGATTNotifyRequest\x12\x18\n\x07address\x18\x01\x20\x01(\
    \x04R\x07address\x12\x16\n\x06handle\x18\x02\x20\x01(\rR\x06handle\x12\
    \x16\n\x06enable\x18\x03\x20\x01(\x08R\x06enable:\x1c\xf2@\x13USE_BLUETO\
    OTH_PROXY\xe0@N\xe8@\x02\"\x85\x01\n\x1fBluetoothGATTNotifyDataResponse\
    \x12\x18\n\x07address\x18\x01\x20\x01(\x04R\x07address\x12\x16\n\x06hand\
    le\x18\x02\x20\x01(\rR\x06handle\x12\x12\n\x04data\x18\x03\x20\x01(\x0cR\
    \x04data:\x1c\xf2@\x13USE_BLUETOOTH_PROXY\xe0@O\xe8@\x01\"H\n(SubscribeB\
    luetoothConnectionsFreeRequest:\x1c\xf2@\x13USE_BLUETOOTH_PROXY\xe0@P\
    \xe8@\x02\"\x88\x01\n\x20BluetoothConnectionsFreeResponse\x12\x12\n\x04f\
    ree\x18\x01\x20\x01(\rR\x04free\x12\x14\n\x05limit\x18\x02\x20\x01(\rR\
    \x05limit\x12\x1c\n\tallocated\x18\x03\x20\x03(\x04R\tallocated:\x1c\xf2\
    @\x13USE_BLUETOOTH_PROXY\xe0@Q\xe8@\x01\"\x82\x01\n\x1aBluetoothGATTErro\
    rResponse\x12\x18\n\x07address\x18\x01\x20\x01(\x04R\x07address\x12\x16\
    \n\x06handle\x18\x02\x20\x01(\rR\x06handle\x12\x14\n\x05error\x18\x03\
    \x20\x01(\x05R\x05error:\x1c\xf2@\x13USE_BLUETOOTH_PROXY\xe0@R\xe8@\x01\
    \"l\n\x1aBluetoothGATTWriteResponse\x12\x18\n\x07address\x18\x01\x20\x01\
    (\x04R\x07address\x12\x16\n\x06handle\x18\x02\x20\x01(\rR\x06handle:\x1c\
    \xf2@\x13USE_BLUETOOTH_PROXY\xe0@S\xe8@\x01\"m\n\x1bBluetoothGATTNotifyR\
    esponse\x12\x18\n\x07address\x18\x01\x20\x01(\x04R\x07address\x12\x16\n\
    \x06handle\x18\x02\x20\x01(\rR\x06handle:\x1c\xf2@\x13USE_BLUETOOTH_PROX\
    Y\xe0@T\xe8@\x01\"\x86\x01\n\x1eBluetoothDevicePairingResponse\x12\x18\n\
    \x07address\x18\x01\x20\x01(\x04R\x07address\x12\x16\n\x06paired\x18\x02\
    \x20\x01(\x08R\x06paired\x12\x14\n\x05error\x18\x03\x20\x01(\x05R\x05err\
    or:\x1c\xf2@\x13USE_BLUETOOTH_PROXY\xe0@U\xe8@\x01\"\x8a\x01\n\x20Blueto\
    othDeviceUnpairingResponse\x12\x18\n\x07address\x18\x01\x20\x01(\x04R\
    \x07address\x12\x18\n\x07success\x18\x02\x20\x01(\x08R\x07success\x12\
    \x14\n\x05error\x18\x03\x20\x01(\x05R\x05error:\x1c\xf2@\x13USE_BLUETOOT\
    H_PROXY\xe0@V\xe8@\x01\"K\n+UnsubscribeBluetoothLEAdvertisementsRequest:\
    \x1c\xf2@\x13USE_BLUETOOTH_PROXY\xe0@W\xe8@\x02\"\x8b\x01\n!BluetoothDev\
    iceClearCacheResponse\x12\x18\n\x07address\x18\x01\x20\x01(\x04R\x07addr\
    ess\x12\x18\n\x07success\x18\x02\x20\x01(\x08R\x07success\x12\x14\n\x05e\
    rror\x18\x03\x20\x01(\x05R\x05error:\x1c\xf2@\x13USE_BLUETOOTH_PROXY\xe0\
    @X\xe8@\x01\"\x96\x01\n\x1dBluetoothScannerStateResponse\x12,\n\x05state\
    \x18\x01\x20\x01(\x0e2\x16.BluetoothScannerStateR\x05state\x12)\n\x04mod\
    e\x18\x02\x20\x01(\x0e2\x15.BluetoothScannerModeR\x04mode:\x1c\xf2@\x13U\
    SE_BLUETOOTH_PROXY\xe0@~\xe8@\x01\"i\n\x1eBluetoothScannerSetModeRequest\
    \x12)\n\x04mode\x18\x01\x20\x01(\x0e2\x15.BluetoothScannerModeR\x04mode:\
    \x1c\xf2@\x13USE_BLUETOOTH_PROXY\xe0@\x7f\xe8@\x02\"r\n\x1eSubscribeVoic\
    eAssistantRequest\x12\x1c\n\tsubscribe\x18\x01\x20\x01(\x08R\tsubscribe\
    \x12\x14\n\x05flags\x18\x02\x20\x01(\rR\x05flags:\x1c\xf2@\x13USE_VOICE_\
    ASSISTANT\xe0@Y\xe8@\x02\"\x9f\x01\n\x1bVoiceAssistantAudioSettings\x126\
    \n\x17noise_suppression_level\x18\x01\x20\x01(\rR\x15noiseSuppressionLev\
    el\x12\x1b\n\tauto_gain\x18\x02\x20\x01(\rR\x08autoGain\x12+\n\x11volume\
    _multiplier\x18\x03\x20\x01(\x02R\x10volumeMultiplier\"\xf9\x01\n\x15Voi\
    ceAssistantRequest\x12\x14\n\x05start\x18\x01\x20\x01(\x08R\x05start\x12\
    '\n\x0fconversation_id\x18\x02\x20\x01(\tR\x0econversationId\x12\x14\n\
    \x05flags\x18\x03\x20\x01(\rR\x05flags\x12C\n\x0eaudio_settings\x18\x04\
    \x20\x01(\x0b2\x1c.VoiceAssistantAudioSettingsR\raudioSettings\x12(\n\
    \x10wake_word_phrase\x18\x05\x20\x01(\tR\x0ewakeWordPhrase:\x1c\xf2@\x13\
    USE_VOICE_ASSISTANT\xe0@Z\xe8@\x01\"`\n\x16VoiceAssistantResponse\x12\
    \x12\n\x04port\x18\x01\x20\x01(\rR\x04port\x12\x14\n\x05error\x18\x02\
    \x20\x01(\x08R\x05error:\x1c\xf2@\x13USE_VOICE_ASSISTANT\xe0@[\xe8@\x02\
    \"C\n\x17VoiceAssistantEventData\x12\x12\n\x04name\x18\x01\x20\x01(\tR\
    \x04name\x12\x14\n\x05value\x18\x02\x20\x01(\tR\x05value\"\x9e\x01\n\x1b\
    VoiceAssistantEventResponse\x123\n\nevent_type\x18\x01\x20\x01(\x0e2\x14\
    .VoiceAssistantEventR\teventType\x12,\n\x04data\x18\x02\x20\x03(\x0b2\
    \x18.VoiceAssistantEventDataR\x04data:\x1c\xf2@\x13USE_VOICE_ASSISTANT\
    \xe0@\\\xe8@\x02\"Y\n\x13VoiceAssistantAudio\x12\x12\n\x04data\x18\x01\
    \x20\x01(\x0cR\x04data\x12\x10\n\x03end\x18\x02\x20\x01(\x08R\x03end:\
    \x1c\xf2@\x13USE_VOICE_ASSISTANT\xe0@j\xe8@\0\"\x8e\x02\n\x20VoiceAssist\
    antTimerEventResponse\x128\n\nevent_type\x18\x01\x20\x01(\x0e2\x19.Voice\
    AssistantTimerEventR\teventType\x12\x19\n\x08timer_id\x18\x02\x20\x01(\t\
    R\x07timerId\x12\x12\n\x04name\x18\x03\x20\x01(\tR\x04name\x12#\n\rtotal\
    _seconds\x18\x04\x20\x01(\rR\x0ctotalSeconds\x12!\n\x0cseconds_left\x18\
    \x05\x20\x01(\rR\x0bsecondsLeft\x12\x1b\n\tis_active\x18\x06\x20\x01(\
    \x08R\x08isActive:\x1c\xf2@\x13USE_VOICE_ASSISTANT\xe0@s\xe8@\x02\"\xcd\
    \x01\n\x1dVoiceAssistantAnnounceRequest\x12\x19\n\x08media_id\x18\x01\
    \x20\x01(\tR\x07mediaId\x12\x12\n\x04text\x18\x02\x20\x01(\tR\x04text\
    \x120\n\x14preannounce_media_id\x18\x03\x20\x01(\tR\x12preannounceMediaI\
    d\x12-\n\x12start_conversation\x18\x04\x20\x01(\x08R\x11startConversatio\
    n:\x1c\xf2@\x13USE_VOICE_ASSISTANT\xe0@w\xe8@\x02\"X\n\x1eVoiceAssistant\
    AnnounceFinished\x12\x18\n\x07success\x18\x01\x20\x01(\x08R\x07success:\
    \x1c\xf2@\x13USE_VOICE_ASSISTANT\xe0@x\xe8@\x01\"r\n\x16VoiceAssistantWa\
    keWord\x12\x0e\n\x02id\x18\x01\x20\x01(\tR\x02id\x12\x1b\n\twake_word\
    \x18\x02\x20\x01(\tR\x08wakeWord\x12+\n\x11trained_languages\x18\x03\x20\
    \x03(\tR\x10trainedLanguages\"B\n\"VoiceAssistantConfigurationRequest:\
    \x1c\xf2@\x13USE_VOICE_ASSISTANT\xe0@y\xe8@\x02\"\xed\x01\n#VoiceAssista\
    ntConfigurationResponse\x12I\n\x14available_wake_words\x18\x01\x20\x03(\
    \x0b2\x17.VoiceAssistantWakeWordR\x12availableWakeWords\x12*\n\x11active\
    _wake_words\x18\x02\x20\x03(\tR\x0factiveWakeWords\x121\n\x15max_active_\
    wake_words\x18\x03\x20\x01(\rR\x12maxActiveWakeWords:\x1c\xf2@\x13USE_VO\
    ICE_ASSISTANT\xe0@z\xe8@\x01\"j\n\x1eVoiceAssistantSetConfiguration\x12*\
    \n\x11active_wake_words\x18\x01\x20\x03(\tR\x0factiveWakeWords:\x1c\xf2@\
    \x13USE_VOICE_ASSISTANT\xe0@{\xe8@\x02\"\xe4\x03\n%ListEntitiesAlarmCont\
    rolPanelResponse\x12\x1b\n\tobject_id\x18\x01\x20\x01(\tR\x08objectId\
    \x12\x10\n\x03key\x18\x02\x20\x01(\x07R\x03key\x12\x12\n\x04name\x18\x03\
    \x20\x01(\tR\x04name\x12\x1b\n\tunique_id\x18\x04\x20\x01(\tR\x08uniqueI\
    d\x12\x12\n\x04icon\x18\x05\x20\x01(\tR\x04icon\x12.\n\x13disabled_by_de\
    fault\x18\x06\x20\x01(\x08R\x11disabledByDefault\x128\n\x0fentity_catego\
    ry\x18\x07\x20\x01(\x0e2\x0f.EntityCategoryR\x0eentityCategory\x12-\n\
    \x12supported_features\x18\x08\x20\x01(\rR\x11supportedFeatures\x12#\n\r\
    requires_code\x18\t\x20\x01(\x08R\x0crequiresCode\x12/\n\x14requires_cod\
    e_to_arm\x18\n\x20\x01(\x08R\x11requiresCodeToArm\x12\x1b\n\tdevice_id\
    \x18\x0b\x20\x01(\rR\x08deviceId:;\x8aA\x18InfoResponseProtoMessage\xf2@\
    \x17USE_ALARM_CONTROL_PANEL\xe0@^\xe8@\x01\"\xbf\x01\n\x1eAlarmControlPa\
    nelStateResponse\x12\x10\n\x03key\x18\x01\x20\x01(\x07R\x03key\x12-\n\
    \x05state\x18\x02\x20\x01(\x0e2\x17.AlarmControlPanelStateR\x05state\x12\
    \x1b\n\tdevice_id\x18\x03\x20\x01(\rR\x08deviceId:?\x8aA\x19StateRespons\
    eProtoMessage\x80A\x01\xf2@\x17USE_ALARM_CONTROL_PANEL\xe0@_\xe8@\x01\"\
    \xd9\x01\n\x1fAlarmControlPanelCommandRequest\x12\x10\n\x03key\x18\x01\
    \x20\x01(\x07R\x03key\x128\n\x07command\x18\x02\x20\x01(\x0e2\x1e.AlarmC\
    ontrolPanelStateCommandR\x07command\x12\x12\n\x04code\x18\x03\x20\x01(\t\
    R\x04code\x12\x1b\n\tdevice_id\x18\x04\x20\x01(\rR\x08deviceId:9\x8aA\
    \x13CommandProtoMessage\x80A\x01\xf2@\x17USE_ALARM_CONTROL_PANEL\xe0@`\
    \xe8@\x02\"\xba\x03\n\x18ListEntitiesTextResponse\x12\x1b\n\tobject_id\
    \x18\x01\x20\x01(\tR\x08objectId\x12\x10\n\x03key\x18\x02\x20\x01(\x07R\
    \x03key\x12\x12\n\x04name\x18\x03\x20\x01(\tR\x04name\x12\x1b\n\tunique_\
    id\x18\x04\x20\x01(\tR\x08uniqueId\x12\x12\n\x04icon\x18\x05\x20\x01(\tR\
    \x04icon\x12.\n\x13disabled_by_default\x18\x06\x20\x01(\x08R\x11disabled\
    ByDefault\x128\n\x0fentity_category\x18\x07\x20\x01(\x0e2\x0f.EntityCate\
    goryR\x0eentityCategory\x12\x1d\n\nmin_length\x18\x08\x20\x01(\rR\tminLe\
    ngth\x12\x1d\n\nmax_length\x18\t\x20\x01(\rR\tmaxLength\x12\x18\n\x07pat\
    tern\x18\n\x20\x01(\tR\x07pattern\x12\x1d\n\x04mode\x18\x0b\x20\x01(\x0e\
    2\t.TextModeR\x04mode\x12\x1b\n\tdevice_id\x18\x0c\x20\x01(\rR\x08device\
    Id:,\x8aA\x18InfoResponseProtoMessage\xf2@\x08USE_TEXT\xe0@a\xe8@\x01\"\
    \xaf\x01\n\x11TextStateResponse\x12\x10\n\x03key\x18\x01\x20\x01(\x07R\
    \x03key\x12\x14\n\x05state\x18\x02\x20\x01(\tR\x05state\x12#\n\rmissing_\
    state\x18\x03\x20\x01(\x08R\x0cmissingState\x12\x1b\n\tdevice_id\x18\x04\
    \x20\x01(\rR\x08deviceId:0\x8aA\x19StateResponseProtoMessage\x80A\x01\
    \xf2@\x08USE_TEXT\xe0@b\xe8@\x01\"\x85\x01\n\x12TextCommandRequest\x12\
    \x10\n\x03key\x18\x01\x20\x01(\x07R\x03key\x12\x14\n\x05state\x18\x02\
    \x20\x01(\tR\x05state\x12\x1b\n\tdevice_id\x18\x03\x20\x01(\rR\x08device\
    Id:*\x8aA\x13CommandProtoMessage\x80A\x01\xf2@\x08USE_TEXT\xe0@c\xe8@\
    \x02\"\xcc\x02\n\x18ListEntitiesDateResponse\x12\x1b\n\tobject_id\x18\
    \x01\x20\x01(\tR\x08objectId\x12\x10\n\x03key\x18\x02\x20\x01(\x07R\x03k\
    ey\x12\x12\n\x04name\x18\x03\x20\x01(\tR\x04name\x12\x1b\n\tunique_id\
    \x18\x04\x20\x01(\tR\x08uniqueId\x12\x12\n\x04icon\x18\x05\x20\x01(\tR\
    \x04icon\x12.\n\x13disabled_by_default\x18\x06\x20\x01(\x08R\x11disabled\
    ByDefault\x128\n\x0fentity_category\x18\x07\x20\x01(\x0e2\x0f.EntityCate\
    goryR\x0eentityCategory\x12\x1b\n\tdevice_id\x18\x08\x20\x01(\rR\x08devi\
    ceId:5\x8aA\x18InfoResponseProtoMessage\xf2@\x11USE_DATETIME_DATE\xe0@d\
    \xe8@\x01\"\xde\x01\n\x11DateStateResponse\x12\x10\n\x03key\x18\x01\x20\
    \x01(\x07R\x03key\x12#\n\rmissing_state\x18\x02\x20\x01(\x08R\x0cmissing\
    State\x12\x12\n\x04year\x18\x03\x20\x01(\rR\x04year\x12\x14\n\x05month\
    \x18\x04\x20\x01(\rR\x05month\x12\x10\n\x03day\x18\x05\x20\x01(\rR\x03da\
    y\x12\x1b\n\tdevice_id\x18\x06\x20\x01(\rR\x08deviceId:9\x8aA\x19StateRe\
    sponseProtoMessage\x80A\x01\xf2@\x11USE_DATETIME_DATE\xe0@e\xe8@\x01\"\
    \xb4\x01\n\x12DateCommandRequest\x12\x10\n\x03key\x18\x01\x20\x01(\x07R\
    \x03key\x12\x12\n\x04year\x18\x02\x20\x01(\rR\x04year\x12\x14\n\x05month\
    \x18\x03\x20\x01(\rR\x05month\x12\x10\n\x03day\x18\x04\x20\x01(\rR\x03da\
    y\x12\x1b\n\tdevice_id\x18\x05\x20\x01(\rR\x08deviceId:3\x8aA\x13Command\
    ProtoMessage\x80A\x01\xf2@\x11USE_DATETIME_DATE\xe0@f\xe8@\x02\"\xcc\x02\
    \n\x18ListEntitiesTimeResponse\x12\x1b\n\tobject_id\x18\x01\x20\x01(\tR\
    \x08objectId\x12\x10\n\x03key\x18\x02\x20\x01(\x07R\x03key\x12\x12\n\x04\
    name\x18\x03\x20\x01(\tR\x04name\x12\x1b\n\tunique_id\x18\x04\x20\x01(\t\
    R\x08uniqueId\x12\x12\n\x04icon\x18\x05\x20\x01(\tR\x04icon\x12.\n\x13di\
    sabled_by_default\x18\x06\x20\x01(\x08R\x11disabledByDefault\x128\n\x0fe\
    ntity_category\x18\x07\x20\x01(\x0e2\x0f.EntityCategoryR\x0eentityCatego\
    ry\x12\x1b\n\tdevice_id\x18\x08\x20\x01(\rR\x08deviceId:5\x8aA\x18InfoRe\
    sponseProtoMessage\xf2@\x11USE_DATETIME_TIME\xe0@g\xe8@\x01\"\xe6\x01\n\
    \x11TimeStateResponse\x12\x10\n\x03key\x18\x01\x20\x01(\x07R\x03key\x12#\
    \n\rmissing_state\x18\x02\x20\x01(\x08R\x0cmissingState\x12\x12\n\x04hou\
    r\x18\x03\x20\x01(\rR\x04hour\x12\x16\n\x06minute\x18\x04\x20\x01(\rR\
    \x06minute\x12\x16\n\x06second\x18\x05\x20\x01(\rR\x06second\x12\x1b\n\t\
    device_id\x18\x06\x20\x01(\rR\x08deviceId:9\x8aA\x19StateResponseProtoMe\
    ssage\x80A\x01\xf2@\x11USE_DATETIME_TIME\xe0@h\xe8@\x01\"\xbc\x01\n\x12T\
    imeCommandRequest\x12\x10\n\x03key\x18\x01\x20\x01(\x07R\x03key\x12\x12\
    \n\x04hour\x18\x02\x20\x01(\rR\x04hour\x12\x16\n\x06minute\x18\x03\x20\
    \x01(\rR\x06minute\x12\x16\n\x06second\x18\x04\x20\x01(\rR\x06second\x12\
    \x1b\n\tdevice_id\x18\x05\x20\x01(\rR\x08deviceId:3\x8aA\x13CommandProto\
    Message\x80A\x01\xf2@\x11USE_DATETIME_TIME\xe0@i\xe8@\x02\"\x89\x03\n\
    \x19ListEntitiesEventResponse\x12\x1b\n\tobject_id\x18\x01\x20\x01(\tR\
    \x08objectId\x12\x10\n\x03key\x18\x02\x20\x01(\x07R\x03key\x12\x12\n\x04\
    name\x18\x03\x20\x01(\tR\x04name\x12\x1b\n\tunique_id\x18\x04\x20\x01(\t\
    R\x08uniqueId\x12\x12\n\x04icon\x18\x05\x20\x01(\tR\x04icon\x12.\n\x13di\
    sabled_by_default\x18\x06\x20\x01(\x08R\x11disabledByDefault\x128\n\x0fe\
    ntity_category\x18\x07\x20\x01(\x0e2\x0f.EntityCategoryR\x0eentityCatego\
    ry\x12!\n\x0cdevice_class\x18\x08\x20\x01(\tR\x0bdeviceClass\x12\x1f\n\
    \x0bevent_types\x18\t\x20\x03(\tR\neventTypes\x12\x1b\n\tdevice_id\x18\n\
    \x20\x01(\rR\x08deviceId:-\x8aA\x18InfoResponseProtoMessage\xf2@\tUSE_EV\
    ENT\xe0@k\xe8@\x01\"\x8d\x01\n\rEventResponse\x12\x10\n\x03key\x18\x01\
    \x20\x01(\x07R\x03key\x12\x1d\n\nevent_type\x18\x02\x20\x01(\tR\teventTy\
    pe\x12\x1b\n\tdevice_id\x18\x03\x20\x01(\rR\x08deviceId:.\x8aA\x19StateR\
    esponseProtoMessage\xf2@\tUSE_EVENT\xe0@l\xe8@\x01\"\xdf\x03\n\x19ListEn\
    titiesValveResponse\x12\x1b\n\tobject_id\x18\x01\x20\x01(\tR\x08objectId\
    \x12\x10\n\x03key\x18\x02\x20\x01(\x07R\x03key\x12\x12\n\x04name\x18\x03\
    \x20\x01(\tR\x04name\x12\x1b\n\tunique_id\x18\x04\x20\x01(\tR\x08uniqueI\
    d\x12\x12\n\x04icon\x18\x05\x20\x01(\tR\x04icon\x12.\n\x13disabled_by_de\
    fault\x18\x06\x20\x01(\x08R\x11disabledByDefault\x128\n\x0fentity_catego\
    ry\x18\x07\x20\x01(\x0e2\x0f.EntityCategoryR\x0eentityCategory\x12!\n\
    \x0cdevice_class\x18\x08\x20\x01(\tR\x0bdeviceClass\x12#\n\rassumed_stat\
    e\x18\t\x20\x01(\x08R\x0cassumedState\x12+\n\x11supports_position\x18\n\
    \x20\x01(\x08R\x10supportsPosition\x12#\n\rsupports_stop\x18\x0b\x20\x01\
    (\x08R\x0csupportsStop\x12\x1b\n\tdevice_id\x18\x0c\x20\x01(\rR\x08devic\
    eId:-\x8aA\x18InfoResponseProtoMessage\xf2@\tUSE_VALVE\xe0@m\xe8@\x01\"\
    \xd0\x01\n\x12ValveStateResponse\x12\x10\n\x03key\x18\x01\x20\x01(\x07R\
    \x03key\x12\x1a\n\x08position\x18\x02\x20\x01(\x02R\x08position\x12<\n\
    \x11current_operation\x18\x03\x20\x01(\x0e2\x0f.ValveOperationR\x10curre\
    ntOperation\x12\x1b\n\tdevice_id\x18\x04\x20\x01(\rR\x08deviceId:1\x8aA\
    \x19StateResponseProtoMessage\x80A\x01\xf2@\tUSE_VALVE\xe0@n\xe8@\x01\"\
    \xc4\x01\n\x13ValveCommandRequest\x12\x10\n\x03key\x18\x01\x20\x01(\x07R\
    \x03key\x12!\n\x0chas_position\x18\x02\x20\x01(\x08R\x0bhasPosition\x12\
    \x1a\n\x08position\x18\x03\x20\x01(\x02R\x08position\x12\x12\n\x04stop\
    \x18\x04\x20\x01(\x08R\x04stop\x12\x1b\n\tdevice_id\x18\x05\x20\x01(\rR\
    \x08deviceId:+\x8aA\x13CommandProtoMessage\x80A\x01\xf2@\tUSE_VALVE\xe0@\
    o\xe8@\x02\"\xd4\x02\n\x1cListEntitiesDateTimeResponse\x12\x1b\n\tobject\
    _id\x18\x01\x20\x01(\tR\x08objectId\x12\x10\n\x03key\x18\x02\x20\x01(\
    \x07R\x03key\x12\x12\n\x04name\x18\x03\x20\x01(\tR\x04name\x12\x1b\n\tun\
    ique_id\x18\x04\x20\x01(\tR\x08uniqueId\x12\x12\n\x04icon\x18\x05\x20\
    \x01(\tR\x04icon\x12.\n\x13disabled_by_default\x18\x06\x20\x01(\x08R\x11\
    disabledByDefault\x128\n\x0fentity_category\x18\x07\x20\x01(\x0e2\x0f.En\
    tityCategoryR\x0eentityCategory\x12\x1b\n\tdevice_id\x18\x08\x20\x01(\rR\
    \x08deviceId:9\x8aA\x18InfoResponseProtoMessage\xf2@\x15USE_DATETIME_DAT\
    ETIME\xe0@p\xe8@\x01\"\xcf\x01\n\x15DateTimeStateResponse\x12\x10\n\x03k\
    ey\x18\x01\x20\x01(\x07R\x03key\x12#\n\rmissing_state\x18\x02\x20\x01(\
    \x08R\x0cmissingState\x12#\n\repoch_seconds\x18\x03\x20\x01(\x07R\x0cepo\
    chSeconds\x12\x1b\n\tdevice_id\x18\x04\x20\x01(\rR\x08deviceId:=\x8aA\
    \x19StateResponseProtoMessage\x80A\x01\xf2@\x15USE_DATETIME_DATETIME\xe0\
    @q\xe8@\x01\"\xa5\x01\n\x16DateTimeCommandRequest\x12\x10\n\x03key\x18\
    \x01\x20\x01(\x07R\x03key\x12#\n\repoch_seconds\x18\x02\x20\x01(\x07R\
    \x0cepochSeconds\x12\x1b\n\tdevice_id\x18\x03\x20\x01(\rR\x08deviceId:7\
    \x8aA\x13CommandProtoMessage\x80A\x01\xf2@\x15USE_DATETIME_DATETIME\xe0@\
    r\xe8@\x02\"\xea\x02\n\x1aListEntitiesUpdateResponse\x12\x1b\n\tobject_i\
    d\x18\x01\x20\x01(\tR\x08objectId\x12\x10\n\x03key\x18\x02\x20\x01(\x07R\
    \x03key\x12\x12\n\x04name\x18\x03\x20\x01(\tR\x04name\x12\x1b\n\tunique_\
    id\x18\x04\x20\x01(\tR\x08uniqueId\x12\x12\n\x04icon\x18\x05\x20\x01(\tR\
    \x04icon\x12.\n\x13disabled_by_default\x18\x06\x20\x01(\x08R\x11disabled\
    ByDefault\x128\n\x0fentity_category\x18\x07\x20\x01(\x0e2\x0f.EntityCate\
    goryR\x0eentityCategory\x12!\n\x0cdevice_class\x18\x08\x20\x01(\tR\x0bde\
    viceClass\x12\x1b\n\tdevice_id\x18\t\x20\x01(\rR\x08deviceId:.\x8aA\x18I\
    nfoResponseProtoMessage\xf2@\nUSE_UPDATE\xe0@t\xe8@\x01\"\xad\x03\n\x13U\
    pdateStateResponse\x12\x10\n\x03key\x18\x01\x20\x01(\x07R\x03key\x12#\n\
    \rmissing_state\x18\x02\x20\x01(\x08R\x0cmissingState\x12\x1f\n\x0bin_pr\
    ogress\x18\x03\x20\x01(\x08R\ninProgress\x12!\n\x0chas_progress\x18\x04\
    \x20\x01(\x08R\x0bhasProgress\x12\x1a\n\x08progress\x18\x05\x20\x01(\x02\
    R\x08progress\x12'\n\x0fcurrent_version\x18\x06\x20\x01(\tR\x0ecurrentVe\
    rsion\x12%\n\x0elatest_version\x18\x07\x20\x01(\tR\rlatestVersion\x12\
    \x14\n\x05title\x18\x08\x20\x01(\tR\x05title\x12'\n\x0frelease_summary\
    \x18\t\x20\x01(\tR\x0ereleaseSummary\x12\x1f\n\x0brelease_url\x18\n\x20\
    \x01(\tR\nreleaseUrl\x12\x1b\n\tdevice_id\x18\x0b\x20\x01(\rR\x08deviceI\
    d:2\x8aA\x19StateResponseProtoMessage\x80A\x01\xf2@\nUSE_UPDATE\xe0@u\
    \xe8@\x01\"\x9d\x01\n\x14UpdateCommandRequest\x12\x10\n\x03key\x18\x01\
    \x20\x01(\x07R\x03key\x12(\n\x07command\x18\x02\x20\x01(\x0e2\x0e.Update\
    CommandR\x07command\x12\x1b\n\tdevice_id\x18\x03\x20\x01(\rR\x08deviceId\
    :,\x8aA\x13CommandProtoMessage\x80A\x01\xf2@\nUSE_UPDATE\xe0@v\xe8@\x02*\
    f\n\x0eEntityCategory\x12\x18\n\x14ENTITY_CATEGORY_NONE\x10\0\x12\x1a\n\
    \x16ENTITY_CATEGORY_CONFIG\x10\x01\x12\x1e\n\x1aENTITY_CATEGORY_DIAGNOST\
    IC\x10\x02*N\n\x10LegacyCoverState\x12\x1b\n\x17LEGACY_COVER_STATE_OPEN\
    \x10\0\x12\x1d\n\x19LEGACY_COVER_STATE_CLOSED\x10\x01*j\n\x0eCoverOperat\
    ion\x12\x18\n\x14COVER_OPERATION_IDLE\x10\0\x12\x1e\n\x1aCOVER_OPERATION\
    _IS_OPENING\x10\x01\x12\x1e\n\x1aCOVER_OPERATION_IS_CLOSING\x10\x02*r\n\
    \x12LegacyCoverCommand\x12\x1d\n\x19LEGACY_COVER_COMMAND_OPEN\x10\0\x12\
    \x1e\n\x1aLEGACY_COVER_COMMAND_CLOSE\x10\x01\x12\x1d\n\x19LEGACY_COVER_C\
    OMMAND_STOP\x10\x02*G\n\x08FanSpeed\x12\x11\n\rFAN_SPEED_LOW\x10\0\x12\
    \x14\n\x10FAN_SPEED_MEDIUM\x10\x01\x12\x12\n\x0eFAN_SPEED_HIGH\x10\x02*D\
    \n\x0cFanDirection\x12\x19\n\x15FAN_DIRECTION_FORWARD\x10\0\x12\x19\n\
    \x15FAN_DIRECTION_REVERSE\x10\x01*\xc7\x02\n\tColorMode\x12\x16\n\x12COL\
    OR_MODE_UNKNOWN\x10\0\x12\x15\n\x11COLOR_MODE_ON_OFF\x10\x01\x12\x20\n\
    \x1cCOLOR_MODE_LEGACY_BRIGHTNESS\x10\x02\x12\x19\n\x15COLOR_MODE_BRIGHTN\
    ESS\x10\x03\x12\x14\n\x10COLOR_MODE_WHITE\x10\x07\x12\x20\n\x1cCOLOR_MOD\
    E_COLOR_TEMPERATURE\x10\x0b\x12\x1e\n\x1aCOLOR_MODE_COLD_WARM_WHITE\x10\
    \x13\x12\x12\n\x0eCOLOR_MODE_RGB\x10#\x12\x18\n\x14COLOR_MODE_RGB_WHITE\
    \x10'\x12$\n\x20COLOR_MODE_RGB_COLOR_TEMPERATURE\x10/\x12\"\n\x1eCOLOR_M\
    ODE_RGB_COLD_WARM_WHITE\x103*~\n\x10SensorStateClass\x12\x14\n\x10STATE_\
    CLASS_NONE\x10\0\x12\x1b\n\x17STATE_CLASS_MEASUREMENT\x10\x01\x12\x20\n\
    \x1cSTATE_CLASS_TOTAL_INCREASING\x10\x02\x12\x15\n\x11STATE_CLASS_TOTAL\
    \x10\x03*U\n\x13SensorLastResetType\x12\x13\n\x0fLAST_RESET_NONE\x10\0\
    \x12\x14\n\x10LAST_RESET_NEVER\x10\x01\x12\x13\n\x0fLAST_RESET_AUTO\x10\
    \x02*\xb9\x01\n\x08LogLevel\x12\x12\n\x0eLOG_LEVEL_NONE\x10\0\x12\x13\n\
    \x0fLOG_LEVEL_ERROR\x10\x01\x12\x12\n\x0eLOG_LEVEL_WARN\x10\x02\x12\x12\
    \n\x0eLOG_LEVEL_INFO\x10\x03\x12\x14\n\x10LOG_LEVEL_CONFIG\x10\x04\x12\
    \x13\n\x0fLOG_LEVEL_DEBUG\x10\x05\x12\x15\n\x11LOG_LEVEL_VERBOSE\x10\x06\
    \x12\x1a\n\x16LOG_LEVEL_VERY_VERBOSE\x10\x07*\x84\x02\n\x0eServiceArgTyp\
    e\x12\x19\n\x15SERVICE_ARG_TYPE_BOOL\x10\0\x12\x18\n\x14SERVICE_ARG_TYPE\
    _INT\x10\x01\x12\x1a\n\x16SERVICE_ARG_TYPE_FLOAT\x10\x02\x12\x1b\n\x17SE\
    RVICE_ARG_TYPE_STRING\x10\x03\x12\x1f\n\x1bSERVICE_ARG_TYPE_BOOL_ARRAY\
    \x10\x04\x12\x1e\n\x1aSERVICE_ARG_TYPE_INT_ARRAY\x10\x05\x12\x20\n\x1cSE\
    RVICE_ARG_TYPE_FLOAT_ARRAY\x10\x06\x12!\n\x1dSERVICE_ARG_TYPE_STRING_ARR\
    AY\x10\x07*\xb5\x01\n\x0bClimateMode\x12\x14\n\x10CLIMATE_MODE_OFF\x10\0\
    \x12\x1a\n\x16CLIMATE_MODE_HEAT_COOL\x10\x01\x12\x15\n\x11CLIMATE_MODE_C\
    OOL\x10\x02\x12\x15\n\x11CLIMATE_MODE_HEAT\x10\x03\x12\x19\n\x15CLIMATE_\
    MODE_FAN_ONLY\x10\x04\x12\x14\n\x10CLIMATE_MODE_DRY\x10\x05\x12\x15\n\
    \x11CLIMATE_MODE_AUTO\x10\x06*\xf1\x01\n\x0eClimateFanMode\x12\x12\n\x0e\
    CLIMATE_FAN_ON\x10\0\x12\x13\n\x0fCLIMATE_FAN_OFF\x10\x01\x12\x14\n\x10C\
    LIMATE_FAN_AUTO\x10\x02\x12\x13\n\x0fCLIMATE_FAN_LOW\x10\x03\x12\x16\n\
    \x12CLIMATE_FAN_MEDIUM\x10\x04\x12\x14\n\x10CLIMATE_FAN_HIGH\x10\x05\x12\
    \x16\n\x12CLIMATE_FAN_MIDDLE\x10\x06\x12\x15\n\x11CLIMATE_FAN_FOCUS\x10\
    \x07\x12\x17\n\x13CLIMATE_FAN_DIFFUSE\x10\x08\x12\x15\n\x11CLIMATE_FAN_Q\
    UIET\x10\t*{\n\x10ClimateSwingMode\x12\x15\n\x11CLIMATE_SWING_OFF\x10\0\
    \x12\x16\n\x12CLIMATE_SWING_BOTH\x10\x01\x12\x1a\n\x16CLIMATE_SWING_VERT\
    ICAL\x10\x02\x12\x1c\n\x18CLIMATE_SWING_HORIZONTAL\x10\x03*\xab\x01\n\rC\
    limateAction\x12\x16\n\x12CLIMATE_ACTION_OFF\x10\0\x12\x1a\n\x16CLIMATE_\
    ACTION_COOLING\x10\x02\x12\x1a\n\x16CLIMATE_ACTION_HEATING\x10\x03\x12\
    \x17\n\x13CLIMATE_ACTION_IDLE\x10\x04\x12\x19\n\x15CLIMATE_ACTION_DRYING\
    \x10\x05\x12\x16\n\x12CLIMATE_ACTION_FAN\x10\x06*\xdf\x01\n\rClimatePres\
    et\x12\x17\n\x13CLIMATE_PRESET_NONE\x10\0\x12\x17\n\x13CLIMATE_PRESET_HO\
    ME\x10\x01\x12\x17\n\x13CLIMATE_PRESET_AWAY\x10\x02\x12\x18\n\x14CLIMATE\
    _PRESET_BOOST\x10\x03\x12\x1a\n\x16CLIMATE_PRESET_COMFORT\x10\x04\x12\
    \x16\n\x12CLIMATE_PRESET_ECO\x10\x05\x12\x18\n\x14CLIMATE_PRESET_SLEEP\
    \x10\x06\x12\x1b\n\x17CLIMATE_PRESET_ACTIVITY\x10\x07*O\n\nNumberMode\
    \x12\x14\n\x10NUMBER_MODE_AUTO\x10\0\x12\x13\n\x0fNUMBER_MODE_BOX\x10\
    \x01\x12\x16\n\x12NUMBER_MODE_SLIDER\x10\x02*\x99\x01\n\tLockState\x12\
    \x13\n\x0fLOCK_STATE_NONE\x10\0\x12\x15\n\x11LOCK_STATE_LOCKED\x10\x01\
    \x12\x17\n\x13LOCK_STATE_UNLOCKED\x10\x02\x12\x15\n\x11LOCK_STATE_JAMMED\
    \x10\x03\x12\x16\n\x12LOCK_STATE_LOCKING\x10\x04\x12\x18\n\x14LOCK_STATE\
    _UNLOCKING\x10\x05*<\n\x0bLockCommand\x12\x0f\n\x0bLOCK_UNLOCK\x10\0\x12\
    \r\n\tLOCK_LOCK\x10\x01\x12\r\n\tLOCK_OPEN\x10\x02*\x8b\x01\n\x10MediaPl\
    ayerState\x12\x1b\n\x17MEDIA_PLAYER_STATE_NONE\x10\0\x12\x1b\n\x17MEDIA_\
    PLAYER_STATE_IDLE\x10\x01\x12\x1e\n\x1aMEDIA_PLAYER_STATE_PLAYING\x10\
    \x02\x12\x1d\n\x19MEDIA_PLAYER_STATE_PAUSED\x10\x03*\xb2\x01\n\x12MediaP\
    layerCommand\x12\x1d\n\x19MEDIA_PLAYER_COMMAND_PLAY\x10\0\x12\x1e\n\x1aM\
    EDIA_PLAYER_COMMAND_PAUSE\x10\x01\x12\x1d\n\x19MEDIA_PLAYER_COMMAND_STOP\
    \x10\x02\x12\x1d\n\x19MEDIA_PLAYER_COMMAND_MUTE\x10\x03\x12\x1f\n\x1bMED\
    IA_PLAYER_COMMAND_UNMUTE\x10\x04*q\n\x18MediaPlayerFormatPurpose\x12'\n#\
    MEDIA_PLAYER_FORMAT_PURPOSE_DEFAULT\x10\0\x12,\n(MEDIA_PLAYER_FORMAT_PUR\
    POSE_ANNOUNCEMENT\x10\x01*\xeb\x02\n\x1aBluetoothDeviceRequestType\x12)\
    \n%BLUETOOTH_DEVICE_REQUEST_TYPE_CONNECT\x10\0\x12,\n(BLUETOOTH_DEVICE_R\
    EQUEST_TYPE_DISCONNECT\x10\x01\x12&\n\"BLUETOOTH_DEVICE_REQUEST_TYPE_PAI\
    R\x10\x02\x12(\n$BLUETOOTH_DEVICE_REQUEST_TYPE_UNPAIR\x10\x03\x127\n3BLU\
    ETOOTH_DEVICE_REQUEST_TYPE_CONNECT_V3_WITH_CACHE\x10\x04\x12:\n6BLUETOOT\
    H_DEVICE_REQUEST_TYPE_CONNECT_V3_WITHOUT_CACHE\x10\x05\x12-\n)BLUETOOTH_\
    DEVICE_REQUEST_TYPE_CLEAR_CACHE\x10\x06*\xf3\x01\n\x15BluetoothScannerSt\
    ate\x12\x20\n\x1cBLUETOOTH_SCANNER_STATE_IDLE\x10\0\x12$\n\x20BLUETOOTH_\
    SCANNER_STATE_STARTING\x10\x01\x12#\n\x1fBLUETOOTH_SCANNER_STATE_RUNNING\
    \x10\x02\x12\"\n\x1eBLUETOOTH_SCANNER_STATE_FAILED\x10\x03\x12$\n\x20BLU\
    ETOOTH_SCANNER_STATE_STOPPING\x10\x04\x12#\n\x1fBLUETOOTH_SCANNER_STATE_\
    STOPPED\x10\x05*]\n\x14BluetoothScannerMode\x12\"\n\x1eBLUETOOTH_SCANNER\
    _MODE_PASSIVE\x10\0\x12!\n\x1dBLUETOOTH_SCANNER_MODE_ACTIVE\x10\x01*j\n\
    \x1bVoiceAssistantSubscribeFlag\x12\"\n\x1eVOICE_ASSISTANT_SUBSCRIBE_NON\
    E\x10\0\x12'\n#VOICE_ASSISTANT_SUBSCRIBE_API_AUDIO\x10\x01*\x8d\x01\n\
    \x19VoiceAssistantRequestFlag\x12\x20\n\x1cVOICE_ASSISTANT_REQUEST_NONE\
    \x10\0\x12#\n\x1fVOICE_ASSISTANT_REQUEST_USE_VAD\x10\x01\x12)\n%VOICE_AS\
    SISTANT_REQUEST_USE_WAKE_WORD\x10\x02*\xa1\x04\n\x13VoiceAssistantEvent\
    \x12\x19\n\x15VOICE_ASSISTANT_ERROR\x10\0\x12\x1d\n\x19VOICE_ASSISTANT_R\
    UN_START\x10\x01\x12\x1b\n\x17VOICE_ASSISTANT_RUN_END\x10\x02\x12\x1d\n\
    \x19VOICE_ASSISTANT_STT_START\x10\x03\x12\x1b\n\x17VOICE_ASSISTANT_STT_E\
    ND\x10\x04\x12\x20\n\x1cVOICE_ASSISTANT_INTENT_START\x10\x05\x12\x1e\n\
    \x1aVOICE_ASSISTANT_INTENT_END\x10\x06\x12\x1d\n\x19VOICE_ASSISTANT_TTS_\
    START\x10\x07\x12\x1b\n\x17VOICE_ASSISTANT_TTS_END\x10\x08\x12#\n\x1fVOI\
    CE_ASSISTANT_WAKE_WORD_START\x10\t\x12!\n\x1dVOICE_ASSISTANT_WAKE_WORD_E\
    ND\x10\n\x12!\n\x1dVOICE_ASSISTANT_STT_VAD_START\x10\x0b\x12\x1f\n\x1bVO\
    ICE_ASSISTANT_STT_VAD_END\x10\x0c\x12$\n\x20VOICE_ASSISTANT_TTS_STREAM_S\
    TART\x10b\x12\"\n\x1eVOICE_ASSISTANT_TTS_STREAM_END\x10c\x12#\n\x1fVOICE\
    _ASSISTANT_INTENT_PROGRESS\x10d*\xa9\x01\n\x18VoiceAssistantTimerEvent\
    \x12!\n\x1dVOICE_ASSISTANT_TIMER_STARTED\x10\0\x12!\n\x1dVOICE_ASSISTANT\
    _TIMER_UPDATED\x10\x01\x12#\n\x1fVOICE_ASSISTANT_TIMER_CANCELLED\x10\x02\
    \x12\"\n\x1eVOICE_ASSISTANT_TIMER_FINISHED\x10\x03*\xb3\x02\n\x16AlarmCo\
    ntrolPanelState\x12\x18\n\x14ALARM_STATE_DISARMED\x10\0\x12\x1a\n\x16ALA\
    RM_STATE_ARMED_HOME\x10\x01\x12\x1a\n\x16ALARM_STATE_ARMED_AWAY\x10\x02\
    \x12\x1b\n\x17ALARM_STATE_ARMED_NIGHT\x10\x03\x12\x1e\n\x1aALARM_STATE_A\
    RMED_VACATION\x10\x04\x12#\n\x1fALARM_STATE_ARMED_CUSTOM_BYPASS\x10\x05\
    \x12\x17\n\x13ALARM_STATE_PENDING\x10\x06\x12\x16\n\x12ALARM_STATE_ARMIN\
    G\x10\x07\x12\x19\n\x15ALARM_STATE_DISARMING\x10\x08\x12\x19\n\x15ALARM_\
    STATE_TRIGGERED\x10\t*\x98\x02\n\x1dAlarmControlPanelStateCommand\x12\
    \x1e\n\x1aALARM_CONTROL_PANEL_DISARM\x10\0\x12\x20\n\x1cALARM_CONTROL_PA\
    NEL_ARM_AWAY\x10\x01\x12\x20\n\x1cALARM_CONTROL_PANEL_ARM_HOME\x10\x02\
    \x12!\n\x1dALARM_CONTROL_PANEL_ARM_NIGHT\x10\x03\x12$\n\x20ALARM_CONTROL\
    _PANEL_ARM_VACATION\x10\x04\x12)\n%ALARM_CONTROL_PANEL_ARM_CUSTOM_BYPASS\
    \x10\x05\x12\x1f\n\x1bALARM_CONTROL_PANEL_TRIGGER\x10\x06*6\n\x08TextMod\
    e\x12\x12\n\x0eTEXT_MODE_TEXT\x10\0\x12\x16\n\x12TEXT_MODE_PASSWORD\x10\
    \x01*j\n\x0eValveOperation\x12\x18\n\x14VALVE_OPERATION_IDLE\x10\0\x12\
    \x1e\n\x1aVALVE_OPERATION_IS_OPENING\x10\x01\x12\x1e\n\x1aVALVE_OPERATIO\
    N_IS_CLOSING\x10\x02*]\n\rUpdateCommand\x12\x17\n\x13UPDATE_COMMAND_NONE\
    \x10\0\x12\x19\n\x15UPDATE_COMMAND_UPDATE\x10\x01\x12\x18\n\x14UPDATE_CO\
    MMAND_CHECK\x10\x022\xc8\x16\n\rAPIConnection\x12.\n\x05hello\x12\r.Hell\
    oRequest\x1a\x0e.HelloResponse\"\x06\xf0@\0\xf8@\0\x124\n\x07connect\x12\
    \x0f.ConnectRequest\x1a\x10.ConnectResponse\"\x06\xf0@\0\xf8@\0\x12=\n\n\
    disconnect\x12\x12.DisconnectRequest\x1a\x13.DisconnectResponse\"\x06\
    \xf0@\0\xf8@\0\x12+\n\x04ping\x12\x0c.PingRequest\x1a\r.PingResponse\"\
    \x06\xf0@\0\xf8@\0\x12;\n\x0bdevice_info\x12\x12.DeviceInfoRequest\x1a\
    \x13.DeviceInfoResponse\"\x03\xf8@\0\x12.\n\rlist_entities\x12\x14.ListE\
    ntitiesRequest\x1a\x05.void\"\0\x124\n\x10subscribe_states\x12\x17.Subsc\
    ribeStatesRequest\x1a\x05.void\"\0\x120\n\x0esubscribe_logs\x12\x15.Subs\
    cribeLogsRequest\x1a\x05.void\"\0\x12S\n\x20subscribe_homeassistant_serv\
    ices\x12&.SubscribeHomeassistantServicesRequest\x1a\x05.void\"\0\x12P\n\
    \x1fsubscribe_home_assistant_states\x12$.SubscribeHomeAssistantStatesReq\
    uest\x1a\x05.void\"\0\x122\n\x08get_time\x12\x0f.GetTimeRequest\x1a\x10.\
    GetTimeResponse\"\x03\xf8@\0\x122\n\x0fexecute_service\x12\x16.ExecuteSe\
    rviceRequest\x1a\x05.void\"\0\x12[\n\x18noise_encryption_set_key\x12\x1d\
    .NoiseEncryptionSetKeyRequest\x1a\x1e.NoiseEncryptionSetKeyResponse\"\0\
    \x120\n\x0ebutton_command\x12\x15.ButtonCommandRequest\x1a\x05.void\"\0\
    \x12,\n\x0ccamera_image\x12\x13.CameraImageRequest\x1a\x05.void\"\0\x122\
    \n\x0fclimate_command\x12\x16.ClimateCommandRequest\x1a\x05.void\"\0\x12\
    .\n\rcover_command\x12\x14.CoverCommandRequest\x1a\x05.void\"\0\x12,\n\
    \x0cdate_command\x12\x13.DateCommandRequest\x1a\x05.void\"\0\x124\n\x10d\
    atetime_command\x12\x17.DateTimeCommandRequest\x1a\x05.void\"\0\x12*\n\
    \x0bfan_command\x12\x12.FanCommandRequest\x1a\x05.void\"\0\x12.\n\rlight\
    _command\x12\x14.LightCommandRequest\x1a\x05.void\"\0\x12,\n\x0clock_com\
    mand\x12\x13.LockCommandRequest\x1a\x05.void\"\0\x12;\n\x14media_player_\
    command\x12\x1a.MediaPlayerCommandRequest\x1a\x05.void\"\0\x120\n\x0enum\
    ber_command\x12\x15.NumberCommandRequest\x1a\x05.void\"\0\x120\n\x0esele\
    ct_command\x12\x15.SelectCommandRequest\x1a\x05.void\"\0\x12.\n\rsiren_c\
    ommand\x12\x14.SirenCommandRequest\x1a\x05.void\"\0\x120\n\x0eswitch_com\
    mand\x12\x15.SwitchCommandRequest\x1a\x05.void\"\0\x12,\n\x0ctext_comman\
    d\x12\x13.TextCommandRequest\x1a\x05.void\"\0\x12,\n\x0ctime_command\x12\
    \x13.TimeCommandRequest\x1a\x05.void\"\0\x120\n\x0eupdate_command\x12\
    \x15.UpdateCommandRequest\x1a\x05.void\"\0\x12.\n\rvalve_command\x12\x14\
    .ValveCommandRequest\x1a\x05.void\"\0\x12\\\n%subscribe_bluetooth_le_adv\
    ertisements\x12*.SubscribeBluetoothLEAdvertisementsRequest\x1a\x05.void\
    \"\0\x12<\n\x18bluetooth_device_request\x12\x17.BluetoothDeviceRequest\
    \x1a\x05.void\"\0\x12H\n\x1bbluetooth_gatt_get_services\x12\x20.Bluetoot\
    hGATTGetServicesRequest\x1a\x05.void\"\0\x129\n\x13bluetooth_gatt_read\
    \x12\x19.BluetoothGATTReadRequest\x1a\x05.void\"\0\x12;\n\x14bluetooth_g\
    att_write\x12\x1a.BluetoothGATTWriteRequest\x1a\x05.void\"\0\x12N\n\x1eb\
    luetooth_gatt_read_descriptor\x12#.BluetoothGATTReadDescriptorRequest\
    \x1a\x05.void\"\0\x12P\n\x1fbluetooth_gatt_write_descriptor\x12$.Bluetoo\
    thGATTWriteDescriptorRequest\x1a\x05.void\"\0\x12=\n\x15bluetooth_gatt_n\
    otify\x12\x1b.BluetoothGATTNotifyRequest\x1a\x05.void\"\0\x12v\n$subscri\
    be_bluetooth_connections_free\x12).SubscribeBluetoothConnectionsFreeRequ\
    est\x1a!.BluetoothConnectionsFreeResponse\"\0\x12`\n'unsubscribe_bluetoo\
    th_le_advertisements\x12,.UnsubscribeBluetoothLEAdvertisementsRequest\
    \x1a\x05.void\"\0\x12F\n\x1abluetooth_scanner_set_mode\x12\x1f.Bluetooth\
    ScannerSetModeRequest\x1a\x05.void\"\0\x12E\n\x19subscribe_voice_assista\
    nt\x12\x1f.SubscribeVoiceAssistantRequest\x1a\x05.void\"\0\x12p\n!voice_\
    assistant_get_configuration\x12#.VoiceAssistantConfigurationRequest\x1a$\
    .VoiceAssistantConfigurationResponse\"\0\x12M\n!voice_assistant_set_conf\
    iguration\x12\x1f.VoiceAssistantSetConfiguration\x1a\x05.void\"\0\x12H\n\
    \x1balarm_control_panel_command\x12\x20.AlarmControlPanelCommandRequest\
    \x1a\x05.void\"\0b\x06proto3\
";

/// `FileDescriptorProto` object which was a source for this generated file
fn file_descriptor_proto() -> &'static ::protobuf::descriptor::FileDescriptorProto {
    static file_descriptor_proto_lazy: ::protobuf::rt::Lazy<::protobuf::descriptor::FileDescriptorProto> = ::protobuf::rt::Lazy::new();
    file_descriptor_proto_lazy.get(|| {
        ::protobuf::Message::parse_from_bytes(file_descriptor_proto_data).unwrap()
    })
}

/// `FileDescriptor` object which allows dynamic access to files
pub fn file_descriptor() -> &'static ::protobuf::reflect::FileDescriptor {
    static generated_file_descriptor_lazy: ::protobuf::rt::Lazy<::protobuf::reflect::GeneratedFileDescriptor> = ::protobuf::rt::Lazy::new();
    static file_descriptor: ::protobuf::rt::Lazy<::protobuf::reflect::FileDescriptor> = ::protobuf::rt::Lazy::new();
    file_descriptor.get(|| {
        let generated_file_descriptor = generated_file_descriptor_lazy.get(|| {
            let mut deps = ::std::vec::Vec::with_capacity(1);
            deps.push(super::api_options::file_descriptor().clone());
            let mut messages = ::std::vec::Vec::with_capacity(141);
            messages.push(HelloRequest::generated_message_descriptor_data());
            messages.push(HelloResponse::generated_message_descriptor_data());
            messages.push(ConnectRequest::generated_message_descriptor_data());
            messages.push(ConnectResponse::generated_message_descriptor_data());
            messages.push(DisconnectRequest::generated_message_descriptor_data());
            messages.push(DisconnectResponse::generated_message_descriptor_data());
            messages.push(PingRequest::generated_message_descriptor_data());
            messages.push(PingResponse::generated_message_descriptor_data());
            messages.push(DeviceInfoRequest::generated_message_descriptor_data());
            messages.push(AreaInfo::generated_message_descriptor_data());
            messages.push(DeviceInfo::generated_message_descriptor_data());
            messages.push(DeviceInfoResponse::generated_message_descriptor_data());
            messages.push(ListEntitiesRequest::generated_message_descriptor_data());
            messages.push(ListEntitiesDoneResponse::generated_message_descriptor_data());
            messages.push(SubscribeStatesRequest::generated_message_descriptor_data());
            messages.push(ListEntitiesBinarySensorResponse::generated_message_descriptor_data());
            messages.push(BinarySensorStateResponse::generated_message_descriptor_data());
            messages.push(ListEntitiesCoverResponse::generated_message_descriptor_data());
            messages.push(CoverStateResponse::generated_message_descriptor_data());
            messages.push(CoverCommandRequest::generated_message_descriptor_data());
            messages.push(ListEntitiesFanResponse::generated_message_descriptor_data());
            messages.push(FanStateResponse::generated_message_descriptor_data());
            messages.push(FanCommandRequest::generated_message_descriptor_data());
            messages.push(ListEntitiesLightResponse::generated_message_descriptor_data());
            messages.push(LightStateResponse::generated_message_descriptor_data());
            messages.push(LightCommandRequest::generated_message_descriptor_data());
            messages.push(ListEntitiesSensorResponse::generated_message_descriptor_data());
            messages.push(SensorStateResponse::generated_message_descriptor_data());
            messages.push(ListEntitiesSwitchResponse::generated_message_descriptor_data());
            messages.push(SwitchStateResponse::generated_message_descriptor_data());
            messages.push(SwitchCommandRequest::generated_message_descriptor_data());
            messages.push(ListEntitiesTextSensorResponse::generated_message_descriptor_data());
            messages.push(TextSensorStateResponse::generated_message_descriptor_data());
            messages.push(SubscribeLogsRequest::generated_message_descriptor_data());
            messages.push(SubscribeLogsResponse::generated_message_descriptor_data());
            messages.push(NoiseEncryptionSetKeyRequest::generated_message_descriptor_data());
            messages.push(NoiseEncryptionSetKeyResponse::generated_message_descriptor_data());
            messages.push(SubscribeHomeassistantServicesRequest::generated_message_descriptor_data());
            messages.push(HomeassistantServiceMap::generated_message_descriptor_data());
            messages.push(HomeassistantServiceResponse::generated_message_descriptor_data());
            messages.push(SubscribeHomeAssistantStatesRequest::generated_message_descriptor_data());
            messages.push(SubscribeHomeAssistantStateResponse::generated_message_descriptor_data());
            messages.push(HomeAssistantStateResponse::generated_message_descriptor_data());
            messages.push(GetTimeRequest::generated_message_descriptor_data());
            messages.push(GetTimeResponse::generated_message_descriptor_data());
            messages.push(ListEntitiesServicesArgument::generated_message_descriptor_data());
            messages.push(ListEntitiesServicesResponse::generated_message_descriptor_data());
            messages.push(ExecuteServiceArgument::generated_message_descriptor_data());
            messages.push(ExecuteServiceRequest::generated_message_descriptor_data());
            messages.push(ListEntitiesCameraResponse::generated_message_descriptor_data());
            messages.push(CameraImageResponse::generated_message_descriptor_data());
            messages.push(CameraImageRequest::generated_message_descriptor_data());
            messages.push(ListEntitiesClimateResponse::generated_message_descriptor_data());
            messages.push(ClimateStateResponse::generated_message_descriptor_data());
            messages.push(ClimateCommandRequest::generated_message_descriptor_data());
            messages.push(ListEntitiesNumberResponse::generated_message_descriptor_data());
            messages.push(NumberStateResponse::generated_message_descriptor_data());
            messages.push(NumberCommandRequest::generated_message_descriptor_data());
            messages.push(ListEntitiesSelectResponse::generated_message_descriptor_data());
            messages.push(SelectStateResponse::generated_message_descriptor_data());
            messages.push(SelectCommandRequest::generated_message_descriptor_data());
            messages.push(ListEntitiesSirenResponse::generated_message_descriptor_data());
            messages.push(SirenStateResponse::generated_message_descriptor_data());
            messages.push(SirenCommandRequest::generated_message_descriptor_data());
            messages.push(ListEntitiesLockResponse::generated_message_descriptor_data());
            messages.push(LockStateResponse::generated_message_descriptor_data());
            messages.push(LockCommandRequest::generated_message_descriptor_data());
            messages.push(ListEntitiesButtonResponse::generated_message_descriptor_data());
            messages.push(ButtonCommandRequest::generated_message_descriptor_data());
            messages.push(MediaPlayerSupportedFormat::generated_message_descriptor_data());
            messages.push(ListEntitiesMediaPlayerResponse::generated_message_descriptor_data());
            messages.push(MediaPlayerStateResponse::generated_message_descriptor_data());
            messages.push(MediaPlayerCommandRequest::generated_message_descriptor_data());
            messages.push(SubscribeBluetoothLEAdvertisementsRequest::generated_message_descriptor_data());
            messages.push(BluetoothServiceData::generated_message_descriptor_data());
            messages.push(BluetoothLEAdvertisementResponse::generated_message_descriptor_data());
            messages.push(BluetoothLERawAdvertisement::generated_message_descriptor_data());
            messages.push(BluetoothLERawAdvertisementsResponse::generated_message_descriptor_data());
            messages.push(BluetoothDeviceRequest::generated_message_descriptor_data());
            messages.push(BluetoothDeviceConnectionResponse::generated_message_descriptor_data());
            messages.push(BluetoothGATTGetServicesRequest::generated_message_descriptor_data());
            messages.push(BluetoothGATTDescriptor::generated_message_descriptor_data());
            messages.push(BluetoothGATTCharacteristic::generated_message_descriptor_data());
            messages.push(BluetoothGATTService::generated_message_descriptor_data());
            messages.push(BluetoothGATTGetServicesResponse::generated_message_descriptor_data());
            messages.push(BluetoothGATTGetServicesDoneResponse::generated_message_descriptor_data());
            messages.push(BluetoothGATTReadRequest::generated_message_descriptor_data());
            messages.push(BluetoothGATTReadResponse::generated_message_descriptor_data());
            messages.push(BluetoothGATTWriteRequest::generated_message_descriptor_data());
            messages.push(BluetoothGATTReadDescriptorRequest::generated_message_descriptor_data());
            messages.push(BluetoothGATTWriteDescriptorRequest::generated_message_descriptor_data());
            messages.push(BluetoothGATTNotifyRequest::generated_message_descriptor_data());
            messages.push(BluetoothGATTNotifyDataResponse::generated_message_descriptor_data());
            messages.push(SubscribeBluetoothConnectionsFreeRequest::generated_message_descriptor_data());
            messages.push(BluetoothConnectionsFreeResponse::generated_message_descriptor_data());
            messages.push(BluetoothGATTErrorResponse::generated_message_descriptor_data());
            messages.push(BluetoothGATTWriteResponse::generated_message_descriptor_data());
            messages.push(BluetoothGATTNotifyResponse::generated_message_descriptor_data());
            messages.push(BluetoothDevicePairingResponse::generated_message_descriptor_data());
            messages.push(BluetoothDeviceUnpairingResponse::generated_message_descriptor_data());
            messages.push(UnsubscribeBluetoothLEAdvertisementsRequest::generated_message_descriptor_data());
            messages.push(BluetoothDeviceClearCacheResponse::generated_message_descriptor_data());
            messages.push(BluetoothScannerStateResponse::generated_message_descriptor_data());
            messages.push(BluetoothScannerSetModeRequest::generated_message_descriptor_data());
            messages.push(SubscribeVoiceAssistantRequest::generated_message_descriptor_data());
            messages.push(VoiceAssistantAudioSettings::generated_message_descriptor_data());
            messages.push(VoiceAssistantRequest::generated_message_descriptor_data());
            messages.push(VoiceAssistantResponse::generated_message_descriptor_data());
            messages.push(VoiceAssistantEventData::generated_message_descriptor_data());
            messages.push(VoiceAssistantEventResponse::generated_message_descriptor_data());
            messages.push(VoiceAssistantAudio::generated_message_descriptor_data());
            messages.push(VoiceAssistantTimerEventResponse::generated_message_descriptor_data());
            messages.push(VoiceAssistantAnnounceRequest::generated_message_descriptor_data());
            messages.push(VoiceAssistantAnnounceFinished::generated_message_descriptor_data());
            messages.push(VoiceAssistantWakeWord::generated_message_descriptor_data());
            messages.push(VoiceAssistantConfigurationRequest::generated_message_descriptor_data());
            messages.push(VoiceAssistantConfigurationResponse::generated_message_descriptor_data());
            messages.push(VoiceAssistantSetConfiguration::generated_message_descriptor_data());
            messages.push(ListEntitiesAlarmControlPanelResponse::generated_message_descriptor_data());
            messages.push(AlarmControlPanelStateResponse::generated_message_descriptor_data());
            messages.push(AlarmControlPanelCommandRequest::generated_message_descriptor_data());
            messages.push(ListEntitiesTextResponse::generated_message_descriptor_data());
            messages.push(TextStateResponse::generated_message_descriptor_data());
            messages.push(TextCommandRequest::generated_message_descriptor_data());
            messages.push(ListEntitiesDateResponse::generated_message_descriptor_data());
            messages.push(DateStateResponse::generated_message_descriptor_data());
            messages.push(DateCommandRequest::generated_message_descriptor_data());
            messages.push(ListEntitiesTimeResponse::generated_message_descriptor_data());
            messages.push(TimeStateResponse::generated_message_descriptor_data());
            messages.push(TimeCommandRequest::generated_message_descriptor_data());
            messages.push(ListEntitiesEventResponse::generated_message_descriptor_data());
            messages.push(EventResponse::generated_message_descriptor_data());
            messages.push(ListEntitiesValveResponse::generated_message_descriptor_data());
            messages.push(ValveStateResponse::generated_message_descriptor_data());
            messages.push(ValveCommandRequest::generated_message_descriptor_data());
            messages.push(ListEntitiesDateTimeResponse::generated_message_descriptor_data());
            messages.push(DateTimeStateResponse::generated_message_descriptor_data());
            messages.push(DateTimeCommandRequest::generated_message_descriptor_data());
            messages.push(ListEntitiesUpdateResponse::generated_message_descriptor_data());
            messages.push(UpdateStateResponse::generated_message_descriptor_data());
            messages.push(UpdateCommandRequest::generated_message_descriptor_data());
            let mut enums = ::std::vec::Vec::with_capacity(34);
            enums.push(EntityCategory::generated_enum_descriptor_data());
            enums.push(LegacyCoverState::generated_enum_descriptor_data());
            enums.push(CoverOperation::generated_enum_descriptor_data());
            enums.push(LegacyCoverCommand::generated_enum_descriptor_data());
            enums.push(FanSpeed::generated_enum_descriptor_data());
            enums.push(FanDirection::generated_enum_descriptor_data());
            enums.push(ColorMode::generated_enum_descriptor_data());
            enums.push(SensorStateClass::generated_enum_descriptor_data());
            enums.push(SensorLastResetType::generated_enum_descriptor_data());
            enums.push(LogLevel::generated_enum_descriptor_data());
            enums.push(ServiceArgType::generated_enum_descriptor_data());
            enums.push(ClimateMode::generated_enum_descriptor_data());
            enums.push(ClimateFanMode::generated_enum_descriptor_data());
            enums.push(ClimateSwingMode::generated_enum_descriptor_data());
            enums.push(ClimateAction::generated_enum_descriptor_data());
            enums.push(ClimatePreset::generated_enum_descriptor_data());
            enums.push(NumberMode::generated_enum_descriptor_data());
            enums.push(LockState::generated_enum_descriptor_data());
            enums.push(LockCommand::generated_enum_descriptor_data());
            enums.push(MediaPlayerState::generated_enum_descriptor_data());
            enums.push(MediaPlayerCommand::generated_enum_descriptor_data());
            enums.push(MediaPlayerFormatPurpose::generated_enum_descriptor_data());
            enums.push(BluetoothDeviceRequestType::generated_enum_descriptor_data());
            enums.push(BluetoothScannerState::generated_enum_descriptor_data());
            enums.push(BluetoothScannerMode::generated_enum_descriptor_data());
            enums.push(VoiceAssistantSubscribeFlag::generated_enum_descriptor_data());
            enums.push(VoiceAssistantRequestFlag::generated_enum_descriptor_data());
            enums.push(VoiceAssistantEvent::generated_enum_descriptor_data());
            enums.push(VoiceAssistantTimerEvent::generated_enum_descriptor_data());
            enums.push(AlarmControlPanelState::generated_enum_descriptor_data());
            enums.push(AlarmControlPanelStateCommand::generated_enum_descriptor_data());
            enums.push(TextMode::generated_enum_descriptor_data());
            enums.push(ValveOperation::generated_enum_descriptor_data());
            enums.push(UpdateCommand::generated_enum_descriptor_data());
            ::protobuf::reflect::GeneratedFileDescriptor::new_generated(
                file_descriptor_proto(),
                deps,
                messages,
                enums,
            )
        });
        ::protobuf::reflect::FileDescriptor::new_generated_2(generated_file_descriptor)
    })
}
